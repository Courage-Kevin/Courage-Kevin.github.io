[{"title":"Java常用API小Demo","url":"/2020/02/06/Java常用API小Demo/","content":"\n# charAt\n&emsp;获取给定位置对应的字符\n```java\n\tpublic static void main(String[] args) {\n\t\t//            0123456789012345\n\t\tString str = \"thinking in java\";\t\t\n\t\tchar c = str.charAt(10);\n\t\tSystem.out.println(c);\n\t\t\n\t\t//判断回文            0 1 2 3  5 6 7 8\n\t\tString line = \"上海自来水自来海上\";\t\n\t\tfor(int i=0;i<line.length()/2;i++) {\n\t\t\tif(line.charAt(i) !=\n\t\t\t   line.charAt(line.length()-1-i)\t\t\n\t\t\t) {\n\t\t\t\tSystem.out.print(\"不\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"是回文!\");\n\t}\n```\n# indexOf\n&emsp;获取给定字符串在当前字符串中的位置，若当前字符串中不含有给定内容则返回值为-1\n\n```java\npublic class IndexOfDemo {\n\tpublic static void main(String[] args) {\n\t\t//            0123456789012345\n\t\tString str = \"thinking in java\";\n\t\t\n\t\tint index = str.indexOf(\"in\");\n\t\tSystem.out.println(index);//2\n\t\t\n\t\t//从指定位置开始检索第一次出现指定内容的位置\n\t\tindex = str.indexOf(\"in\",3);\n\t\tSystem.out.println(index);//5\n\t\t\n\t\t//检索最后一次出现指定内容的位置\n\t\tindex = str.lastIndexOf(\"in\");\n\t\tSystem.out.println(index);//9\n\t\t\n\t}\n}\n```\n   \n\n# lenght\n&emsp;获取当前字符串的长度(字符个数)\n```java\npublic class LengthDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"我爱java\";\n\t\tint len = str.length();\n\t\tSystem.out.println(\"len:\"+len);\n\t}\n}\n\n```\n\n\n# startsWith,endsWith\n&emsp;判断字符串是否是以给定的字符串开始或结尾的\n\n```java\npublic class StartsWithDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"thinking in java\";\n\t\t\n\t\tboolean starts = str.startsWith(\"thin\");\n\t\tSystem.out.println(starts);\n\n\t\tboolean ends= str.endsWith(\"ava\");\n\t\tSystem.out.println(ends);\n\t\t\n\t}\n}\n```\n\n\n\n# String\n&emsp;String是不变对象。JVM对String有一个优化，即:常量池,当使用字面量形式创建字符串对象时，JVM会将其缓存在常量池中，当再次使用该字面量创建字符串对象时即重用对象，避免内存中堆积大量内容一样的字符串对象，减少内存开销。\n\n```java\npublic class StringDemo {\n\tpublic static void main(String[] args) {\n\t\t//字面量  直接量\n\t\tString s1 = \"123abc\";\n\t\tString s2 = \"123abc\";\n\t\tString s3 = \"123abc\";\n\t\t//s2,s3重用了s1创建的对象\n\t\tSystem.out.println(s1==s2);\n\t\tSystem.out.println(s1==s3);\n\t\t/*\n\t\t * 字符串为不变对象\n\t\t * 即:字符串一旦创建，内容是不可以改变的，若想\n\t\t * 改变内容一定会创建新对象\n\t\t */\n\t\tSystem.out.println(s1);//123abc!\n\t\tSystem.out.println(s2);//123abc\n\t\tSystem.out.println(s1==s2);//不再相同\n\t\t\n\t\t/*\n\t\t * 这里发挥了编译器的一个特性:\n\t\t * 编译器在编译源代码时，若发现一个计算表达式\n\t\t * 参与运算的内容是确定值时，会在编译期间直接\n\t\t * 进行计算，并将计算结果编译到class文件中。避免\n\t\t * JVM每次执行程序时再做运算，从而提高性能。\n\t\t * 如下代码，编译器编译后改为了:\n\t\t * String s4 = \"123abc\";\n\t\t */\n\t\tString s4 = \"123\"+\"abc\";\n\t\tSystem.out.println(s4);//123abc\n\t\tSystem.out.println(s2==s4);//true\n\t\t\t\t\n\t\tString s5 = \"123\";\n\t\tString s6 = s5 + \"abc\";\n\t\tSystem.out.println(s6);//123abc\n\t\tSystem.out.println(s2==s6);//false\n\t}\n}\n\n```\n\n\n\n# substring\n&emsp;截取指定范围内的字符串 String substring(int start,int end)\n\n```java\npublic class SubStringDemo {\n\tpublic static void main(String[] args) {\n\t\t//            01234567890\n\t\tString str = \"www.tedu.cn\";\n\t\t/*\n\t\t * java api中有一个特点，通常使用两个数字表示\n\t\t * 范围时，都是\"含头不含尾\"的.\n\t\t */\n\t\tString sub = str.substring(4, 8);\n\t\tSystem.out.println(sub);//tedu\n\t\t/*\n\t\t * 一个参数的为从指定位置截取到字符串末尾\n\t\t */\n\t\tsub = str.substring(4);\n\t\tSystem.out.println(sub);\n\t\t\n\t}\n}\n```\n\n\n\n# ToUpperCase\n&emsp;将当前字符串中的英文部分转换为全大写或全小写\n\n```java\npublic class ToUpperCaseDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"我爱Java\";\n\t\t\n\t\tString upper = str.toUpperCase();\n\t\tSystem.out.println(upper);\n\t\t\n\t\tString lower = str.toLowerCase();\n\t\tSystem.out.println(lower);\n\t}\n}\n```\n\n\n\n\n# trim\n&emsp;去除当前字符串两边的空白字符\n\n```java\npublic class TrimDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"  hello\t\t\t\";\n\t\tString trim = str.trim();\n\t\tSystem.out.println(str);\n\t\tSystem.out.println(trim);\n\t}\n}\n\n```\n\n\n# valueOf\n&emsp;字符串提供了一组重载的valueOf方法。可以将其他类型转换为字符串\n\n```java\n\tpublic static void main(String[] args) {\n\t\tint d = 123;\n\t\tString str = String.valueOf(d);\n\t\tSystem.out.println(str);\n\t\t//任何内容和字符串连接结果也能转换为字符串\n\t\tstr = d + \"\";\n\t\tSystem.out.println(str);\n\t\t\n\t\tdouble dou = 123.123;\n\t\tString str2 = String.valueOf(dou);\n\t\tSystem.out.println(str2);\n\t}\n```\n\n\n\n\n# trim\n&emsp;去除当前字符串两边的空白字符\n\n```java\npublic class TrimDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"  hello\t\t\t\";\n\t\tString trim = str.trim();\n\t\tSystem.out.println(str);\n\t\tSystem.out.println(trim);\n\t}\n}\n\n```\n\n\n\n\n# Matches\n&emsp;字符串支持正则表达式方法一: 使用给定的正则表达式验证当前字符串是否符合格式要求,符合则返回true。\n\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString email = \"fancq@tedu.cn\";\n\t\t/*\n\t\t * 邮箱的正则表达式\n\t\t * \\w+@[a-zA-Z0-9]+(\\.[a-zA-Z]+)+\n\t\t */\n\t\tString regex = \"\\\\w+@[a-zA-Z0-9]+(\\\\.[a-zA-Z]+)+\";\n\t\tboolean match = email.matches(regex);\n\t\tif(match) {\n\t\t\tSystem.out.println(\"是邮箱!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"不是邮箱!\");\n\t\t}\n\t}\n\n```\n\n# replaceAll\n&emsp;字符串支持正则表达式方法三:\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString str = \"abc123def456ghi\";\n\t\t/*\n\t\t * 将当前字符串中的数字部分替换为\"#NUMBER#\"\n\t\t */\n\t\tstr = str.replaceAll(\"\\\\d+\", \"#NUMBER#\");\n\t\tSystem.out.println(str);\n\t}\n```\n\n\n# Split\n&emsp; 字符串支持正则表达式方法二: 将当前字符串中按照满足正则表达式的部分进行拆分，并将拆分出的每部分以一个字符串数组形式返回。\n\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString str = \"abc123def456ghi\";\n\t\t/*\n\t\t * 按照数字部分拆分，得到所有的字母部分\n\t\t */\n\t\tString[] arr = str.split(\"[0-9]+\");\n\t\tSystem.out.println(arr.length);\n\t\tSystem.out.println(Arrays.toString(arr));\n\t\t\n\t\t/*\n\t\t * 如果连续匹配了两次要拆分的内容时，中间会拆分\n\t\t * 出一个空字符串，但是若在字符串末尾连续匹配则\n\t\t * 所有拆分出的空字符串都会被忽略。\n\t\t */\n\t\tstr = \"abc,,,def,ghi,,,,,,,,,,,,,,,,,,,\";\n\t\tarr = str.split(\",\");\n\t\tSystem.out.println(arr.length);\n\t\tSystem.out.println(Arrays.toString(arr));\n\n```\n\n\n\n\n# StringBuilder  \n\n1. StringBuilder是专门设计用来编辑字符串内容的API。由于String不适合频繁修改，所以在实际开发中如果有经常，修改字符串的操作时，可以使用StringBuilder来完成。\n2. StringBuilder内部维护一个可变的字符数组，所以修改的过程中资源开销小。并且提供了对应的操作:增，删，改，插\n\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString str = \"好好学习java\";\n\t\t//默认方式创建内部表示一个空字符串:\"\"\n//\t\tStringBuilder builder = new StringBuilder();\n\t\t//创建时表示给定字符串内容\n\t\tStringBuffer builder = new StringBuffer(str);\n\t\t/*\n\t\t * 好好学习java\n\t\t * 好好学习java,为了找个好工作!\n\t\t * append:将指定内容追加到当前字符串末尾\n\t\t */\n\t\tbuilder.append(\",为了找个好工作!\");\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t\t\n\t\t/*\n\t\t * 好好学习java,为了找个好工作!\n\t\t * 好好学习java,就是为了改变世界!\n\t\t * replace:将指定范围内的字符串替换为给定内容\n\t\t */\n\t\tbuilder.replace(9, 16, \"就是为了改变世界\");\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t\t\n\t\t/*\n\t\t * 好好学习java,就是为了改变世界!\n\t\t * ,就是为了改变世界!\n\t\t * delete:删除指定范围内的字符串\n\t\t */\n\t\tbuilder.delete(0, 8);\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t\t\n\t\t/*\n\t\t * ,就是为了改变世界!\n\t\t * 活着,就是为了改变世界!\n\t\t * insert:将指定内容插入到指定位置\n\t\t */\n\t\tbuilder.insert(0, \"活着\");\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t}\n\n\n```\n\n\n\n\n# StringBuilder效率测试\n\n```java\n\tpublic static void main(String[] args) {\n\t\tStringBuilder builder = new StringBuilder(\"a\");\n\t\tfor(int i=0;i<10000000;i++) {\n\t\t\tbuilder.append(\"a\");\n\t\t}\n\t\tSystem.out.println(\"执行完毕!\");\n\t}\n```\n\n\n\n\n# 包装类\n&emsp;包装类是为了解决基本类型不能直接参与面向对象开发的问题，其中6个数字类型的包装类都继承自java.lang.Number。其余两个直接继承自Object，Number是一个抽象类，定义了数字类型包装类公有的行为，允许在数字类型之间互转。\n\n\n```java\n\t\tpublic static void main(String[] args) {\n\t\tint d = 128;\n//      将基本类型转换为包装类\n//\t\tInteger i1 = new Integer(d);\n//\t\tInteger i2 = new Integer(d);\n\t\t\n\t\t//从基本类型转换为包装类建议使用valueOf方法:\n\t\tInteger i1 = Integer.valueOf(d);\n\t\tInteger i2 = Integer.valueOf(d);\n\t\t\n\t\tSystem.out.println(i1==i2);//false\n\t\tSystem.out.println(i1.equals(i2));//true\n\t\t\n\t\tdouble dou = 1.0;\n\t\tDouble dou1 = Double.valueOf(dou);\n\t\tDouble dou2 = Double.valueOf(dou);\n\t\tSystem.out.println(dou1==dou2);\n\t\tSystem.out.println(dou1.equals(dou2));\n\t\t\n\t\t/*\n\t\t * 将包装类转换为基本类型\n\t\t */\n\t\t int in = i1.intValue();\n\t\t System.out.println(in);\n\t\t\n\t\t double dd = i1.doubleValue();\n\t\t System.out.println(dd);\n\t\t \n\t\t //可能出现溢出问题\n\t\t byte b = i1.byteValue();\n\t\t System.out.println(b);\n\t\t \n\t\t /*\n\t\t  * 数字类型的包装类都支持两个常量:\n\t\t  * MAX_VALUE,MIN_VALUE\n\t\t  * 用于表示其对应的基本类型数据的取值范围\n\t\t  */\n\t\t //int最大值与最小值?\n\t\t int imax = Integer.MAX_VALUE;\n\t\t System.out.println(imax);\n\t\t\n\t\t int imin = Integer.MIN_VALUE;\n\t\t System.out.println(imin);\n\t\t\n\t\t long lmax = Long.MAX_VALUE;\n\t\t System.out.println(lmax);\n        }\n}\n\n```\n  \n# Integer\n&emsp;JDK5发布时，推出了一个特性:自动拆装箱,允许编译器在编译源代码时将基本类型与引用类型之间互相,赋值时补全代码自动进行转换。\n\n```java\n\t\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 触发了编译器自动拆箱特性:\n\t\t * 编译器会将下面的代码改为\n\t\t * int d = new Integer(1).intValue();\n\t\t */\n\t\tint d = new Integer(1);\n\t\t/*\n\t\t * 触发了自动装箱特性:\n\t\t * 编译器会改为:\n\t\t * Integer i = Integer.valueOf(d);\n\t\t */\n\t\tInteger i = d;\n\t}\n\n```\n\n\n    \n# parse\n&emsp;包装类提供了一个静态方法:parseXXX(String str)，可以将给定的字符串转换为对应的基本类型，前提是该字符串，内容要正确的描述基本类型可以保存的值\n\n```java\n\t\tpublic static void main(String[] args) {\n\t\tString str = \"123\";\n\t\tint d = Integer.parseInt(str);\n\t\tSystem.out.println(d);\n\t\t\n\t\tdouble dou = Double.parseDouble(str);\n\t\tSystem.out.println(dou);\n\t}\n\n```\n\n\n    \n# Object常用方法\n&emsp;使用当前类测试Object常用方法:\n\n```java\n\tpublic class Point {\n\tprivate int x;\n\tprivate int y;\n\tpublic Point(int x, int y) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic int getX() {\n\t\treturn x;\n\t}\n\tpublic void setX(int x) {\n\t\tthis.x = x;\n\t}\n\tpublic int getY() {\n\t\treturn y;\n\t}\n\tpublic void setY(int y) {\n\t\tthis.y = y;\n\t}\n\t/**\n\t * 重写toString方法。\n\t * toString方法是一个非常常用的方法，很多API的操作\n\t * 都会间接调用该方法。\n\t * 方法的目的是将当前对象转换为字符串，具体返回的字符串\n\t * 格式没有固定要求，遵循的原则是返回的内容中包含当前\n\t * 对象的属性信息，可以通过该字符串的内容直观反应出当前\n\t * 对象的内容。\n\t */\n\tpublic String toString() {\n\t\t//(1,2)\n\t\treturn \"(\"+x+\",\"+y+\")\";\n\t}\n\t\n\t/**\n\t * Object定义的equals方法的设计意图是比较两个对象的\n\t * 内容是否相同。\n\t * 如果不重写该方法，那么Object内部是用\"==\"比较的，\n\t * 这样就失去了equals比较的意义了。所以当我们需要调用\n\t * 一个类的equals时，该方法就应当重写。\n\t * 注:java提供的类大部分都已经重写过了。只有我们自定义\n\t * 的类需要自行重写。\n\t * \n\t * p.equals(p2)\n\t * this:p\n\t * o:p2\n\t */\n\tpublic boolean equals(Object o) {\n\t\tif(o==null) {\n\t\t\treturn false;\n\t\t}\n\t\tif(this==o) {\n\t\t\treturn true;\n\t\t}\n\t\tif(o instanceof Point) {\n\t\t\tPoint p = (Point)o;\n\t\t\treturn this.x==p.x&&this.y==p.y;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n# 文件复制\n```java\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t//创建一个RAF用于读取原文件\n\t\tRandomAccessFile src\n\t\t\t= new RandomAccessFile(\"mv.mp4\",\"r\");\n\t\t\n\t\t//再创建另一个RAF用于向复制文件中写\n\t\tRandomAccessFile desc\n\t\t\t= new RandomAccessFile(\"mv_cp.mp4\",\"rw\");\n\t\t//用于记录每次读取到的字节\n\t\tint d = -1;\n\t\t/*\n\t\t * 循环从原文件中读取每一个字节，只要没有读取到\n\t\t * 文件末尾，就将读取到的字节写入到复制文件中。\n\t\t */\n\t\tlong start = System.currentTimeMillis();\n\t\twhile( (d = src.read())  != -1  ) {\n\t\t\tdesc.write(d);\n\t\t}\n\t\tlong end = System.currentTimeMillis();\n\t\tSystem.out.println(\"复制完毕!耗时:\"+(end-start)+\"ms\");\n\t\t\n\t\tsrc.close();\n\t\tdesc.close();\n\t}\n```\n\n\n#  java.io.RandomAccessFile类\n&emsp; 用来读写文件数据的类，其基于指针对文件数据进行读写操作\n\n```java\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t/*\n\t\t * RandomAccessFile创建有两种模式:\n\t\t * r:只读模式，只读取文件数据，并不会写入内容\n\t\t * rw:读写模式，对文件既可以读也可以写。\n\t\t * \n\t\t * 常见构造方法:\n\t\t * RandomAccessFile(String path,String mode)\n\t\t * RandomAccessFile(File file,String mode)\n\t\t * mode:创建的模式(r,rw)\n\t\t */\n\t\t/*\n\t\t * 对当前目录下的raf.dat文件进行读写操作\n\t\t * 对于\"rw\"模式创建时，若指定的文件不存在时会自动\n\t\t * 创建出来，若为\"r\"只读模式时，若指定的文件不存在\n\t\t * 则会直接抛出异常:FileNotFoundException\n\t\t */\n\t\tRandomAccessFile raf = new RandomAccessFile(\"raf.dat\",\"rw\");\t\n\t\t/*\n\t\t * void write(int d)\n\t\t * 向文件中写入1个字节，写入的是给定的int值对应的\n\t\t * 2进制的\"低八位\"\n\t\t *                            vvvvvvvv\n\t\t * 00000000 00000000 00000000 00000010\n\t\t * 00000000 00000000 00000000 11111111\n\t\t * 00000000 00000000 00000001 00000000\n\t\t * \n\t\t * 00000001 00000010\n\t\t */\n\t\traf.write(1);\n\t\traf.write(2);\n\t\tSystem.out.println(\"写出完毕!\");\n\t\t\n\t\traf.close();\n\t\t\n\t}\n\n\n```\n\n\n# 创建文件\n&emsp;使用File创建一个新文件\n\n```java\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t/*\n\t\t * 在当前目录下新建一个文件test.txt\n\t\t */\n\t\tFile file = new File(\"./test.txt\");\n\t\t//判断File表示的文件或目录是否已经真实存在了\n\t\tif(!file.exists()) {\n\t\t\t//将File表示的文件创建出来\n\t\t\tfile.createNewFile();\n\t\t\tSystem.out.println(\"文件创建成功!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"文件已存在!\");\n\t\t}\n\t}\n```\n\n\n# 删除文件\n&emsp;删除一个文件\n```java\n\t\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 删除当前目录下的test.txt\n\t\t * \"./\"可以忽略不写，默认就是当前目录\n\t\t */\n\t\tFile file = new File(\"test.txt\");\n\t\tif(file.exists()) {\n\t\t\tfile.delete();\n\t\t\tSystem.out.println(\"文件已删除!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"文件不存在!\");\n\t\t}\n\t}\n\n\n```\n\n# 创建目录\n&emsp;创建一个目录\n```java\n\t\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 在当前目录下新建一个目录:demo\n\t\t */\n\t\tFile dir = new File(\"demo\");\n\t\tif(!dir.exists()) {\n\t\t\t//创建该目录\n\t\t\tdir.mkdir();\n\t\t\tSystem.out.println(\"目录已创建!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"目录已存在!\");\n\t\t}\n\t}\n```\n\n# 创建多级目录\n&emsp;创建一个多级目录\n```java\n\tpublic static void main(String[] args) {\n\t\t/*\n\t\t *\t在当前目录下新建目录:\n\t\t *\t./a/b/c/d/e/f\n\t\t */\n\t\tFile dir = new File(\"./a/b/c/d/e/f\");\n\t\tif(!dir.exists()) {\n\t\t\t/*\n\t\t\t * mkdirs会将所有不存在的父目录一同创建出来\n\t\t\t */\n\t\t\tdir.mkdirs();\n\t\t\tSystem.out.println(\"目录已创建!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"目录已存在!\");\n\t\t}\n    }\n```","tags":["基础知识"],"categories":["Java基础知识"]},{"title":"Http协议基础知识","url":"/2020/02/06/Http协议基础知识/","content":"\n# Http协议  \n\n## 什么是http协议\n当在上网浏览网页的时候，浏览器和服务器之间就会通过Http在Internet上进行数据的发送和接受。\nHTTP协议规定了浏览器和服务器之间通信的方式，也可以说是通信的规则。是应用层协议，是一个基于请求/响应模式的，无状态的协议。\n> 具体说，HTTP协议中主要规定了两个内容：\n    > 1. 规定了浏览器该如何给服务器发送请求信息（即请求信息的格式）\n    > 2. 同时也规定了服务器该如何给浏览器做响应信息（即响应信息的格式）   \n\n---\n\n## Http1.0\n> 当连接建立之后，浏览器发送一个请求，服务器回应一个消息，之后连接就被关闭。当浏览器下一次请求的时候，需要重新建立新的连接，显然这种需要不断建立连接的通信方式开销较大。早期的web页面通常只包含HTML文件，因此即使建立连接的开销比较大，也不会有太大的影响。而现在的web页面通常包含多种资源，（图片，动画，声音），每获取一种资源，就建立一次连接。这样就增加了HTTP服务器的开销，造成了Internet上的信息阻塞。\n---\n\n## Http1.1\n> 因此在Http1.1版本中，给出了一个持续连接的机制，并将其作为1.1中建立连接的缺省行为，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到响应，然后继续发送请求并在此得到回应，而且客户端还可以发送流水线请求，也就是说，客户端可以连续发送多个请求，而不用等待每一个响应的到来。\n---   \n\n## 三次握手\n>1. 客户端与服务器端建立连接前，客户端会向服务器发送第一条消息，询问服务器端是否准备好了。第一次握手\n>2. 服务器端收到客户端发来的询问之后，会给客户端发送一条消息，告诉客户端已经准备好了。第二次握手\n>3. 当客户端在收到服务器端发过来的消息之后，会在此确认，客户端会在向服务器发起响应确认准备好了，第三次握手。之后建立连接\n   \n---   \n\n## Http工作时遵循的基本原则(了解):\n> 1. 基于请求响应模型\n> 2. 一次请求只对应一次响应\n> 3. 只能是浏览器向服务器发送请求, 服务器只能等待浏览器的请求, 再根据请求做出回应\n--- \n\n## GET请求和POST请求方式的区别：\n两者之间的区别主要体现在请求参数发送过程的不相同\n> GET提交: 通过请求行拼接参数将数据发送给服务器\n    > &emsp;1.通过地址栏携带参数, 相对不安全\n    > &emsp;2.通过地址栏发送数据, 数据量不能太大(不能超过1kb或者是4kb);  \n\n> POST提交: 通过请求实体内容携带参数, 数据不会显示在地址栏\n    > &emsp;1.参数不会出现地址栏, 相对更安全\n    > &emsp;2.数据通过请求实体内容发送, 数据量理论上没有限制.\n---\n\n\n## 服务器种类：\n> Tomcat、Resin、Jetty、Weblogic、WebSphere、JBoss\n\n> B/S：Browser Server 浏览器服务器模型  （不需要下载客户端的） 京东、淘宝、网页游戏。\n> 优点：不需要下载客户端程序，使用浏览器可以直接访问，程序的升级操作是在服务器端进行的。\n> 缺点：浏览器具有一定的局限性，页面的展示差，页面的数据需要从服务器实时获取，对网速的依赖很高\n\n> C/S：Client Server客户端服务器模型       （需要下载客户端的） QQ  LOL 梦幻西游 。\n> 优点：客户端可以任意设计，页面的展示能力强。由于大量资源已经保存在了客户端，对服务器的交互仅仅是一些数据的变化，对于网速的依赖很低。\n> 缺点：第一次使用时需要下载客户端程序，一旦程序需要升级操作，所有的客户端程序都需要升级。\n---\n\n## XML解析方式：\n### DOM解析：\n>原理：\n\t> 解析器将整个xml文档加载进内存，保存为一颗Document的对象树，\n\t> 通过Document对象，得到树上的节点对象，对每个对象提供增删改查操作对应的方法\n>优点：\n\t> &emsp;1.可以十分方便对节点进行增删改查操作，\n\t> &emsp;2.解析一次即可重复使用数据由于在内存中保存了文档结构树，\n>缺点：\n\t> &emsp;1.如果文档较大，占用内存空间，甚至内存溢出\n\t> &emsp;2.将整个文档解析完才能操作，相对耗费时间，效率低\n   \n\n### SAX解析：\n> 原理：解析器逐行扫描xml文档，利用处理器接口中的方法进行解析\n> 优点：\n\t> &emsp;1.无需将整个xml文档加载到内存，占用内存小\n\t> &emsp;2.由于逐行解析，遇到需要内容停下来处理，效率高\n> 缺点：\n\t> &emsp;1.每次需要数据，都要重新解析\n    > &emsp;2.只能读取数据，不能做增删改操作。   \n\n---","tags":["基础知识"],"categories":["http"]},{"title":"Servlet基础知识","url":"/2018/02/15/Servlet基础知识/","content":"\n# Servlet\n\n## Servlet概述\n> 1. Servlet本质上一段java程序\n> 2. Servlet程序无法独立运行，必须放在服务器中，由服务器调用才可以执行！\n> 3. Servlet的作用是：接受请求、处理请求、将结果响应给浏览器。\n\n## Servlet的作用\n> Servlet的作用就是处理请求，服务器会将接受到的请求交给Servlet处理。这个过程为：\n> 1. 客户端发送请求至服务器端；\n> 2. 服务器将请求信息交给 Servlet 处理；\n> 3. 最终处理的结果交给服务器；\n> 4. 服务器将结果响应给客户端。\n\n## Servlet调用过程\n> ![avatar](/images/servlet调用执行流程.png)\n> 1. 浏览器向服务器发起请求\n> 2. 首先会根据请求头信息获知浏览器访问的是那个虚拟主机\n> 3. 然后根据请求行中的路径资源获知浏览器访问的是哪一个web应用\n> 4. 根据请求行中的资源路径获知访问的是哪一个资源\n> 5. 根据获取到的资源路径到web.项目文件中去匹配真实路径，创建servlet实例并调用service方法\n> 6. 调用service方法前，底层会创建两个对象，Requset、response，通过request获取请求相关信息\n> 7. 通过response想浏览器发送响应数据，然后按照Http协议规定的格式，组织成相应消息，最后发送给浏览器\n\n## Servlet生命周期\n> &emsp;Servlet在第一次被访问时创建Servlet实例, 创建之后服务器会立即调用init方法进行初始化的操作, 创建之后, Servlet实例会一直驻留在服务器的内存中, 为后续的请求服务. 只要有请求来访问这个Servlet, 服务器就会调用service方法来处理请求, 直到服务器关闭, 或者WEB应用被移出容器, 随着WEB应用的销毁, Servlet实例也会跟着销毁, 在销毁之前服务器会调用destroy方法进行善后的处理。\n\n## 请求、转发、域对象\n> 1. 域对象：\n    > &emsp;能够在指定的范围内, 利用自身的map实现数据的共享  \n\n> 2. 请求转发：\n    > &emsp;是指定服务器中的某一个资源（Servlet或JSP）在处理请求的过程中，将请求转发给一个其他的资源，让其他资源来处理请求转发只能在同一个Web应用内部的两个资源之间进行跳转, 不可以是不同的Web应用或者不同的服务器中进行跳转,请求转发是一次请求，一次响应，转发前后地址栏地址不会发生变化  \n\n> 3. 重定向：\n\t> &emsp;是指当用户浏览某个网址时，将其导向到另一个网址的技术。重定向和定时刷新都是两次请求两次响应，重定向和定时刷新前后，地址栏地址都会发生变化\n\n> 4. 总结:\n > 定时刷新和重定向都是两次请求, 两次响应\n > 定时刷新和重定向跳转前后, 地址栏地址都会发生变化。\n > 定时刷新和重定向在跳转时没有限制, 既可以在同一个Web应用内部的资源之间进行跳转, 也可以在不同的Web应用或者不同的主机之间进行跳转\n > 定时刷新和重定向不同的是, 重定向是立即跳转, 中间没有时间间隔, 而定时刷新可以指定多少秒之后再进行跳转, 在跳转之前, 可以输出内容到浏览器, 提示用户。\n\n### EL表达式的作用: \n> &emsp;在Web开发中, 实现很多功能的时候, 都是由Servlet接收请求、处理请求，但是处理的结果应该交给JSP显示，此时我们可以在Servlet中将请求处理的结果存入request域中，再通过转发将Request域带到JSP中，再通过EL表达式将request域中的数据取出来, 显示在网页上.\n\n","tags":["基础知识"],"categories":["Servlet基础知识"]},{"title":"JDBC知识总结","url":"/2018/02/08/Jdbc知识总结/","content":"\n# JDBC：\n ## 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库\n* JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。\n\n## 快速入门：  \n开发步骤：\n1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar\n2. 注册驱动\n3. 获取数据库连接对象 Connection\n4. 定义sql\n5. 获取执行sql语句的对象 Statement\n6. 执行sql，接受返回结果\n7. 处理结果\n8. 释放资源\n\t\n## 代码实现：\n```java \n    //1. 导入驱动jar包\n    //2.注册驱动\n    Class.forName(\"com.mysql.jdbc.Driver\");\n    //3.获取数据库连接对象\n    Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\");\n    //4.定义sql语句\n    String sql = \"update account set balance = 500 where id = 1\";\n    //5.获取执行sql的对象 Statement\n    Statement stmt = conn.createStatement();\n    //6.执行sql\n    int count = stmt.executeUpdate(sql);\n    //7.处理结果\n    System.out.println(count);\n    //8.释放资源\n    stmt.close();\n    conn.close();\n```\n# 详解各个对象：\n1. DriverManager：驱动管理对象,用于注册驱动，告诉程序该使用哪一个数据库驱动jar,获取数据库连接。\n2. Connection：数据库连接对象:获取执行sql的对象,管理事务\n3. Statement：执行sql的对象\t\t\t\n4. ResultSet：结果集对象,封装查询结果\n5. PreparedStatement：执行sql的对象\n    1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题\n    2. 解决sql注入问题：使用PreparedStatement对象来解决\n    3. 预编译的SQL：参数使用?作为占位符\n  \n\n# 抽取JDBC工具类 ： JDBCUtils\n## 代码实现：\n```java \n    public class JDBCUtils {\n    private static String url;\n    private static String user;\n    private static String password;\n    private static String driver;\n    /**\n        * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块\n        */\n    static{\n        //读取资源文件，获取值。\n\n        try {\n            //1. 创建Properties集合类。\n            Properties pro = new Properties();\n\n            //获取src路径下的文件的方式--->ClassLoader 类加载器\n            ClassLoader classLoader = JDBCUtils.class.getClassLoader();\n            URL res  = classLoader.getResource(\"jdbc.properties\");\n            String path = res.getPath();\n            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties\n            //2. 加载文件\n            // pro.load(new FileReader(\"D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties\"));\n            pro.load(new FileReader(path));\n\n            //3. 获取数据，赋值\n            url = pro.getProperty(\"url\");\n            user = pro.getProperty(\"user\");\n            password = pro.getProperty(\"password\");\n            driver = pro.getProperty(\"driver\");\n            //4. 注册驱动\n            Class.forName(driver);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n​\t\n```java \n\t    /**\n\t     * 获取连接\n\t     * @return 连接对象\n\t     */\n\t    public static Connection getConnection() throws SQLException {\n\t\n\t        return DriverManager.getConnection(url, user, password);\n\t    }\n\t\n\t    /**\n\t     * 释放资源\n\t     * @param stmt\n\t     * @param conn\n\t     */\n\t    public static void close(Statement stmt,Connection conn){\n\t        if( stmt != null){\n\t            try {\n\t                stmt.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( conn != null){\n\t            try {\n\t                conn.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n```\n\n​\t\n```java\n\t    /**\n\t     * 释放资源\n\t     * @param stmt\n\t     * @param conn\n\t     */\n\t    public static void close(ResultSet rs,Statement stmt, Connection conn){\n\t        if( rs != null){\n\t            try {\n\t                rs.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( stmt != null){\n\t            try {\n\t                stmt.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( conn != null){\n\t            try {\n\t                conn.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n\t\n\t}\n```\t\n\n## JDBC控制事务：\n1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。\n2. 操作：\n    1. 开启事务\n    2. 提交事务\n    3. 回滚事务\n3. 使用Connection对象来管理事务\n    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务\n        * 在执行sql之前开启事务\n    * 提交事务：commit() \n        * 当所有sql都执行完提交事务\n    * 回滚事务：rollback() \n        * 在catch中回滚事务\n\n\n​\t\t\t","tags":["基础知识"],"categories":["Jdbc基础知识"]},{"title":"Java基础知识总结","url":"/2018/02/05/Java基础知识总结/","content":"Java基础知识整理\n<!--more-->\n# 基础部分\n## Java编译运行过程\n1. 编译期：java源文件，经编译生成.class文件\n2. 运行期：JVM加载.class文件，并运行class\n3. 特点：跨平台，一次编译到处使用\n\n## 名词释义\n1. JVM：java虚拟机，作用就是加载.class文件，运行.class文件\n2. JRE： java开发环境，除了包含JVM外，还包含java程序运行所必须的环境\n3. JDK：java开发工具包，除了包含JRE外，还包含编译，运行等命令工具3. \n\n## 数据类型\n| **byte类型**     | **8位**  | **范围：-128~127**               |\n| ---------------- | -------- | --------------------------------|\n| **short 类型**   | **16位** | **范围：-32768~32767**           |\n| **char  类型**   | **16位** | **范围：\\u0000~\\u65535**         |\n| **int类型**      | **32位** | **范围：-2147483648~2147483647** |\n| **long 类型**    | **64位** | **范围：很大很大 2^63**           |\n| **float 类型**   | **32位** |                                  |\n| **double 类型**  | **64位** |                                  |\n| **boolean 类型** | **8位**  |                                  |\n\n\n## 基本类型自动转换\n1. 从小到大依次为：byte < short < int < long < float < double\n2. 自动类型转换：小类型转大类型 （小杯子往大杯子倒水）\n3. 强制类型转换：大类型转小类型 （大杯子往小杯子倒数）\n\n## 运算符\n1. 算数：    +，-，*，/，%，++，--\n2. 关系：>,<,>=,<=,==,!=,boolean\n3. 逻辑：&&，||，!boolean\n4. 赋值：=，+=，-=，*=，/=，%=\n5. 字符连接运算符：+\n6. 条件/三目运算：boolean?数1:数2;\n\n## 分支结构\n1. If\n2. If…else\n3. If…elss     if\n4. Switch…case\n\n## 循环\n1. while循环\n2. do...while循环\n3. for循环\n\n\n\n## 数组\n1. 数组的定义：int [ ] arr =new int [ 10 ] \n2. 数组的初始化：int [ ] arr = new int [ ] \n3. 数组的访问：通过数组名.length可以获取数组的长度，也就是数组内元素的个数通过索引来访问数组元素，下标从0开始，最大到数组长度-1\n4. 数组遍历\n   ```java\n   int[] arr = new int[10];\n   \n   for (int i = 0; i < arr.length; i++) {\n       arr[3] = (int) (Math.random() * 100);\n   }\n   \n   for (int i = 0; i < arr.length; i++) {\n       System.out.println(arr[i]);    //正序输出\n   }\n   \n   for (int i = arr.length - 1; i >= 0; i--) {\n       System.out.println(arr[i]);    //倒序输出\n   }\n   ```\n\n## 访问修饰符\n| **private**   | **同类可见**               | **可以修饰变量、方法**           | **注意：不能修饰类(外部类)** |\n| ------------- | -------------------------- | -------------------------------- | ---------------------------- |\n| **default**   | **同包同类可见**           | **可以修饰类、接口、变量、方法** |                              |\n| **protected** | **同包同类和所有子类可见** | **可以修饰变量、方法**           | **注意不能修饰类(外部类)**   |\n| **public**    | **所有类可见**             | **可以修饰类、接口、变量、方法** |                              |\n\n\n\n## 非访问修饰符\n&emsp;为了实现某一些功能，java也提供了许多非访问修饰符\n> static修饰符：\n   > 1. static关键字修饰的变量称之为静态变量，无论一个类实例化多少对象，他的静态变量只有唯一的一个。\n   > 2. static关键字修饰的方法称之为静态方法，静态方法只能使用类的静态变量，不可以使用非静态变量。\n\n> final修饰符：\n  > 1. Final关键字可以修饰类，表示不能有子类。\n  > 2. Final关键字可以修饰变量，表示变量不能被修改，只能有唯一一次赋值。\n  > 3. Final关键字可以修饰方法，表示不能被子类覆盖重写。\n  > 4. Final关键字修饰引用类型变量，地址值不能变，但是对象的属性可以通过set方法改变。\n\n> abstract修饰符：<font color=red>被abstract修饰的类和方法叫做抽象类和抽象方法</font>。\n  > 1. 抽象类：抽象类不能用来实例化对象，目的：是为了将来对该类进行扩充。\n  > 2. 抽象方法：继承抽象类的子类必须实现父类的所有抽象方法，除非这个子类也是抽象类，\n  > 3. 注意：如果一个类包含若干个抽象方法，那么该类必须声明为抽象类，抽象类不可以包含抽象方法。  \n\n> 抽象加单总结:\n  > 1. 抽象方法的意义：在于将方法的设计和方法的实现分离。\n  > 2. 抽象类需要被继承，抽象类定义的抽象方法子类必须重写。\n  > 3. 抽象类不能创建对象，但是可以包含构造方法，成员属性，普通方法。\n\n---\n\n# 内部类\n&emsp;一个事物的内部包含另外一个事物，就是一个类内部包含另外一个类，比如身体和心脏的关系，汽车和发动机的关系。\n> ## 成员内部类：\n > 定义在类里面的类，叫做成员内部类。\n > 使用成员内部类的两种方式:\n    > 1. 间接方式：在外部类的方法中，使用内部类，然后main只是调用外部类的方法。\n    > 2. 直接方式：外部类名称.内部类名称   \n    > 对象名 = new 外部类名称() . new 内部类名称(); (外部.内部)  \n\n> ## 局部内部类\n    > &emsp;定在在方法里面的类，叫做局部内部类，局部内部类包含了匿名内部类。  \n\n> ## 匿名内部类\n    > 作用：如果接口的实现类，或者是父类的子类，只需要使用唯一一次，那么这种情况下，就可以省略该类的定义，改用匿名内部类。\n    > 定义格式：接口名称  对象名 = new 接口名称(){ //方法体中重写所有的抽象方法 }； \n```java\npublic class MainDemo {\n    public static void main(String[] args) {\n        Myinterface myinterface = new Myinterface() {\n            @Override\n            public void method() {\n                System.out.println(\"匿名内部类方法执行\");\n            }\n        };\n        myinterface.method();\n    }\n}\n```\n---   \n\n# 面向对象\n## 什么是类？\n> 类是一个模板，包含对象的属性，方法。 \n> 我们把它理解为造汽车的图纸，图纸包含了制造汽车的各个部件的尺寸，参数等。\n\n## 什么是对象？\n> 对象是类的一个实例。\n> 我们可以对象理解为根据图纸制造出来的汽车。  \n\n## 类和对象之间的关系？  \n> 汽车就好比一个对象，图纸就好比是一个类，有了图纸才能设计出汽车，换而言之也就是有了类才能创建对象（也叫实例）。  \n\n## 面向对象的特征?\n> 记住并理解这重要的6个字，<font color=red>*封装、继承、多态*</font>&emsp;称之为面向对象的三大特征 。\n### 1. 封装  \n\n> #### 封装的概念：\n&emsp;面向对象的封装就是把描述一个对象的属性和行为的代码封装到一个类当中，属性用变量定义，行为用方法定义，然后运用访问修饰符，修饰成员变量及方法，就基本上实现了对象的封装。    \n        \n> #### 封装的好处：\n&emsp;封装的目标就是要实现软件内部的“高内聚、低耦合”，防止程序相互依赖而带来的变动的影响。解耦\n\n> #### 封装的总结：\n封装类，封装的就是对象的属性和行为。\n封装方法，封装的就是具体业务逻辑功能的实现。\n访问控制，访问修饰符（private、public....）用来封装具体的访问权限。\n\n### 2. 继承  \n> #### 封装的概念：\n&emsp; 继承也是泛化（抽取共性）的过程，在开发中我们先将子类共有的属性及方法全部抽取到父类，然后通过子类去继承父类的属性及方法实现数据和方法的共享，这是类之间的一种关系，<font color=red>继承的好处就是提高了代码的可重用性和扩展性</font>。\n\n\n### 3. 多态\n\n> #### 多态的概念\n&emsp; 一个对象拥有多种形态，这就是多态，代码体现多态其实就是一句话，<font color=red>父类引用指向子类对象</font>  \n\n> #### 多态的格式和使用\n  > 1. 父类名称  对象名称  =  new 子类名称（）；\n  > 2. 接口名称  对象名称  =  new 实现类名称（）；\n\n> #### 多态中访问成员变量的两种方式及规则\n  > 1. 直接通过对象名称访问成员变量：看等号左边是谁就优先用谁，没有则会往上寻找父类中是否存在该变量。\n  > 2. 间接通过成员方法访问成员变量：看该方法属于谁就优先用谁，没有则会往上寻找父类中是否存在该变量。\n\n> #### 多态中成员方法的访规则\n> 1. 看等号右边new的是谁，就优先用谁的方法。没有则会找到父类的方法。\n\n> #### 对比多态中成员变量和成员方法有何不同\n  > 1. 成员变量：编译看左边，运行还看左边\n  > 2. 成员方法：编译看左边，运行看右边。\n\n> #### 多态的好处\n  > &emsp; 比如Animal类有cat和dog两个子类，Animal有eat（）方法，cat和dog继承Animal也拥有了eat方法，但是狗和猫吃的东西不一样，有自己各自的方法。我们在写代码的时候  Animal  obj = new Dog();  并调用 obj.eat();  这里在编译时调用的时Animal类中的eat()方法，但是在程序运行的时候，会执行dog类中的eat()方法。new Cat();也是同理。这样就保证了等号左边的一致性，你new谁，在程序运行时，就调用谁的方法。一句话，编译看左边，运行看右边。<font color=red>多态的好处就是允许程序在运行的时候动态的创建对象，并调用对象的方法</font>。  \n\n> #### 对象向上转型\n  > &emsp; 父类引用指向子类对象。多态的写法就是向上转型。比如 将一个狗对象，当作父类动物对象来看待。    \n  > &emsp; 注意：向上转型的弊端，对象一旦向上转型为父类，那么就无法调用子类原本特有的方法。因为编译的时候根本无法通过对象点出来子类的方法，而只能调用父类的方法。\n\n> #### 对象的向下转型\n  > &emsp; 进行还原动作，比如你将一个子类对象向上转型为父类对象，你还可以将该对象转换回来，比如将狗的实例转为动物的实例，在将动物实例转换回狗的实例 　\n  > &emsp; Dog dog = (Dog) Animal();\n  > &emsp; 但是如果你在向下转型的过程中，向上转型为动物对象的狗对象还原为一个猫对象，那么就回报错。一定要注意，向下转型的时候对象的原本类型是什么，可以借助 instance of 关键字。\n> #### instance of \n  > &emsp;可以判断一个父类引用的对象，本来是什么子类。可以帮助我们在写代码的过程中，安全的向下转型。\n```java\npublic static void main(String[] args) {    \n        Animal animal = new Dog();\n        if(animal instanceof Dog){\n            Dog dog = (Dog) animal;\n            dog.eat();\n        }\n        if (animal instanceof Cat){\n            Cat cat = (Cat) animal;\n            cat.eat();\n        }     \n    }\n```  \n---  \n\n\n# 接口和抽象\n> ## 抽象类和抽象方法\n> 1. 抽象类不能直接new\n> 2. 必须需要子类实现抽象类\n> 3. 子类需要覆盖父类的抽象方法\n> 4. 创建子类进行使用  \n\n> 注意事项：\n> 1. 抽象类可以有构造函数，是供子类创建对象时，初始化父类成员使用的。\n> 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必须定义为抽象类。\n> 3. 抽象类的子类，必须重写子类中的所有抽象方法。否则编译报错。除非子类也是抽象类。  \n\n> ## 接口的概念\n    >&emsp;就是多个类的公共规范，接口是一种引用数据类型，最重要的内容就是其中的抽象方法（usb接口，插座）  \n\n> ## 接口的使用步骤\n> 1. 接口不能直接使用，必须有一个实现类来实现接口。\n> 2. 接口的实现类必须重写接口中所有的抽象方法\n> 3. 创建实现类对象，进行使用。\n> 注意事项：如果实现类并没有重写接口中的所有方法，那么这个实现类就必须是抽象类。   \n\n> ## 接口可以包含、常量、抽象方法、默认方法、静态方法、私有方法\n    > 1. <font color=red>默认方法：就是定义在接口中的静态方法。包含public default 方法名 { 方法体 }</font>。\n        > * 作用：可以解决接口升级的问题，因为接口中添加新的抽象方法，其实现类必须全部重写，\n        > * 注意：并且可以通过接口实现类对象直接调用，也可以被接口实现类覆盖重写。\n    > 2. <font color=red>静态方法：就是定义在接口中的静态方法。包含public static 方法名 { 方法体 }</font>。\n        > * 作用：不创建对象直接调用接口中的方法。静态方法和对象无关\n        > * 注意：不能通过接口实现类的对象来调用接口中的静态方法。而是直接用接口名称调用（一个类可以实现多个接口，多个接口中静态方法有可能产生冲突）（默认方法和静态方法只有在java 8会以上版本才支持）\n    > 3. <font color=red>私有方法：就是在接口中定义private关键字的方法，默认接口中方法必须是public的。（私有方法只有在java 9 或以上版本才支持）</font>\n        > * 普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名称（参数列表）{ 方法体 }\n        > * 静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名称（参数列表）{ 方法体 }\n        > * 作用：某些场景，我们需要在接口中抽取一个公有的方法，来解决两个或多个方法之间代码重复的问题，并规定只能在接口中调用，就可以通过私有方法来解决。  \n    > 4. <font color=red>常量：接口当中也可以定义“成员变量”</font>。\n        > * 类和类之间是单继承的，直接父类只有一个。\n        > * 类和接口之间是多实现的，一个接口可以实现（implements）多个接口，注意处理抽象方法的冲突问题就行。\n        > * 接口与接口之间是多继承的。就是一个接口可以继承（extends）多个接口，那么该接口就拥有了其他接口的全部抽象方法。  \n    > 5. <font color=red>注意事项（总结）</font>。\n        > *  接口不能有静态代码块或者构造方法。\n        > *  一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。\n        > *  如果实现类所实现的接口中，存在重复的抽象方法，那么只需要重写覆盖一次即可。\n        > *  如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类必须是一个抽象类。\n        > *  如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类必须冲突的默认方法进行重写。\n        > *  如果一个类的直接父类当中的方法，和接口当中的默认方法产生了冲突，会优先用父类的方法。（先继承，后实现的特点）。\n\n---\n\n# 内存管理\n> ## 堆\n    > 1. 堆中存储new出来的对象(包括实例变量)\n    > 2. 垃圾：没有任何引用所指向的对象，垃圾回收器(GC)不定时到内存中清扫垃圾，回收过程是透明的，调用System.gc()可以建议虚拟机尽快调度GC来回收\n    > 3. 内存泄漏:不再使用的内存还没有被及时的回收、建议:对象不再使用时及时将引用设置为null\n    > 4. 实例变量的生命周期：创建对象时存储在堆中，对象被回收时一并被回收  \n\n> ## 栈\n    > 1. 存储正在调用的方法中的局部变量(包括方法的参数)\n    > 2. 调用方法时，会在栈中为该方法分配一块对应的栈帧，栈帧中存储局部变量(包括方法的参数)，当方法执行结束后，栈帧被清除，局部变量一并失效\n    > 3. 局部变量的生命周期:调用方法时存储在栈中，方法结束时与栈帧一并被清除\n  \n> ## 方法区\n    > 1. 存储.class字节码文件(包括静态变量、方法)\n    > 2. 方法只有一份，通过this来区分具体的对象\n\n---\n\n\n# 集合总结  \n\n> ## 集合类的由来\n    >  &emsp;再开发过程中，我们一般用对象来封装特有数据，对象多了就需要存储，如果对象的个数不确定，就是用集合容器进行存储。  \n\n> ## 什么是集合\n\t>  &emsp;可以将集合理解为就是一个容器，因为面向对象编程会产生很多的对象，对了方便对对象的操作，所以把对象装入到集合，集合本身就是一个对象，能储存对象的对象就叫集合，存储对象的容器，就叫做集合，集合是可变长度的，数组不可变的。  \n\n> ## 集合的特点\n    >  &emsp;用于存储对象的容器，集合长度是可变的，集合中不可以存储基本数据类型值\n\n> ## 集合框架示意图\n![avatar](/images/collection.jpg)\n\n> ## Collection框架介绍\n    > &emsp;Collection是集合框架的顶级接口，Collections是是集合框架的工具类（提供集合共有的一些api）\n    > &emsp;Collection接口下有两个子接口，List接口和set接口，如上图  \n\n> ### List接口：有序可重复，存储对象有顺序，可以重复\n    > &emsp; Vector：最早的集合类，现在已经被ArrayList取代。底层也是数组\n    > &emsp; ArrayList：底层是数组，有序、可重复、有索引，异步线程不安全、特点：查找效率高，增删效率低\n    > &emsp; LinkedList：底层是双向链表，异步线程不安全，特点：增删效率高，查询效率低。不支持高效的随机元素访问。\n\n> ### Set接口：无序不可重复。不可存储重复对象，如果有重复，会覆盖。\n    > &emsp; TreeSet：底层是红黑树(自平衡的排序二叉树)，特点：有序，唯一 \n    > &emsp; hashSet：底层采用HashMap保存数据。特点：集合元素必须唯一，并且不可重复，无序的。\n    > &emsp; LinkHashSet：LinkHashSet继承HashSet，内部是通过LinkedHashMap实现。特点：集合元素必须唯一，并且不可重复，但是有序的。\n> ### Map集合：  \n\n> #### &emsp; map集合的特点:\n    > &emsp; map集合是一个双列集合，一个元素包含两个值，一个key，一个value\n    > &emsp; map集合中的元素，key和value的数据类型可以相同，也可以不同\n    > &emsp; map集合中的元素，key不允许重复，value可以重复\n    > &emsp; map集合中的元素，key和value是一一对应的关系。  \n\n> #### Map集合与collection集合的区别： \n    > &emsp; map集合中元素是成对存在的，每个元素由键与值两个部分组成的，通过键可以找到所对应的值，称之为双列集合。\n    > &emsp; collection集合中的元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储，称之为单列集合。  \n\n> #### Map集合常用子类：\n    > &emsp; HashMap：实现了Map接口，底层是哈希表。无序集合（存储元素和取出元素的顺序有可能不一致），异步多线程，查询的速度块，\n    > &emsp; LinkedHashMap：HashMap的子类，底层是哈希表+链表，是一个有序的集合，存取出元素的顺序是一直的，保证迭代的顺序。\n    > &emsp; HashTable：实现了Map接口，底层也是哈希表，不允许存储空key和value，线程安全的集合，速度慢，\n    > &emsp; properties：HashTable的子类，唯一一个和IO流相结合的集合  \n\n> #### HashMap底层原理\n    > &emsp; HashMap中维持了一个数组，数组的每一个位置称之为一个桶，每一个桶维持了一个链表，一个元素根据哈希吗进行运算，根据运算的结果平均的分配到这个桶中，放用到75%的桶的时候，会进行扩容，桶的数量会增加一倍，已有元素会重新计算哈希吗重新分布，这个过程称之为rehash，默认初始容量为16，即一开始有16个桶，当用到13个桶的时候要进行扩容。由16个桶扩容为32个桶，加载因子越大，碰撞概率越大，加载因子越小，扩容和rehash操作越频繁。  \n\n> #### HashMap 为什么速度快？\n    > &emsp; HashMap 之所以速度快，因为他使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）  \n    \n> #### hashcode为什么使用31来做相乘？\n    > &emsp; 之所以使用 31，是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代\t。替乘法，可以得到更好的性能： 31 * i == (i << 5） - i， 现代的 JVM 可以自动完成这种优化。这个公式可以很简单的推导出来  \n\n\n\n\n> ## 集合常见方法\n集合容器因为内部的数据结构不同，有多种具体容器，不断的向上抽取，就形成了集合框架，集合框架的顶层接口是collections，包含集合的共性方法\n> ### 常见方法：\n> 1. 添加 ：添加对象  boolean add（Object obj），boolean addAll\n> 2. 删除： boolean remove（object obj），boolean removeAll（object obj）\n> 3. 判断：boolean contains(Object obj），boolean containsAll(Boject ooll)，boolean ifEmpty\n> 4. 获取：int size()；获取集合元素集合的长度。\n\n> ## Iterator迭代器：\n> &emsp;专门取出集合中元素的方式，迭代器对象该对象必须依赖具体的容器，因为每一个容器的数据结构都不同，所以迭代器实在容器中进行内部实现的，对于适用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象就可以，也就是iterator方法   \n\n> ## 迭代器的实现原理：\n    > 迭代器就是实现了Iterator接口的每一个容器内部的内部对象\n    > 注意：在迭代器过程中，不要视同集合操作元素，容易出现异常，但是可以使用Iterator接口的子接口，ListIterator来完成在接待中对元素进行更多的操作，他可以实现在迭代过程中，完成对元素的增删改查，注意，只有list集合具备该迭代功能。   \n\n---\n\n# 线程总结  \n\n> ## 什么是进程？\n    > 计算机在执行的任务就是进程,比如JVM、QQ、微信、迅雷等服务本质上也是进程\n> ## 什么是线程？\n    > 进程中的小任务，多个小任务一起执行就是多线程 \n> ## 线程定义的三种方式\n    > 1. 继承Thread类，重写run()方法，将要执行的逻辑写入run方法，并调用start()方法\n    > 2. 实现Runable接口，重写run()方法，通过runnable对象来构建一个Thread对象来启动线程\n    > 3. 实现Callable<T>接口，重写call()方法.\n    > 4. 注意：为什么以上1、2两种方式都需要重写run方法？因为Thread类也实现了Runable接口。\n\n> ## api\n    > 1. Thread.currentThread().getName()获取线程的名字\n    > 2. Thread.seelp(毫秒值) 线程休息一会儿\n\n> ## 多线程的并发安全问题\n    > 线程的执行不存在先后，而是相互抢占执行，抢占并不是只发生在线程执行的开始，而是发生在线程执行的每一步过程中。由于多个线程并发导致出现一些不符合常理的数据现象---多线程并发安全问题\n\n> ## 同步代码块\n    > 同步代码块可以解决多线程并发安全问题,可以利用synchronize同步代码块来解决此问题\n    > synchronize需要指定锁对象,锁对象必须要求是这个类的所有线程都认识\n    > 共享资源，类的字节码、this（需要是同一个对象，一个对象启动四个线程）\n    > synchronize去修饰方法 ，同步方法的锁对象是this   \n\n> ## 什么是同步和异步\n    > 一段逻辑同一时间内只能一个线程执行，称之为反之叫做异步。\n    >  线程同步一定是安全的，而线程不安全一定是异步的。\n\n> ## 什么是死锁？如何解决死锁问题\n> 多个线程之间的锁形成了嵌套，导致程序无法继续运行的现象叫做死锁\n>  思考如何避免死锁？\n>  &emsp;1.减少线程数量  （理论上是可以，实际开发中不现实）。\n>  &emsp;2.统一锁对象     \n>  &emsp;3.减少锁嵌套\n\n\n> ## 线程的状态\n> 1. 创建状态\n> 2. 就绪状态\n> 3. 执行状态\n> 4. 阻塞状态 / 挂起状态   （人为阻塞 冻结状态）    \n> 5. 消亡状态\n \n> ## Sleep和wait有什么区别：\n> sleep在使用的时候需要指定休眠时间，到点自然醒。释放执行权，不释放锁。是一个静态方法，设计在了Thread类上。wait在使用的时候可以指定等待时间，也可以不指定，如果不指定等待时间就需要唤醒，释放执行权，释放锁，是一个非静态方法，设计在了Object类上。\n\n> ## 守护线程：\n> 守护别的线程，当被守护的线程结束，守护线程无论执行完成与否都得随之结束。 Daemon\n> 一个线程要么是守护线程要么是被守护的线程\n> 守护线程是随着最后一个被守护线程的结束而结束。   --GC就是一个守护线程。\n\n> ## 线程的优先级\n> 线程的优先级。1-10个等级   没有手动设置的情况下优先级默认是5。\n> 理论上数字越大等级越高，这个线程抢到资源的几率越大，相邻的两个线程的优先级的差异性不明显，至少要相差5个等级才能体现的相对明显\n","tags":["基础知识"],"categories":["Java基础知识"]}]