[{"title":"Mysql数据库高可用","url":"/2020/02/06/Mysql数据库高可用/","content":"\n\n# 数据库备份策略\n\n## 冷备份策略\n> 说明：定期将数据库文件进行转储.\n> 缺点：\n> &emsp;1.数据库冷备份，则需要手动的人工完成.效率低\n> &emsp;2.定期数据备份，不能保证数据的安全的.仅仅能够恢复部分数据\n> &emsp;3.如果数据量比较庞大，导入导出时耗费的时间较多\n> &emsp;4.由于网络传输问题.可能会导致备份多次  \n> 优点：数据库冷备份是恢复数据最后有效的手段.\n\n\n## 热备份策略\n> 说明： 当主数据库数据进行\"更新\"操作时，数据会自动的同步到slave(从数据库中)该操作可以实现数据实时备份。  \n![avatar](/images/databasecopy.jpg)\n\n## 数据备份原理\n> 1. 当数据库主库发生数据改变时，会将改变的数据写入二进制日志文件中(主库)。\n> 2. 从库中会启动IO线程会实时的监控主库的二进制文件是否发生改变.如果主库的二进制改变了，则将改变的数据进行读取.读取之后，将二进制内容写入中继日志中。\n> 3. 从库会启动Sql线程.会读取中继日志中的消息，将它写入数据库中，最终实现数据同步。\n\n\n## 数据库双机热备\n>   根据数据库主从的配置.当主数据库做更新操作时，从库复制备份数据.当主库宕机时，通过某些技术手段可以数据库的高可用，实现故障迁移.当用户再有写入操作时，应该将数据写入从库中.如果主库修复完成重启数据库时，主库发现从库的数据较多.则数据库备份将失效.最终导致数据不一致的问题.\n\n### 双机热备意义\n> 说明：实现数据库双机热备是实现高可用的前提，如果数据不同步则无法实现数据库高可用.一般公司都有自己的运维团队.所以负责java开发的程序员不需要手动的配置数据库主从.但是需要了解mysql数据备份策略.为以后转岗做准备。\n\n\n\n\n## 数据库读写分离\n### Amoeba\n> #### 什么是amoeba?\n> Amoeba是一个以MySQL为底层数据存储，并对应用提供MySQL协议接口的proxy。它集中地响应应用的请求，依据用户事先设置的规则，将SQL请求发送到特定的数据库上执行。基于此可以实现负载均衡、读写分离、高可用性等需求。与MySQL官方的MySQL Proxy相比，作者强调的是amoeba配置的方便（基于XML的配置文件，用SQLJEP语法书写规则，比基于lua脚本的MySQL Proxy简单）。\n\n>Amoeba相当于一个SQL请求的路由器，目的是为负载均衡、读写分离、高可用性提供机制，而不是完全实现它们。用户需要结合使用MySQL的 Replication等机制来实现副本同步等功能。amoeba对底层数据库连接管理和路由实现也采用了可插拨的机制，第三方可以开发更高级的策略类来替代作者的实现。这个程序总体上比较符合KISS原则的思想。\n\n> amoeba作用：<font color=red>可以实现数据库的读写操作分离，高可用。 (数据库分库分表中间件)</font>  \n> &nbsp; 需求分析： 如果所有的访问压力都访问一台mysql服务器.如果遇到高并发问题可能导致数据库服务器宕机影响整个服务.\n> &nbsp; 解决方案： 使用读写分离策略.提高数据库的执行效率，当用户有更新操作时，访问主数据库.当用户有读操作时访问从数据库.同时从数据库可以有多台.并且主从实现数据同步.实现读和写分离.高升数据库性能.\n![avatar](/images/amoeba.png)\n\n\n\n### Mycat\n> #### 什么是Mycat\n> 官网copy了一份：\n> 1. 一个彻底开源的，面向企业应用开发的大数据库集群\n> 2. 支持事务、ACID、可以替代MySQL的加强版数据库\n> 3. 一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群\n> 4. 一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server\n> 5. 结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品\n> 6. 一个新颖的数据库中间件产品  \n\n> Mycat作用：<font color=red>能满足数据库数据大量存储， 提高了查询性能 (数据库分库分表中间件)</font>  \n\n![avatar](/images/mycat.png)\n> Mycat工作原理说明：\n> 1. 后台服务器需要将数据入库时通过mycat代理服务器操作数据库.\n> 2. 如果是更新操作.则将数据发往主数据库，如果是读操作则将数据发送给从数据库或者空闲的主数据库.\n> 3. 当主数据库发生宕机后，Mycat内部有心跳检测机制.判断主库宕机后，实现故障迁移.将所有的写库操作发往第二台主库.也就是从机.\n> 4. 当运维人员修复主库后.Mycat还会将写操作发往主库.从而实现数据库高可用.\n\n\n#### 垂直拆分和水平拆分\n> 业务需求： 当公司的业务积累到一定量，数据库和数据表都有大量的数据，无论从运维/查询角度而言效率都很慢，这就是通常所说的数据库瓶颈问题。 \n> <font color=red>那么如何解决这一问题呢？ 核心思想：将大量的数据分别保存到不同的数据库和数据表中</font>。\n\n#### 数据拆分概念引入\n> ##### 垂直拆分：  \n> 特点：根据不同的业务，将数据表拆分到不同的数据库中.\n> 规定：如果有业务关联，则尽可能拆分到一个数据库中.  \n> ##### 水平拆分： \n> 特点：  按照数据量进行拆分，将一个表中的数据分别保存到不同的数据表中，分散存储  \n\n#### 使用Mycat实现数据库 1.高可用性 2.读写分离 3.负载均衡\n> ##### 数据库垂直拆分  \n\n> &nbsp;根据功能模块(业务)将一个数据库中的表，拆分为多个数据库.降低了数据库中的数据量.提高数据库效率\n> * 优点：将数据表根据功能存放到不同的数据库中，可以提高数据库的性能。\n> * 拆分策略：将具有关联意义的数据表尽可能保存到同一个数据库中.否则关联查询时不能正确关联.因为在不同的数据库中。  \n\n> ##### 数据表水平拆分  \n\n> &nbsp;由于单表数据表的量很大，造成了数据库查询的瓶颈.所以需要将数据表中的数据拆分到多个数据库中.降低单表的数据量。\n> * 数据存取问题：由于使用数据库水平拆分，那么数据库中的数据应该按照什么规则存取呢?\n> * 问题解决：Mycat对于数据水平拆分，指定了很多策略.课上介绍一种根据Id取模运算.\n> * 原理说明：当信息入库时根据Id%分库数量=值.这个值就是数据存储的位置.同样当用户读取数据库时，也会取模快速定位数据库中的表.快速获取数据，如下图。\n![avatar](/images/拆分策略.png)\n\n\n\n# 数据库优化策略(重点知识)\n> 1. 优化sql语句(多表操作)  where 左连接 右连接 内连接 原则:尽可能根据主键查询,尽可能少用关联查询.\n> 2. 创建索引(对经常查询的数据创建索引)\n> 3. 添加缓存(Redis/MemCache)\n> 4. 定期进行数据转储(将一些查询较少的数据保存到历史表,让当前表维护可控的数据量)\n> 5. 分库分表(需要大量的数据库服务器)\n\n","tags":["基础知识","mysql"],"categories":["数据库基础知识"]},{"title":"数据库Mysql基础知识","url":"/2020/02/06/数据库Mysql基础知识/","content":"# 数据库概述\n## 什么是数据库\n> 数据库：英文为Database，简称DB，数据库是按照数据结构来组织、存储和管理数据的仓库，简而言之，数据库就是存储数据的仓库。\n\n## 数据库的分类\n> 数据库根据存储采用的数据结构的不同可以分为许多种，其中包含早期的层次式数据库、网络式数据库。\n> 目前占市场主流的是关系型数据库。当然还有非关系(NoSQL)型数据库（键值对数据库，例如：MongoDB、Redis）等其他类型的数据库\n\n## 什么是关系型数据库？\n> 底层是以二维表的及其之间的关系所组成的数据库，即是关系型数据库。例如：\n\n## 常见的关系型数据库\n> SQL Server      微软提供（收费、Java中使用不多）\n> Oracle            甲骨文公司（收费、功能强大、性能优异，Java中使用者很多）\n> DB2                IBM（收费、中型/大型、银行/电信等企业）\n> MySQL           瑞典MySQL AB（免费开源、小型、性能也不差、适用于中小型项目、可集群）\n> SQLite            迷你数据库，嵌入式设备中\n> ...\n## MySQL建库、建表\n> 查看数据库、查看数据表：show databases；\n```sql\n    show databases;\n```\n> 进入数据库：\n```sql\n    use 数据库名；\n```\n> 查看当前库中的所有表：show tables；\n```sql\n    show tables；\n```\n> 创建数据库、创建数据表\n> 创建数据库： \n```sql\n    drop database if exists 数据库名;\n```\n> 设置数据库编码：\n```sql\n    create database mydb1 charset utf8；\n```\n> 创建数据表：\n```sql\ndrop table if exists 表名;\n\ncreate table stu(\n    id int,                -- 学生编号\n    name varchar(20),    -- 学生姓名\n    gender char(1),    -- 学生性别\n    birthday date,        -- 出生年月\n    score double        -- 考试成绩\n        );\n```\n\n## MySQL数据类型及\n### 数值类型：\n> MySQL中支持多种整型，其实很大程度上是相同的，只是存储值的大小范围不同而已。\n> 1. tinyint：   占用1个字节，相对于java中的byte\n> 2. smallint： 占用2个字节，相对于java中的short\n> 3. int：          占用4个字节，相对于java中的int\n> 4. bigint：    占用8个字节，相对于java中的long ，其次是浮点类型即：float和double类型\n> 5. float：      占用4个字节，单精度浮点类型，相对于java中的float\n> 6. double：    占用8个字节，双精度浮点类型，相对于java中的double\n\n### 字符串类型\n> 1. char(n)  定长字符串，最长255个字符。n表示字符数，所谓的定长，是当插入的值长度小于指定的长度10（上面指定的）时, 剩余的空间会用空格填充。（这样会浪费空间）\n> 2. varchar(n)变长字符串，最长不超过 65535个字节，n表示字符数，一般超过255个字节，会使用text类型。所谓的不定长，是当插入的值长度小于指定的长度10（上面指定的）时, 剩余的空间可以留给别的数据使用。（节省空间）\n> 3. 大文本（长文本）类型，最长65535个字节，一般超过255个字符列的会使用text。text也分多种，其中bigtext存储数据的长度约为4GB。\n \n### 总结： \n> &emsp; char、varchar、text都可以表示字符串类型，其区别在于：\n> 1. char在保存数 据时, 如果存入的字符串长度小于指定的长度n,后面会用空格补全。 \n> 2. varchar和text保存数据时, 按数据的真实长度存储, 剩余的空间可以留给别的数据用.\n> 3. char会造成空间浪费(不足指定长度的会用空格补全), 但是由于不需要计算数据的长度, 因此速度更快。（即以空间换时间）\n> 4. varchar和text是节省了空间，但是存储的速度不如char快，因为要计算数据的实际长度。（即以时间换空间）\n\n### 日期类型\n> 1. date：年月日    time：时分秒     datetime：年月日 时分秒    \n> 2. timestamp：时间戳(实际存储的是一个时间毫秒值)，与datetime存储日期格式相同。\n> 3. timestamp最大表示2038年，而datetime范围是1000~9999\n> 4. timestamp在插入数、修改数据时，可以自动更新成系统当前时间(后面用到时再做讲解)\n\n## 字段约束\n> &emsp; 创建表时, 除了要给每个列指定对应的数据类型, 有时也需要给列添加约束。常见的约束有：主键约束、唯一约束、非空约束、外键约束。\n> 1. 主键(primary key)：主键是数据表中，一行记录的唯一标识。比如学生的编号，人的身份证号, 主键的特点：唯一且不能为空，当主键为数值时，为了方便维护，可以设置主键为自增 auto_increment              \n> 2. 唯一(unique)：保证所约束的列必须是唯一的，即不能重复出现，例如：用户注册时，保存的用户名不可以重复。唯一约束特点是不能重复(允许为空)\n> 3. 非空(not null) ：保证所约束的列必须是不为空的，即在插入记录时，该列必须要赋值，例如：用户注册时，保存的密码不能为空。非空约束的特点是：不能为空值，即插入数据时该列必须得有值。\n> 4. 外键约束：外键是用于表和表之间关系的列\n \n\n## SQL语言\n### 什么是SQL语言?\n> Structured Query Language：结构化的查询语言，SQL是操作所有关系型数据库的通用的语言\n\n###   SQL语言的分类：\n> 1. DDL -- 数据库定义语言，指CREATE、ALTER、DROP等操作（ 即创建、删除、修改数据库和数据表 ）\n> 2. DML -- 数据操作语言，指INSERT、UPDATE、DROP等操作（ 即数据表中数据的增、删、改操作 ）\n> 3. DQL  -- 数据查询语言（指SELECT操作，即数据表中数据的查询操作）\n \n\n### 更新表记录（insert/update/delete）\n#### insert--插入表记录\n> 格式: <font color=red>insert into 表名称 values (值1, 值2,....)</font>\n```sql\n    insert into emp  (字段1，字段2，)  values(值1, 值2...)\n```\n#### update修改表记录\n> 格式: <font color=red>update 表名称 set 列名称 = 新值 where 列名称 = 某值</font>\n```sql\n-- \n    update stu set score=score+10 where name='xxx';\n    select * from stu where name='xxx';\n    update stu set score=ifnull(score, 0)+10;\n    注意: null值和任何值计算结果还是null, 因此, 可以通过ifnull函数将null置为零对待.\n```\n\n#### delete删除表记录\n> 格式: <font color=red>delete from 表名称 where 列名称 = 值</font>\n```sql\n    delete from stu where name='xxx'; \n    delete from stu;    \n--若没有where子句, 则默认删除所有记录\n```\n\n#### select查询表记录\n> 格式: <font color=red>select 列名称 from 表名称</font>\n```sql\n    -- 查询emp表中的所有员工，显示员工姓名、薪资、奖金\n        select name,sal,bonus from emp;\n        select * from emp;\n        select distinct dept from emp;           \n        distinct  --关键字，用于剔除指定列中的重复值\n```\n\n#### where子句查询\n> 格式: <font color=red>select 列名称 from 表名称</font>\n```sql\n        -- 查询薪资大于300的姓名及工资大于3000的所有员工，显示员工姓名、薪资\n                select name,sal from emp where sal>3000; \n         \n        -- 查询emp表中总薪资(薪资+奖金)大于3500的所有员工，显示员工姓名、总薪资\n                select name, sal+bonus from emp where (sal+bonus)>3000; \n                select name, sal+bonus as 总薪资 from emp where (sal+bonus)>3000;\n        \n        --as用于定义别名(仅在查询的结果中作为列的表头显示)，也可以省略as\n        -- where子句中不能使用列别名（但是可以使用表别名）\n         \n        -- 查询emp表中薪资在3000和4500之间的员工，显示员工姓名和薪资\n                select name,sal from emp where sal between 3000 and 4500; \n         \n        -- 查询emp表中姓名中以\"刘\"开头的员工，显示员工姓名。\n                select name,sal from emp where name like '刘%';\n        \n        -- 查询emp表中姓名以\"刘\"开头，字数为两个字的员工，显示员工姓名。\n                select * from emp where name like '刘_';\n         \n        -- 查询emp表中姓名中包含\"涛\"字的员工，显示员工姓名。\n                select * from emp where name like '%涛%';\n                --提示：\"%\" 表示任意0或多个字符。\"_\" 表示任意一个字符\n         \n        -- 查询emp表中薪资为1400、1600、1800的员工，显示员工姓名和薪资\n                select name,sal from emp where sal in(1400,1600,1800);\n        \n        -- 查询emp表中薪资小于2000和薪资大于4000的员工，显示员工姓名、薪资。\n                select name,sal from emp where sal<2000 or sal >4000;\n         \n        -- 查询emp表中薪资大于3000并且奖金小于600的员工，显示姓名、薪资、奖金。\n                select name,sal,bonus from emp where sal>3000 and bonus<600; \n```\n#### 排序查询\n> 对查询的结果进行排序使用 order by关键字。\n> 1. order by 排序的列 asc    升序 ↑    \n> 2. order by 排序的列 dasc   降序 ↓\n```sql\n-- 对emp表中所有员工的薪资进行升序(从低到高)排序，显示姓名、薪资。\n            select name,sal from emp order by sal asc;\n     \n    -- 对emp表中所有员工的总薪资进行降序(从高到低)排序，显示姓名、总薪资。\n            select name, sal+bonus as 总薪资 from emp order by (sal+bonus) desc;\n\n    --分组查询：对所查询的记录可以根据某一列进行分组, 分组使用group by。\n\n    -- 将员工按照部门进行分组\n            select * from emp group by dept;\n     \n    -- 对emp表按照部门进行分组, 并统计每个部门的人数, 显示部门和对应人数\n            select dept 部门名称, count(*) 部门人数 from emp group by dept;\n     \n    -- 对emp表按照部门进行分组, 求每个部门的最高薪资(不包含奖金)\n            select max(sal) 总薪资 from emp group by dept;\n     \n    --注意：分组之前使用聚合函数表示对查询的所有记录进行统计计算,分组之后使用聚合函数表示对每一个组中的所有记录进行统计计算。\n```\n\n#### 聚合函数查询：\n> 1. max()或min() -- 某列的最大值或最小值，\n> 2. count() 某列的行数，\n> 3. sum() 某列值之和，\n> 4. avg() 某列的平均值\n```sql\n        -- 查询emp表中最高薪资\n                select max(sal) as 最高薪资 from emp;\n        -- 查询emp表中最高总薪资(薪资加奖金)\n                select max(sal+bonus) as 最高薪资 from emp;\n         \n        -- 统计emp表中薪资大于3000的员工人数\n                select count(*) from emp where sal>3000;\n         \n        -- 统计emp表中所有员工的总薪资(不包含奖金)\n                select sum(sal) as 员工总薪资 from emp;\n         \n        -- 统计emp表员工的平均薪资(不包含奖金)\n                select avg(sal) as 员工总薪资 from emp;\n         \n        -- 重要提示：可以使用count(*)统计记录行数，多个聚合函数可以一起查询。\n        -- 例如:根据部门进行分组，统计每个部门员工人数和平均薪资\n                select dept, count(*) 员工人数, avg(sal) 平均薪资 from emp group by dept; \n         \n        -- 聚合函数不能用在where子句中，在没有分组的情况下，聚合函数不能和其他普通字段一起查询\n        -- 错误的例如: 查询emp表中薪资最高的员工姓名。\n                select name, max(sal) from emp;--结果是错的\n        -- 正确的查询：\n                select name, sal from emp where sal=(select max(sal) from emp);-- \n```\n \n#### 数值函数：\n> 1. ceil(数值) -- 向上取整、\n> 2. floor(数值) -- 向下取整、\n> 3. round(数值) -- 向下取整\n> 4. rand(数值) -- 随机数\n``` sql\n--  查询emp表中所有员工薪资上涨15.47%, 向上取整。\n    select name,sal, ceil(sal*1.1547) from emp;\n```\n\n#### 日期函数\n> 1. curdate() -- 返回当前日期(年月日)\n> 2. curtime() -- 返回当前时间(时分秒)\n> 3. now() -- 返回当前日期+时间(年月日 时分秒)\n> 4. date_add()、date_sub() -- 增加/减少日期\n> 5. year()、month()、day()、hour()、minute()、second()，分别用来获取日期中的年、月、日、时、分、秒\n```sql\n        -- 查询系统当前时间。\n                select now();\n        -- 查询emp表中所有员工的年龄，显示姓名、年龄。\n                select name,year(curdate()) - year(birthday) 年龄 from emp;\n         \n        -- 查询emp表中所有在1993和1995年出生的，显示姓名、出生日期。\n                select name,birthday from emp where year(birthday) between 1993 and 1995;\n ```\n\n\n### 外键和表关系\n#### 外键：\n> 唯一标识其他表中的一条记录，用来通知数据库两张表列与列之间的对应关系, 并让数据库帮我们维护这样关系的键就叫做外键。  \n> 外键作用: 确保数据库数据的完整性和一致性，添加外键: 例如:foreign key(dept_id) references dept(id)  \n> 例如：员工表的部门id列（dept_id）和部门表的id列具有一 一对应的关系, 其中dept_id就是外键。\n\n#### 表关系：\n> 1. 一对多：一对多，反过来就是多对一，对于一对多的两张表，可以在多的一方添加列，保存一的一方的主键，从而保存两张表之间的关系\n> 2. 一对一：对于一对一关系的两张表，可以在任意一张表中添加列，保存另一张表的主键，从而保存两张表之间的关系\n> 3. 多对多：对于多对多的关系，可以拆分成两张一对多的关系，无法在两张表中添加列保存关系，但我们可以添加一张第三方的表,保存两张表的主键，从而保存两张表的关系。\n\n \n### 连接查询：将两张或者两张以上的表，按照指定条件查询，将结果显示在一张表中。\n> 多张表查询的语法：  <font color=red>Select 字段 from 表1,表2... where...</font>\n> 如果表名过长，可以为表添加别名以方便书写<font color=red>select... from A a, B b... where…</font>    \n```sql\n-- 查询部门和员工两张表\n    select * from dept,emp;   \n    ---上面查询的结果中存在大量错误的数据, 如果想正确显示部门及部门对应的员工，可以通过where子句从中筛选正确的数据.\n-- 查询部门和部门下的员工。\n    select * from dept d,emp e where d.id=e.dept_id;\n    select * from dept d inner join emp e on d.id=e.dept_id;          \n    --- (inner join...on...)方式也叫做内连接查询\n```\n\n### 外连接查询：\n> 左外连接查询，显示左侧表中的所有记录，如果在右侧表中没有对应的记录，则显示为null\n> 语法：<font color=red>select ...from a left join b on (a.id=b.xid)</font>\n \n```sql\n-- 查询所有部门和部门下的员工，如果部门下没有员工，显示null\nselect * from dept d left join emp e on d.id=e.dept_id;\n以上结果会显示（左侧表）所有部门，如果某部门下没有员工，（右侧表）则显示为null\n```\n\n### 右外连接查询：\n> 显示右侧表中的所有记录，如果在左侧表中没有对应的记录，则显示为null\n>语法：<font color=red>select 字段 from a right join b on (a.id=b.xid)</font>\n \n```sql\n-- 查询部门和所有员工，如果员工没有所属部门，显示null\nselect * from dept d right join emp e on d.id=e.dept_id;\n以上结果会显示（右侧表）所有员工，如果员工没有所属部门，（左侧表）则显示为null\n```\n\n\n \n### 子查询：\n> 其实就是将一个查询得出的结果，作为另外一个查询的条件。\n> 格式：<font color=red>select...from...where...(select...from...)</font>\n```sql\n---列出薪资比'xxx'高的所有员工，显示姓名、薪资      -- 先查询出'王海涛'的薪资\nselect name, sal from emp where sal>( select sal from emp where name='xxx');\n \n---列出与'刘沛霞'从事相同职位的所有员工，显示姓名、职位、部门。\nselect e.name, e.job, d.name from emp e, dept d where e.dept_id=d.id and job=(select job from emp where name='xxx');\n```\n\n### 多表查询\n\n```sql\n（左外连接）列出所有部门和部门下的员工，如果部门下没有员工, 显示为null。\nselect d.id, d.name, e.name, e.dept_id from dept d left join emp e on e.dept_id=d.id;\n\n--（关联查询）列出在'培优部'任职的员工，假定不知道'培优部'的部门编号。\nselect e.name, e.dept_id, d.id, d.name from emp e, dept d where e.dept_id=d.id;\n-- 再筛选过滤，查询部门名称为'培优部'的员工\nselect e.name, d.id, d.name from emp e, dept d where e.dept_id=d.id and d.name='培优部';\n \n（自连接查询）列出所有员工及其直接上级，显示员工姓名、上级编号，上级姓名\n-- 先查询员工表（emp e1）\nselect name, topid from emp e1;\n-- 再查询上级表（还是员工表，emp e2）\nselect id, name from emp e2;\n-- 最后查询员工及其员工的直接上级\nselect e1.name,e1.topid, e2.id, e2.name from emp e1, emp e2 where e1.topid = e2.id;  \n\n\n（分组、聚合函数）列出最低薪资大于1500的各种职位，显示职位和该职位最低薪资\n--先查询出各种职位的最低薪资\nselect job, min(sal) 最低薪资 from emp group by job;\n--提示：对分组后的记录筛选过滤请使用having替换where，并且having书写在最后\n--再查询出最低薪资>1500的职位\nselect job, min(sal) 最低薪资 from emp group by job having min(sal)>1500;  \n\n\n（分组、聚合函数查询）列出在每个部门就职的员工数量、平均工资。显示部门编号、员工数量，平均薪资。\nselect dept_id, count(*) 员工数量, avg(sal) 平均薪资 from emp group by dept_id;  \n\n \n（分组、关联、聚合函数查询）查出至少有一个员工的部门。显示部门编号、部门名称、部门位置、部门人数。\n--先关联查询, 查询出员工和员工对应的部门\nselect d.id, d.name, d.loc, e.name from emp e, dept d where e.dept_id=d.id;\n--再根据部门进行分组, 统计每个部门的员工数量\nselect d.id, d.name, d.loc, count(*) 员工数量 from emp e, dept d where e.dept_id=d.id group by e.dept_id;  \n\n \n（自连接查询）列出受雇日期早于直接上级的所有员工的编号、姓名、部门名称。\n-- 关联查询\nselect e1.id, e1.name, d.name from emp e1, emp e2, dept d where e1.dept_id=d.id and e1.topid=e2.id and e1.hdate < e2.hdate;  \n\n```\n\t\n","tags":["基础知识","mysql"],"categories":["数据库基础知识"]},{"title":"Servlet基础知识","url":"/2018/02/15/Servlet基础知识/","content":"\n# Servlet\n\n## Servlet概述\n> 1. Servlet本质上一段java程序\n> 2. Servlet程序无法独立运行，必须放在服务器中，由服务器调用才可以执行！\n> 3. Servlet的作用是：接受请求、处理请求、将结果响应给浏览器。\n\n## Servlet的作用\n> Servlet的作用就是处理请求，服务器会将接受到的请求交给Servlet处理。这个过程为：\n> 1. 客户端发送请求至服务器端；\n> 2. 服务器将请求信息交给 Servlet 处理；\n> 3. 最终处理的结果交给服务器；\n> 4. 服务器将结果响应给客户端。\n\n## Servlet调用过程\n> ![avatar](/images/servlet调用执行流程.png)\n> 1. 浏览器向服务器发起请求\n> 2. 首先会根据请求头信息获知浏览器访问的是那个虚拟主机\n> 3. 然后根据请求行中的路径资源获知浏览器访问的是哪一个web应用\n> 4. 根据请求行中的资源路径获知访问的是哪一个资源\n> 5. 根据获取到的资源路径到web.项目文件中去匹配真实路径，创建servlet实例并调用service方法\n> 6. 调用service方法前，底层会创建两个对象，Requset、response，通过request获取请求相关信息\n> 7. 通过response想浏览器发送响应数据，然后按照Http协议规定的格式，组织成相应消息，最后发送给浏览器\n\n## Servlet生命周期\n> &emsp;Servlet在第一次被访问时创建Servlet实例, 创建之后服务器会立即调用init方法进行初始化的操作, 创建之后, Servlet实例会一直驻留在服务器的内存中, 为后续的请求服务. 只要有请求来访问这个Servlet, 服务器就会调用service方法来处理请求, 直到服务器关闭, 或者WEB应用被移出容器, 随着WEB应用的销毁, Servlet实例也会跟着销毁, 在销毁之前服务器会调用destroy方法进行善后的处理。\n\n## 请求、转发、域对象\n> 1. 域对象：\n    > &emsp;能够在指定的范围内, 利用自身的map实现数据的共享  \n\n> 2. 请求转发：\n    > &emsp;是指定服务器中的某一个资源（Servlet或JSP）在处理请求的过程中，将请求转发给一个其他的资源，让其他资源来处理请求转发只能在同一个Web应用内部的两个资源之间进行跳转, 不可以是不同的Web应用或者不同的服务器中进行跳转,请求转发是一次请求，一次响应，转发前后地址栏地址不会发生变化  \n\n> 3. 重定向：\n\t> &emsp;是指当用户浏览某个网址时，将其导向到另一个网址的技术。重定向和定时刷新都是两次请求两次响应，重定向和定时刷新前后，地址栏地址都会发生变化\n\n> 4. 总结:\n > 定时刷新和重定向都是两次请求, 两次响应\n > 定时刷新和重定向跳转前后, 地址栏地址都会发生变化。\n > 定时刷新和重定向在跳转时没有限制, 既可以在同一个Web应用内部的资源之间进行跳转, 也可以在不同的Web应用或者不同的主机之间进行跳转\n > 定时刷新和重定向不同的是, 重定向是立即跳转, 中间没有时间间隔, 而定时刷新可以指定多少秒之后再进行跳转, 在跳转之前, 可以输出内容到浏览器, 提示用户。\n\n### EL表达式的作用: \n> &emsp;在Web开发中, 实现很多功能的时候, 都是由Servlet接收请求、处理请求，但是处理的结果应该交给JSP显示，此时我们可以在Servlet中将请求处理的结果存入request域中，再通过转发将Request域带到JSP中，再通过EL表达式将request域中的数据取出来, 显示在网页上.\n\n","tags":["基础知识"],"categories":["Servlet基础知识"]},{"title":"会话技术基础知识","url":"/2018/02/10/会话技术基础知识/","content":"\n# 会话技术  \n\n## 什么是会话?  \n\n> &emsp;为了实现某一个功能(比如购物), 浏览器和服务器之间可能会产生多次的请求和响应。从浏览器访问服务器开始，到访问服务器结束，浏览器关闭为止，这期间产生的多次请求和响应加在一起就称之为浏览器和服务器之间的一次会话！  \n\n> &emsp;会话中往往会产生一些数据，而这些数据往往是需要我们保存起来的，如何保存会话中产生的数据呢？这里可以使用会话技术(也就是Cookie和session)来保存会话中产生的数据\n\n## Cookie 和 Session 保存数据的原理 \n### Cookie\n> &emsp;通过 Set-Cookie响应头 和 Cookie请求头 将会话中产生的数据保存在客户端( 浏览器 ) , 当浏览器在此访问服务器时,服务器会获取上一次会话发送给浏览器的Cookie信息,通过这种方式来保存会话中的数据。由于Cookie技术是将会话中产生的数据保存在客户端，每个客户端各自持有自己的数据，当需要时再带给服务器，因此不会发生混乱！  \n\n>  Cookie的API\n> \n```java\n// 1.创建Cookie对象\n    Cookie c = new Cookie(String name, String value);\n// 2.将Cookie添加到response响应中\n    response.addCookie(Cookie c);//可以调用多次, 表示将多个cookie添加到响应中\n// 3.获取请求中的所有cookie对象组成的数组\n    Cookie[] cs = request.getCookies();\n//注意：该方法会返回请求中的所有cookie组成的数组, 若请求中没有cookie, 该方法会返回null.\n```\n>  删除Cookie\n>  &emsp;没有直接删除cookie的方法，我们可以向浏览器再发送一个同名的cookie(比如名称为prod的cookie), 并设置cookie的存活时间为零, 最后将cookie发送给浏览器。由于浏览器是根据cookie的名字来区分cookie的，如果前后发送了两个名称一样的cookie，后发送cookie会覆盖之前发送的cookie。又由于后发送的cookie生存时间为零，浏览器收到后也会立即删除！！\n\n### Session\n> &emsp;浏览器第一次发送请求需要保存数据时，服务端获取到需要保存的数据，去服务器内部检查一下有没有为当前浏览器服务的session，如果有就直接拿过来用，如果没有session就创建一个新的session拿过来用。接着将数据保存在Session中，做出响应。当浏览器再去访问服务器时，服务器可以从session中获取到之前为当前浏览器保存的数据，通过这种方式，也可以来保存会话中产生的数据。\n\n### Cookie 和 Session的异同\n> 相同点：Cookie和Session都是用于保存会话中产生的数据，都是会话技术\n> 不同点:  \n    > Cookie：\n        >> 1. Cookie是将会话产生的数据保存在客户端，是客户端技术\n        >> 2. Cookie将数据保存在客户端，不占服务器内存，可以提高服务器性能\n        >> 3. Cookie适合存储安全性要求不高，但是需要长时间保存的数据  \n        （因为保存在浏览器客户端，数据容易丢失，或被窃取）\n\n> Session：\n        >> 1. Session是将会话产生的数据保存在服务器，是服务器端技术\n        >> 2. Session将数据保存在服务器端，占用服务器内存，影响服务器性能\n        >> 3. Session适合存储对安全性要求较高，但是不需要长时间保存的数据  \n        （不会随着用户操作，导致数据丢失或被窃取，安全性高）","tags":["基础知识"],"categories":["会话技术"]},{"title":"JDBC知识总结","url":"/2018/02/09/Jdbc知识总结/","content":"\n# JDBC：\n## 概念：Java DataBase Connectivity  \n> JDBC( Java DataBase Connectivity ) 翻译过来就是Java数据库连接，其实就是通过Java语言操作数据库的一门技术。\n\n### JDBC由来\n> 由于数据库厂商提供的数据库驱动（操作数据库的jar包）各不相同，导致开发人员的学习成本十分的高。因此SUN公司提出了JDBC这套规范，用来统一访问数据的标准。JDBC本质上是一套接口，SUN要求所有的数据库厂商在设计驱动时，都要实现JDBC这套标准。因此开发人员只要学会JDBC这套接口，所有的数据库驱动就都会使用了。\n\n### JDBC包的介绍\n> JDBC主要是由java.sql 和javax.sql包组成的，并且这两个包已经被集成到J2SE的规范中了，这意味着，只要一个普通的java程序就可以使用JDBC。需要注意的是，JDBC包中大部分都是接口，因此在开发数据库程序时，除了如上的两个包，还需要手动的导入具体的数据库驱动。\n\n## 快速入门：  \n> 开发步骤：\n> 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar\n> 2. 注册驱动\n> 3. 获取数据库连接对象 Connection\n> 4. 定义sql\n> 5. 获取执行sql语句的对象 Statement\n> 6. 执行sql，接受返回结果\n> 7. 处理结果\n> 8. 释放资源\n\t\n### 代码实现：\n```java \n    //1. 导入驱动jar包\n    //2.注册驱动\n    Class.forName(\"com.mysql.jdbc.Driver\");\n    //3.获取数据库连接对象\n    Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\");\n    //4.定义sql语句\n    String sql = \"update account set balance = 500 where id = 1\";\n    //5.获取执行sql的对象 Statement\n    Statement stmt = conn.createStatement();\n    //6.执行sql\n    int count = stmt.executeUpdate(sql);\n    //7.处理结果\n    System.out.println(count);\n    //8.释放资源\n    stmt.close();\n    conn.close();\n```\n## 详解各个对象：\n> 1. DriverManager：驱动管理对象,用于注册驱动，告诉程序该使用哪一个数据库驱动jar,获取数据库连接。\n> 2. Connection：数据库连接对象:获取执行sql的对象,管理事务\n> 3. Statement：执行sql的对象\t\t\t\n> 4. ResultSet：结果集对象,封装查询结果\n> 5. PreparedStatement：执行sql的对象\n>     1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题\n>     2. 解决sql注入问题：使用PreparedStatement对象来解决\n>     3. 预编译的SQL：参数使用?作为占位符\n  \n## SQL注入攻击：\n> &emsp; 由于后台的SQL语句是拼接而来的。其中的参数是由用户提交的，如果用户在提交参数时，在其中掺杂了一些SQL关键字或者特殊符号，就可能会导致SQL语句的语意发生变化。从而执行一些意外的操作。\n## 防止SQL注入攻击\n> &emsp; 使用PreparedStatement对象来替代Statement对象。PreparedStatement对象比Statement对象更安全，效率更高。\n\n\n## 数据库连接池\n> &emsp; 在开发中，所谓的池就是一个容器，来存储程序的中的数据.而数据库连接池就是用来存储数据库连接的池子，用于在整个程序中共享连接，减少连接开关的次数，实现连接的复用，从而提高程序执行的效率.\n\n### 为什么要使用数据库连接池?\n> &emsp; 对于数据库来说，频繁的开关连接会非常的耗费资源，也会导致程序执行效率的低下。我们可以在程序中创建一个池子，在程序启动时就初始化一批连接放在连接池中，当用户需要连接时，就直接从池子中拿一个连接使用，当用完连接后，也不要将连接关闭，而是将连接还回池中，下一个用户需要连接时也是如此。这样可以减少链接开关的次数，从而提供程序执行的效率.\n\n\n## 抽取JDBC工具类 ： JDBCUtils\n### 代码实现：\n```java \n    public class JDBCUtils {\n    private static String url;\n    private static String user;\n    private static String password;\n    private static String driver;\n    /**\n        * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块\n        */\n    static{\n        //读取资源文件，获取值。\n\n        try {\n            //1. 创建Properties集合类。\n            Properties pro = new Properties();\n\n            //获取src路径下的文件的方式--->ClassLoader 类加载器\n            ClassLoader classLoader = JDBCUtils.class.getClassLoader();\n            URL res  = classLoader.getResource(\"jdbc.properties\");\n            String path = res.getPath();\n            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties\n            //2. 加载文件\n            // pro.load(new FileReader(\"D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties\"));\n            pro.load(new FileReader(path));\n\n            //3. 获取数据，赋值\n            url = pro.getProperty(\"url\");\n            user = pro.getProperty(\"user\");\n            password = pro.getProperty(\"password\");\n            driver = pro.getProperty(\"driver\");\n            //4. 注册驱动\n            Class.forName(driver);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n​\t\n```java \n\t    /**\n\t     * 获取连接\n\t     * @return 连接对象\n\t     */\n\t    public static Connection getConnection() throws SQLException {\n\t\n\t        return DriverManager.getConnection(url, user, password);\n\t    }\n\t\n\t    /**\n\t     * 释放资源\n\t     * @param stmt\n\t     * @param conn\n\t     */\n\t    public static void close(Statement stmt,Connection conn){\n\t        if( stmt != null){\n\t            try {\n\t                stmt.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( conn != null){\n\t            try {\n\t                conn.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n```\n\n​\t\n```java\n\t    /**\n\t     * 释放资源\n\t     * @param stmt\n\t     * @param conn\n\t     */\n\t    public static void close(ResultSet rs,Statement stmt, Connection conn){\n\t        if( rs != null){\n\t            try {\n\t                rs.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( stmt != null){\n\t            try {\n\t                stmt.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( conn != null){\n\t            try {\n\t                conn.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n\t\n\t}\n```\t\n\n## JDBC控制事务：\n### 什么是事务？\n>\t就是讲一堆sql绑定在一起执行，要么全部执行成功，要么全部都执行失败。   \n\n### 事物的四大特性：\n> 1. 原子性：事务中的所有操作是一个整体，不能在分割，要么全部执行成功，要么全部都执行失败！\n> 2. 一致性：事务前后的业务数据保持不变。\n> 3. 隔离性：事务之间是具有隔离的，一个事务不能访问另外一个事务正在执行的操作。\n> 4. 持久性：事务一旦提交成功，数据的改变将会是永久的。  \n\n### 事务的并发读问题：\n> 1. 脏读：在一个事务中读取到了另外一个事务未提交的数据。\n> 2. 不可重复读：在一个事务中读取到了另一个事物已提交的数据，两次查询的结果不一致，（修改）操作。\n> 3. 幻读：对同一张表的两次查询结果不一致（插入/删除）操作。  \n\n### 事务的隔离级别\n> 1. 读未提交：安全性最低，不能防止任何读并发问题，但是效率高。\n> 2. 读已提交：安全性比<font color=red>读未提交</font>高，可以防止脏读，但是不能防止不可重复读，效率比<font color=red>读未提交</font>低。\n> 3. 可重复读：安全性比<font color=red>读已提交</font>高，可以防止脏读和不可重复读，但是不能防止幻读，效率比<font color=red>读未提交</font>低。\n> 4.   串行化：安全性高，可以防止一切并发读问题，效率最低，不使用这种隔离级别，因为效率太低。  \n\n### 事务隔离级别\n> 事务隔离级别分四个等级，在相同数据环境下，对数据执行相同的操作，设置不同的隔离级别，可能导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力也是不同的。\n> 1. READ UNCOMMITTED（读未提交数据）：安全级别最低, 可能出现任何事务并发问题(比如脏读、不可以重复读、幻读等) 性能最好。\n> 2. READ COMMITTED（读已提交数据）（Oracle默认）防止脏读，没有处理不可重复读，也没有处理幻读；性能比REPEATABLE READ好。\t \n> 3. REPEATABLE READ（可重复读）（MySQL默认）防止脏读和不可重复读，不能处理幻读问题；性能比SERIALIZABLE好。 \n> 4. SERIALIZABLE（串行化）不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的；性能最差。  \n\t \n> MySQL的默认隔离级别为REPEATABLE READ，即可以防止脏读和不可重复读\n\n\n​\t\t\t","tags":["基础知识"],"categories":["Jdbc基础知识"]},{"title":"Java常用API小Demo","url":"/2018/02/06/Java常用API小Demo/","content":"\n# charAt\n&emsp;获取给定位置对应的字符\n```java\n\tpublic static void main(String[] args) {\n\t\t//            0123456789012345\n\t\tString str = \"thinking in java\";\t\t\n\t\tchar c = str.charAt(10);\n\t\tSystem.out.println(c);\n\t\t\n\t\t//判断回文            0 1 2 3  5 6 7 8\n\t\tString line = \"上海自来水自来海上\";\t\n\t\tfor(int i=0;i<line.length()/2;i++) {\n\t\t\tif(line.charAt(i) !=\n\t\t\t   line.charAt(line.length()-1-i)\t\t\n\t\t\t) {\n\t\t\t\tSystem.out.print(\"不\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"是回文!\");\n\t}\n```\n# indexOf\n&emsp;获取给定字符串在当前字符串中的位置，若当前字符串中不含有给定内容则返回值为-1\n\n```java\npublic class IndexOfDemo {\n\tpublic static void main(String[] args) {\n\t\t//            0123456789012345\n\t\tString str = \"thinking in java\";\n\t\t\n\t\tint index = str.indexOf(\"in\");\n\t\tSystem.out.println(index);//2\n\t\t\n\t\t//从指定位置开始检索第一次出现指定内容的位置\n\t\tindex = str.indexOf(\"in\",3);\n\t\tSystem.out.println(index);//5\n\t\t\n\t\t//检索最后一次出现指定内容的位置\n\t\tindex = str.lastIndexOf(\"in\");\n\t\tSystem.out.println(index);//9\n\t\t\n\t}\n}\n```\n   \n\n# lenght\n&emsp;获取当前字符串的长度(字符个数)\n```java\npublic class LengthDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"我爱java\";\n\t\tint len = str.length();\n\t\tSystem.out.println(\"len:\"+len);\n\t}\n}\n\n```\n\n\n# startsWith,endsWith\n&emsp;判断字符串是否是以给定的字符串开始或结尾的\n\n```java\npublic class StartsWithDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"thinking in java\";\n\t\t\n\t\tboolean starts = str.startsWith(\"thin\");\n\t\tSystem.out.println(starts);\n\n\t\tboolean ends= str.endsWith(\"ava\");\n\t\tSystem.out.println(ends);\n\t\t\n\t}\n}\n```\n\n\n\n# String\n&emsp;String是不变对象。JVM对String有一个优化，即:常量池,当使用字面量形式创建字符串对象时，JVM会将其缓存在常量池中，当再次使用该字面量创建字符串对象时即重用对象，避免内存中堆积大量内容一样的字符串对象，减少内存开销。\n\n```java\npublic class StringDemo {\n\tpublic static void main(String[] args) {\n\t\t//字面量  直接量\n\t\tString s1 = \"123abc\";\n\t\tString s2 = \"123abc\";\n\t\tString s3 = \"123abc\";\n\t\t//s2,s3重用了s1创建的对象\n\t\tSystem.out.println(s1==s2);\n\t\tSystem.out.println(s1==s3);\n\t\t/*\n\t\t * 字符串为不变对象\n\t\t * 即:字符串一旦创建，内容是不可以改变的，若想\n\t\t * 改变内容一定会创建新对象\n\t\t */\n\t\tSystem.out.println(s1);//123abc!\n\t\tSystem.out.println(s2);//123abc\n\t\tSystem.out.println(s1==s2);//不再相同\n\t\t\n\t\t/*\n\t\t * 这里发挥了编译器的一个特性:\n\t\t * 编译器在编译源代码时，若发现一个计算表达式\n\t\t * 参与运算的内容是确定值时，会在编译期间直接\n\t\t * 进行计算，并将计算结果编译到class文件中。避免\n\t\t * JVM每次执行程序时再做运算，从而提高性能。\n\t\t * 如下代码，编译器编译后改为了:\n\t\t * String s4 = \"123abc\";\n\t\t */\n\t\tString s4 = \"123\"+\"abc\";\n\t\tSystem.out.println(s4);//123abc\n\t\tSystem.out.println(s2==s4);//true\n\t\t\t\t\n\t\tString s5 = \"123\";\n\t\tString s6 = s5 + \"abc\";\n\t\tSystem.out.println(s6);//123abc\n\t\tSystem.out.println(s2==s6);//false\n\t}\n}\n\n```\n\n\n\n# substring\n&emsp;截取指定范围内的字符串 String substring(int start,int end)\n\n```java\npublic class SubStringDemo {\n\tpublic static void main(String[] args) {\n\t\t//            01234567890\n\t\tString str = \"www.tedu.cn\";\n\t\t/*\n\t\t * java api中有一个特点，通常使用两个数字表示\n\t\t * 范围时，都是\"含头不含尾\"的.\n\t\t */\n\t\tString sub = str.substring(4, 8);\n\t\tSystem.out.println(sub);//tedu\n\t\t/*\n\t\t * 一个参数的为从指定位置截取到字符串末尾\n\t\t */\n\t\tsub = str.substring(4);\n\t\tSystem.out.println(sub);\n\t\t\n\t}\n}\n```\n\n\n\n# ToUpperCase\n&emsp;将当前字符串中的英文部分转换为全大写或全小写\n\n```java\npublic class ToUpperCaseDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"我爱Java\";\n\t\t\n\t\tString upper = str.toUpperCase();\n\t\tSystem.out.println(upper);\n\t\t\n\t\tString lower = str.toLowerCase();\n\t\tSystem.out.println(lower);\n\t}\n}\n```\n\n\n\n\n# trim\n&emsp;去除当前字符串两边的空白字符\n\n```java\npublic class TrimDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"  hello\t\t\t\";\n\t\tString trim = str.trim();\n\t\tSystem.out.println(str);\n\t\tSystem.out.println(trim);\n\t}\n}\n\n```\n\n\n# valueOf\n&emsp;字符串提供了一组重载的valueOf方法。可以将其他类型转换为字符串\n\n```java\n\tpublic static void main(String[] args) {\n\t\tint d = 123;\n\t\tString str = String.valueOf(d);\n\t\tSystem.out.println(str);\n\t\t//任何内容和字符串连接结果也能转换为字符串\n\t\tstr = d + \"\";\n\t\tSystem.out.println(str);\n\t\t\n\t\tdouble dou = 123.123;\n\t\tString str2 = String.valueOf(dou);\n\t\tSystem.out.println(str2);\n\t}\n```\n\n\n\n\n# trim\n&emsp;去除当前字符串两边的空白字符\n\n```java\npublic class TrimDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"  hello\t\t\t\";\n\t\tString trim = str.trim();\n\t\tSystem.out.println(str);\n\t\tSystem.out.println(trim);\n\t}\n}\n\n```\n\n\n\n\n# Matches\n&emsp;字符串支持正则表达式方法一: 使用给定的正则表达式验证当前字符串是否符合格式要求,符合则返回true。\n\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString email = \"fancq@tedu.cn\";\n\t\t/*\n\t\t * 邮箱的正则表达式\n\t\t * \\w+@[a-zA-Z0-9]+(\\.[a-zA-Z]+)+\n\t\t */\n\t\tString regex = \"\\\\w+@[a-zA-Z0-9]+(\\\\.[a-zA-Z]+)+\";\n\t\tboolean match = email.matches(regex);\n\t\tif(match) {\n\t\t\tSystem.out.println(\"是邮箱!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"不是邮箱!\");\n\t\t}\n\t}\n\n```\n\n# replaceAll\n&emsp;字符串支持正则表达式方法三:\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString str = \"abc123def456ghi\";\n\t\t/*\n\t\t * 将当前字符串中的数字部分替换为\"#NUMBER#\"\n\t\t */\n\t\tstr = str.replaceAll(\"\\\\d+\", \"#NUMBER#\");\n\t\tSystem.out.println(str);\n\t}\n```\n\n\n# Split\n&emsp; 字符串支持正则表达式方法二: 将当前字符串中按照满足正则表达式的部分进行拆分，并将拆分出的每部分以一个字符串数组形式返回。\n\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString str = \"abc123def456ghi\";\n\t\t/*\n\t\t * 按照数字部分拆分，得到所有的字母部分\n\t\t */\n\t\tString[] arr = str.split(\"[0-9]+\");\n\t\tSystem.out.println(arr.length);\n\t\tSystem.out.println(Arrays.toString(arr));\n\t\t\n\t\t/*\n\t\t * 如果连续匹配了两次要拆分的内容时，中间会拆分\n\t\t * 出一个空字符串，但是若在字符串末尾连续匹配则\n\t\t * 所有拆分出的空字符串都会被忽略。\n\t\t */\n\t\tstr = \"abc,,,def,ghi,,,,,,,,,,,,,,,,,,,\";\n\t\tarr = str.split(\",\");\n\t\tSystem.out.println(arr.length);\n\t\tSystem.out.println(Arrays.toString(arr));\n\n```\n\n\n\n\n# StringBuilder  \n\n1. StringBuilder是专门设计用来编辑字符串内容的API。由于String不适合频繁修改，所以在实际开发中如果有经常，修改字符串的操作时，可以使用StringBuilder来完成。\n2. StringBuilder内部维护一个可变的字符数组，所以修改的过程中资源开销小。并且提供了对应的操作:增，删，改，插\n\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString str = \"好好学习java\";\n\t\t//默认方式创建内部表示一个空字符串:\"\"\n//\t\tStringBuilder builder = new StringBuilder();\n\t\t//创建时表示给定字符串内容\n\t\tStringBuffer builder = new StringBuffer(str);\n\t\t/*\n\t\t * 好好学习java\n\t\t * 好好学习java,为了找个好工作!\n\t\t * append:将指定内容追加到当前字符串末尾\n\t\t */\n\t\tbuilder.append(\",为了找个好工作!\");\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t\t\n\t\t/*\n\t\t * 好好学习java,为了找个好工作!\n\t\t * 好好学习java,就是为了改变世界!\n\t\t * replace:将指定范围内的字符串替换为给定内容\n\t\t */\n\t\tbuilder.replace(9, 16, \"就是为了改变世界\");\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t\t\n\t\t/*\n\t\t * 好好学习java,就是为了改变世界!\n\t\t * ,就是为了改变世界!\n\t\t * delete:删除指定范围内的字符串\n\t\t */\n\t\tbuilder.delete(0, 8);\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t\t\n\t\t/*\n\t\t * ,就是为了改变世界!\n\t\t * 活着,就是为了改变世界!\n\t\t * insert:将指定内容插入到指定位置\n\t\t */\n\t\tbuilder.insert(0, \"活着\");\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t}\n\n\n```\n\n\n\n\n# StringBuilder效率测试\n\n```java\n\tpublic static void main(String[] args) {\n\t\tStringBuilder builder = new StringBuilder(\"a\");\n\t\tfor(int i=0;i<10000000;i++) {\n\t\t\tbuilder.append(\"a\");\n\t\t}\n\t\tSystem.out.println(\"执行完毕!\");\n\t}\n```\n\n\n\n\n# 包装类\n&emsp;包装类是为了解决基本类型不能直接参与面向对象开发的问题，其中6个数字类型的包装类都继承自java.lang.Number。其余两个直接继承自Object，Number是一个抽象类，定义了数字类型包装类公有的行为，允许在数字类型之间互转。\n\n\n```java\n\t\tpublic static void main(String[] args) {\n\t\tint d = 128;\n//      将基本类型转换为包装类\n//\t\tInteger i1 = new Integer(d);\n//\t\tInteger i2 = new Integer(d);\n\t\t\n\t\t//从基本类型转换为包装类建议使用valueOf方法:\n\t\tInteger i1 = Integer.valueOf(d);\n\t\tInteger i2 = Integer.valueOf(d);\n\t\t\n\t\tSystem.out.println(i1==i2);//false\n\t\tSystem.out.println(i1.equals(i2));//true\n\t\t\n\t\tdouble dou = 1.0;\n\t\tDouble dou1 = Double.valueOf(dou);\n\t\tDouble dou2 = Double.valueOf(dou);\n\t\tSystem.out.println(dou1==dou2);\n\t\tSystem.out.println(dou1.equals(dou2));\n\t\t\n\t\t/*\n\t\t * 将包装类转换为基本类型\n\t\t */\n\t\t int in = i1.intValue();\n\t\t System.out.println(in);\n\t\t\n\t\t double dd = i1.doubleValue();\n\t\t System.out.println(dd);\n\t\t \n\t\t //可能出现溢出问题\n\t\t byte b = i1.byteValue();\n\t\t System.out.println(b);\n\t\t \n\t\t /*\n\t\t  * 数字类型的包装类都支持两个常量:\n\t\t  * MAX_VALUE,MIN_VALUE\n\t\t  * 用于表示其对应的基本类型数据的取值范围\n\t\t  */\n\t\t //int最大值与最小值?\n\t\t int imax = Integer.MAX_VALUE;\n\t\t System.out.println(imax);\n\t\t\n\t\t int imin = Integer.MIN_VALUE;\n\t\t System.out.println(imin);\n\t\t\n\t\t long lmax = Long.MAX_VALUE;\n\t\t System.out.println(lmax);\n        }\n}\n\n```\n  \n# Integer\n&emsp;JDK5发布时，推出了一个特性:自动拆装箱,允许编译器在编译源代码时将基本类型与引用类型之间互相,赋值时补全代码自动进行转换。\n\n```java\n\t\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 触发了编译器自动拆箱特性:\n\t\t * 编译器会将下面的代码改为\n\t\t * int d = new Integer(1).intValue();\n\t\t */\n\t\tint d = new Integer(1);\n\t\t/*\n\t\t * 触发了自动装箱特性:\n\t\t * 编译器会改为:\n\t\t * Integer i = Integer.valueOf(d);\n\t\t */\n\t\tInteger i = d;\n\t}\n\n```\n\n\n    \n# parse\n&emsp;包装类提供了一个静态方法:parseXXX(String str)，可以将给定的字符串转换为对应的基本类型，前提是该字符串，内容要正确的描述基本类型可以保存的值\n\n```java\n\t\tpublic static void main(String[] args) {\n\t\tString str = \"123\";\n\t\tint d = Integer.parseInt(str);\n\t\tSystem.out.println(d);\n\t\t\n\t\tdouble dou = Double.parseDouble(str);\n\t\tSystem.out.println(dou);\n\t}\n\n```\n\n\n    \n# Object常用方法\n&emsp;使用当前类测试Object常用方法:\n\n```java\n\tpublic class Point {\n\tprivate int x;\n\tprivate int y;\n\tpublic Point(int x, int y) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic int getX() {\n\t\treturn x;\n\t}\n\tpublic void setX(int x) {\n\t\tthis.x = x;\n\t}\n\tpublic int getY() {\n\t\treturn y;\n\t}\n\tpublic void setY(int y) {\n\t\tthis.y = y;\n\t}\n\t/**\n\t * 重写toString方法。\n\t * toString方法是一个非常常用的方法，很多API的操作\n\t * 都会间接调用该方法。\n\t * 方法的目的是将当前对象转换为字符串，具体返回的字符串\n\t * 格式没有固定要求，遵循的原则是返回的内容中包含当前\n\t * 对象的属性信息，可以通过该字符串的内容直观反应出当前\n\t * 对象的内容。\n\t */\n\tpublic String toString() {\n\t\t//(1,2)\n\t\treturn \"(\"+x+\",\"+y+\")\";\n\t}\n\t\n\t/**\n\t * Object定义的equals方法的设计意图是比较两个对象的\n\t * 内容是否相同。\n\t * 如果不重写该方法，那么Object内部是用\"==\"比较的，\n\t * 这样就失去了equals比较的意义了。所以当我们需要调用\n\t * 一个类的equals时，该方法就应当重写。\n\t * 注:java提供的类大部分都已经重写过了。只有我们自定义\n\t * 的类需要自行重写。\n\t * \n\t * p.equals(p2)\n\t * this:p\n\t * o:p2\n\t */\n\tpublic boolean equals(Object o) {\n\t\tif(o==null) {\n\t\t\treturn false;\n\t\t}\n\t\tif(this==o) {\n\t\t\treturn true;\n\t\t}\n\t\tif(o instanceof Point) {\n\t\t\tPoint p = (Point)o;\n\t\t\treturn this.x==p.x&&this.y==p.y;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n# 文件复制\n```java\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t//创建一个RAF用于读取原文件\n\t\tRandomAccessFile src\n\t\t\t= new RandomAccessFile(\"mv.mp4\",\"r\");\n\t\t\n\t\t//再创建另一个RAF用于向复制文件中写\n\t\tRandomAccessFile desc\n\t\t\t= new RandomAccessFile(\"mv_cp.mp4\",\"rw\");\n\t\t//用于记录每次读取到的字节\n\t\tint d = -1;\n\t\t/*\n\t\t * 循环从原文件中读取每一个字节，只要没有读取到\n\t\t * 文件末尾，就将读取到的字节写入到复制文件中。\n\t\t */\n\t\tlong start = System.currentTimeMillis();\n\t\twhile( (d = src.read())  != -1  ) {\n\t\t\tdesc.write(d);\n\t\t}\n\t\tlong end = System.currentTimeMillis();\n\t\tSystem.out.println(\"复制完毕!耗时:\"+(end-start)+\"ms\");\n\t\t\n\t\tsrc.close();\n\t\tdesc.close();\n\t}\n```\n\n\n#  java.io.RandomAccessFile类\n&emsp; 用来读写文件数据的类，其基于指针对文件数据进行读写操作\n\n```java\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t/*\n\t\t * RandomAccessFile创建有两种模式:\n\t\t * r:只读模式，只读取文件数据，并不会写入内容\n\t\t * rw:读写模式，对文件既可以读也可以写。\n\t\t * \n\t\t * 常见构造方法:\n\t\t * RandomAccessFile(String path,String mode)\n\t\t * RandomAccessFile(File file,String mode)\n\t\t * mode:创建的模式(r,rw)\n\t\t */\n\t\t/*\n\t\t * 对当前目录下的raf.dat文件进行读写操作\n\t\t * 对于\"rw\"模式创建时，若指定的文件不存在时会自动\n\t\t * 创建出来，若为\"r\"只读模式时，若指定的文件不存在\n\t\t * 则会直接抛出异常:FileNotFoundException\n\t\t */\n\t\tRandomAccessFile raf = new RandomAccessFile(\"raf.dat\",\"rw\");\t\n\t\t/*\n\t\t * void write(int d)\n\t\t * 向文件中写入1个字节，写入的是给定的int值对应的\n\t\t * 2进制的\"低八位\"\n\t\t *                            vvvvvvvv\n\t\t * 00000000 00000000 00000000 00000010\n\t\t * 00000000 00000000 00000000 11111111\n\t\t * 00000000 00000000 00000001 00000000\n\t\t * \n\t\t * 00000001 00000010\n\t\t */\n\t\traf.write(1);\n\t\traf.write(2);\n\t\tSystem.out.println(\"写出完毕!\");\n\t\t\n\t\traf.close();\n\t\t\n\t}\n\n\n```\n\n\n# 创建文件\n&emsp;使用File创建一个新文件\n\n```java\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t/*\n\t\t * 在当前目录下新建一个文件test.txt\n\t\t */\n\t\tFile file = new File(\"./test.txt\");\n\t\t//判断File表示的文件或目录是否已经真实存在了\n\t\tif(!file.exists()) {\n\t\t\t//将File表示的文件创建出来\n\t\t\tfile.createNewFile();\n\t\t\tSystem.out.println(\"文件创建成功!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"文件已存在!\");\n\t\t}\n\t}\n```\n\n\n# 删除文件\n&emsp;删除一个文件\n```java\n\t\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 删除当前目录下的test.txt\n\t\t * \"./\"可以忽略不写，默认就是当前目录\n\t\t */\n\t\tFile file = new File(\"test.txt\");\n\t\tif(file.exists()) {\n\t\t\tfile.delete();\n\t\t\tSystem.out.println(\"文件已删除!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"文件不存在!\");\n\t\t}\n\t}\n\n\n```\n\n# 创建目录\n&emsp;创建一个目录\n```java\n\t\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 在当前目录下新建一个目录:demo\n\t\t */\n\t\tFile dir = new File(\"demo\");\n\t\tif(!dir.exists()) {\n\t\t\t//创建该目录\n\t\t\tdir.mkdir();\n\t\t\tSystem.out.println(\"目录已创建!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"目录已存在!\");\n\t\t}\n\t}\n```\n\n# 创建多级目录\n&emsp;创建一个多级目录\n```java\n\tpublic static void main(String[] args) {\n\t\t/*\n\t\t *\t在当前目录下新建目录:\n\t\t *\t./a/b/c/d/e/f\n\t\t */\n\t\tFile dir = new File(\"./a/b/c/d/e/f\");\n\t\tif(!dir.exists()) {\n\t\t\t/*\n\t\t\t * mkdirs会将所有不存在的父目录一同创建出来\n\t\t\t */\n\t\t\tdir.mkdirs();\n\t\t\tSystem.out.println(\"目录已创建!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"目录已存在!\");\n\t\t}\n    }\n```","tags":["基础知识"],"categories":["Java基础知识"]},{"title":"Http协议基础知识","url":"/2018/02/06/Http协议基础知识/","content":"\n# Http协议  \n\n## 什么是http协议\n当在上网浏览网页的时候，浏览器和服务器之间就会通过Http在Internet上进行数据的发送和接受。\nHTTP协议规定了浏览器和服务器之间通信的方式，也可以说是通信的规则。是应用层协议，是一个基于请求/响应模式的，无状态的协议。\n> 具体说，HTTP协议中主要规定了两个内容：\n    > 1. 规定了浏览器该如何给服务器发送请求信息（即请求信息的格式）\n    > 2. 同时也规定了服务器该如何给浏览器做响应信息（即响应信息的格式）   \n\n---\n\n## Http1.0\n> 当连接建立之后，浏览器发送一个请求，服务器回应一个消息，之后连接就被关闭。当浏览器下一次请求的时候，需要重新建立新的连接，显然这种需要不断建立连接的通信方式开销较大。早期的web页面通常只包含HTML文件，因此即使建立连接的开销比较大，也不会有太大的影响。而现在的web页面通常包含多种资源，（图片，动画，声音），每获取一种资源，就建立一次连接。这样就增加了HTTP服务器的开销，造成了Internet上的信息阻塞。\n---\n\n## Http1.1\n> 因此在Http1.1版本中，给出了一个持续连接的机制，并将其作为1.1中建立连接的缺省行为，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到响应，然后继续发送请求并在此得到回应，而且客户端还可以发送流水线请求，也就是说，客户端可以连续发送多个请求，而不用等待每一个响应的到来。\n---   \n\n## 三次握手\n>1. 客户端与服务器端建立连接前，客户端会向服务器发送第一条消息，询问服务器端是否准备好了。第一次握手\n>2. 服务器端收到客户端发来的询问之后，会给客户端发送一条消息，告诉客户端已经准备好了。第二次握手\n>3. 当客户端在收到服务器端发过来的消息之后，会在此确认，客户端会在向服务器发起响应确认准备好了，第三次握手。之后建立连接\n   \n---   \n\n## Http工作时遵循的基本原则(了解):\n> 1. 基于请求响应模型\n> 2. 一次请求只对应一次响应\n> 3. 只能是浏览器向服务器发送请求, 服务器只能等待浏览器的请求, 再根据请求做出回应\n--- \n\n## GET请求和POST请求方式的区别：\n两者之间的区别主要体现在请求参数发送过程的不相同\n> GET提交: 通过请求行拼接参数将数据发送给服务器\n    > &emsp;1.通过地址栏携带参数, 相对不安全\n    > &emsp;2.通过地址栏发送数据, 数据量不能太大(不能超过1kb或者是4kb);  \n\n> POST提交: 通过请求实体内容携带参数, 数据不会显示在地址栏\n    > &emsp;1.参数不会出现地址栏, 相对更安全\n    > &emsp;2.数据通过请求实体内容发送, 数据量理论上没有限制.\n---\n\n\n## 服务器种类：\n> Tomcat、Resin、Jetty、Weblogic、WebSphere、JBoss\n\n> B/S：Browser Server 浏览器服务器模型  （不需要下载客户端的） 京东、淘宝、网页游戏。\n> 优点：不需要下载客户端程序，使用浏览器可以直接访问，程序的升级操作是在服务器端进行的。\n> 缺点：浏览器具有一定的局限性，页面的展示差，页面的数据需要从服务器实时获取，对网速的依赖很高\n\n> C/S：Client Server客户端服务器模型       （需要下载客户端的） QQ  LOL 梦幻西游 。\n> 优点：客户端可以任意设计，页面的展示能力强。由于大量资源已经保存在了客户端，对服务器的交互仅仅是一些数据的变化，对于网速的依赖很低。\n> 缺点：第一次使用时需要下载客户端程序，一旦程序需要升级操作，所有的客户端程序都需要升级。\n---\n\n## XML解析方式：\n### DOM解析：\n>原理：\n\t> 解析器将整个xml文档加载进内存，保存为一颗Document的对象树，\n\t> 通过Document对象，得到树上的节点对象，对每个对象提供增删改查操作对应的方法\n>优点：\n\t> &emsp;1.可以十分方便对节点进行增删改查操作，\n\t> &emsp;2.解析一次即可重复使用数据由于在内存中保存了文档结构树，\n>缺点：\n\t> &emsp;1.如果文档较大，占用内存空间，甚至内存溢出\n\t> &emsp;2.将整个文档解析完才能操作，相对耗费时间，效率低\n   \n\n### SAX解析：\n> 原理：解析器逐行扫描xml文档，利用处理器接口中的方法进行解析\n> 优点：\n\t> &emsp;1.无需将整个xml文档加载到内存，占用内存小\n\t> &emsp;2.由于逐行解析，遇到需要内容停下来处理，效率高\n> 缺点：\n\t> &emsp;1.每次需要数据，都要重新解析\n    > &emsp;2.只能读取数据，不能做增删改操作。   \n\n---","tags":["基础知识"],"categories":["http"]},{"title":"Java基础知识总结","url":"/2018/02/01/Java基础知识总结/","content":"Java基础知识整理\n<!--more-->\n# 基础部分\n## Java编译运行过程\n1. 编译期：java源文件，经编译生成.class文件\n2. 运行期：JVM加载.class文件，并运行class\n3. 特点：跨平台，一次编译到处使用\n\n## 名词释义\n1. JVM：java虚拟机，作用就是加载.class文件，运行.class文件\n2. JRE： java开发环境，除了包含JVM外，还包含java程序运行所必须的环境\n3. JDK：java开发工具包，除了包含JRE外，还包含编译，运行等命令工具3. \n\n## 数据类型\n| **byte类型**     | **8位**  | **范围：-128~127**               |\n| ---------------- | -------- | --------------------------------|\n| **short 类型**   | **16位** | **范围：-32768~32767**           |\n| **char  类型**   | **16位** | **范围：\\u0000~\\u65535**         |\n| **int类型**      | **32位** | **范围：-2147483648~2147483647** |\n| **long 类型**    | **64位** | **范围：很大很大 2^63**           |\n| **float 类型**   | **32位** |                                  |\n| **double 类型**  | **64位** |                                  |\n| **boolean 类型** | **8位**  |                                  |\n\n\n## 基本类型自动转换\n1. 从小到大依次为：byte < short < int < long < float < double\n2. 自动类型转换：小类型转大类型 （小杯子往大杯子倒水）\n3. 强制类型转换：大类型转小类型 （大杯子往小杯子倒数）\n\n## 运算符\n1. 算数：    +，-，*，/，%，++，--\n2. 关系：>,<,>=,<=,==,!=,boolean\n3. 逻辑：&&，||，!boolean\n4. 赋值：=，+=，-=，*=，/=，%=\n5. 字符连接运算符：+\n6. 条件/三目运算：boolean?数1:数2;\n\n## 分支结构\n1. If\n2. If…else\n3. If…elss     if\n4. Switch…case\n\n## 循环\n1. while循环\n2. do...while循环\n3. for循环\n\n\n\n## 数组\n1. 数组的定义：int [ ] arr =new int [ 10 ] \n2. 数组的初始化：int [ ] arr = new int [ ] \n3. 数组的访问：通过数组名.length可以获取数组的长度，也就是数组内元素的个数通过索引来访问数组元素，下标从0开始，最大到数组长度-1\n4. 数组遍历\n   ```java\n   int[] arr = new int[10];\n   \n   for (int i = 0; i < arr.length; i++) {\n       arr[3] = (int) (Math.random() * 100);\n   }\n   \n   for (int i = 0; i < arr.length; i++) {\n       System.out.println(arr[i]);    //正序输出\n   }\n   \n   for (int i = arr.length - 1; i >= 0; i--) {\n       System.out.println(arr[i]);    //倒序输出\n   }\n   ```\n\n## 访问修饰符\n| **private**   | **同类可见**               | **可以修饰变量、方法**           | **注意：不能修饰类(外部类)** |\n| ------------- | -------------------------- | -------------------------------- | ---------------------------- |\n| **default**   | **同包同类可见**           | **可以修饰类、接口、变量、方法** |                              |\n| **protected** | **同包同类和所有子类可见** | **可以修饰变量、方法**           | **注意不能修饰类(外部类)**   |\n| **public**    | **所有类可见**             | **可以修饰类、接口、变量、方法** |                              |\n\n\n\n## 非访问修饰符\n&emsp;为了实现某一些功能，java也提供了许多非访问修饰符\n> static修饰符：\n   > 1. static关键字修饰的变量称之为静态变量，无论一个类实例化多少对象，他的静态变量只有唯一的一个。\n   > 2. static关键字修饰的方法称之为静态方法，静态方法只能使用类的静态变量，不可以使用非静态变量。\n\n> final修饰符：\n  > 1. Final关键字可以修饰类，表示不能有子类。\n  > 2. Final关键字可以修饰变量，表示变量不能被修改，只能有唯一一次赋值。\n  > 3. Final关键字可以修饰方法，表示不能被子类覆盖重写。\n  > 4. Final关键字修饰引用类型变量，地址值不能变，但是对象的属性可以通过set方法改变。\n\n> abstract修饰符：<font color=red>被abstract修饰的类和方法叫做抽象类和抽象方法</font>。\n  > 1. 抽象类：抽象类不能用来实例化对象，目的：是为了将来对该类进行扩充。\n  > 2. 抽象方法：继承抽象类的子类必须实现父类的所有抽象方法，除非这个子类也是抽象类，\n  > 3. 注意：如果一个类包含若干个抽象方法，那么该类必须声明为抽象类，抽象类不可以包含抽象方法。  \n\n> 抽象加单总结:\n  > 1. 抽象方法的意义：在于将方法的设计和方法的实现分离。\n  > 2. 抽象类需要被继承，抽象类定义的抽象方法子类必须重写。\n  > 3. 抽象类不能创建对象，但是可以包含构造方法，成员属性，普通方法。\n\n---\n\n# 内部类\n&emsp;一个事物的内部包含另外一个事物，就是一个类内部包含另外一个类，比如身体和心脏的关系，汽车和发动机的关系。\n> ## 成员内部类：\n > 定义在类里面的类，叫做成员内部类。\n > 使用成员内部类的两种方式:\n    > 1. 间接方式：在外部类的方法中，使用内部类，然后main只是调用外部类的方法。\n    > 2. 直接方式：外部类名称.内部类名称   \n    > 对象名 = new 外部类名称() . new 内部类名称(); (外部.内部)  \n\n> ## 局部内部类\n    > &emsp;定在在方法里面的类，叫做局部内部类，局部内部类包含了匿名内部类。  \n\n> ## 匿名内部类\n    > 作用：如果接口的实现类，或者是父类的子类，只需要使用唯一一次，那么这种情况下，就可以省略该类的定义，改用匿名内部类。\n    > 定义格式：接口名称  对象名 = new 接口名称(){ //方法体中重写所有的抽象方法 }； \n```java\npublic class MainDemo {\n    public static void main(String[] args) {\n        Myinterface myinterface = new Myinterface() {\n            @Override\n            public void method() {\n                System.out.println(\"匿名内部类方法执行\");\n            }\n        };\n        myinterface.method();\n    }\n}\n```\n---   \n\n# 面向对象\n## 什么是类？\n> 类是一个模板，包含对象的属性，方法。 \n> 我们把它理解为造汽车的图纸，图纸包含了制造汽车的各个部件的尺寸，参数等。\n\n## 什么是对象？\n> 对象是类的一个实例。\n> 我们可以对象理解为根据图纸制造出来的汽车。  \n\n## 类和对象之间的关系？  \n> 汽车就好比一个对象，图纸就好比是一个类，有了图纸才能设计出汽车，换而言之也就是有了类才能创建对象（也叫实例）。  \n\n## 面向对象的特征?\n> 记住并理解这重要的6个字，<font color=red>*封装、继承、多态*</font>&emsp;称之为面向对象的三大特征 。\n### 1. 封装  \n\n> #### 封装的概念：\n&emsp;面向对象的封装就是把描述一个对象的属性和行为的代码封装到一个类当中，属性用变量定义，行为用方法定义，然后运用访问修饰符，修饰成员变量及方法，就基本上实现了对象的封装。    \n        \n> #### 封装的好处：\n&emsp;封装的目标就是要实现软件内部的“高内聚、低耦合”，防止程序相互依赖而带来的变动的影响。解耦\n\n> #### 封装的总结：\n封装类，封装的就是对象的属性和行为。\n封装方法，封装的就是具体业务逻辑功能的实现。\n访问控制，访问修饰符（private、public....）用来封装具体的访问权限。\n\n### 2. 继承  \n> #### 封装的概念：\n&emsp; 继承也是泛化（抽取共性）的过程，在开发中我们先将子类共有的属性及方法全部抽取到父类，然后通过子类去继承父类的属性及方法实现数据和方法的共享，这是类之间的一种关系，<font color=red>继承的好处就是提高了代码的可重用性和扩展性</font>。\n\n\n### 3. 多态\n\n> #### 多态的概念\n&emsp; 一个对象拥有多种形态，这就是多态，代码体现多态其实就是一句话，<font color=red>父类引用指向子类对象</font>  \n\n> #### 多态的格式和使用\n  > 1. 父类名称  对象名称  =  new 子类名称（）；\n  > 2. 接口名称  对象名称  =  new 实现类名称（）；\n\n> #### 多态中访问成员变量的两种方式及规则\n  > 1. 直接通过对象名称访问成员变量：看等号左边是谁就优先用谁，没有则会往上寻找父类中是否存在该变量。\n  > 2. 间接通过成员方法访问成员变量：看该方法属于谁就优先用谁，没有则会往上寻找父类中是否存在该变量。\n\n> #### 多态中成员方法的访规则\n> 1. 看等号右边new的是谁，就优先用谁的方法。没有则会找到父类的方法。\n\n> #### 对比多态中成员变量和成员方法有何不同\n  > 1. 成员变量：编译看左边，运行还看左边\n  > 2. 成员方法：编译看左边，运行看右边。\n\n> #### 多态的好处\n  > &emsp; 比如Animal类有cat和dog两个子类，Animal有eat（）方法，cat和dog继承Animal也拥有了eat方法，但是狗和猫吃的东西不一样，有自己各自的方法。我们在写代码的时候  Animal  obj = new Dog();  并调用 obj.eat();  这里在编译时调用的时Animal类中的eat()方法，但是在程序运行的时候，会执行dog类中的eat()方法。new Cat();也是同理。这样就保证了等号左边的一致性，你new谁，在程序运行时，就调用谁的方法。一句话，编译看左边，运行看右边。<font color=red>多态的好处就是允许程序在运行的时候动态的创建对象，并调用对象的方法</font>。  \n\n> #### 对象向上转型\n  > &emsp; 父类引用指向子类对象。多态的写法就是向上转型。比如 将一个狗对象，当作父类动物对象来看待。    \n  > &emsp; 注意：向上转型的弊端，对象一旦向上转型为父类，那么就无法调用子类原本特有的方法。因为编译的时候根本无法通过对象点出来子类的方法，而只能调用父类的方法。\n\n> #### 对象的向下转型\n  > &emsp; 进行还原动作，比如你将一个子类对象向上转型为父类对象，你还可以将该对象转换回来，比如将狗的实例转为动物的实例，在将动物实例转换回狗的实例 　\n  > &emsp; Dog dog = (Dog) Animal();\n  > &emsp; 但是如果你在向下转型的过程中，向上转型为动物对象的狗对象还原为一个猫对象，那么就回报错。一定要注意，向下转型的时候对象的原本类型是什么，可以借助 instance of 关键字。\n> #### instance of \n  > &emsp;可以判断一个父类引用的对象，本来是什么子类。可以帮助我们在写代码的过程中，安全的向下转型。\n```java\npublic static void main(String[] args) {    \n        Animal animal = new Dog();\n        if(animal instanceof Dog){\n            Dog dog = (Dog) animal;\n            dog.eat();\n        }\n        if (animal instanceof Cat){\n            Cat cat = (Cat) animal;\n            cat.eat();\n        }     \n    }\n```  \n---  \n\n\n# 接口和抽象\n> ## 抽象类和抽象方法\n> 1. 抽象类不能直接new\n> 2. 必须需要子类实现抽象类\n> 3. 子类需要覆盖父类的抽象方法\n> 4. 创建子类进行使用  \n\n> 注意事项：\n> 1. 抽象类可以有构造函数，是供子类创建对象时，初始化父类成员使用的。\n> 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必须定义为抽象类。\n> 3. 抽象类的子类，必须重写子类中的所有抽象方法。否则编译报错。除非子类也是抽象类。  \n\n> ## 接口的概念\n    >&emsp;就是多个类的公共规范，接口是一种引用数据类型，最重要的内容就是其中的抽象方法（usb接口，插座）  \n\n> ## 接口的使用步骤\n> 1. 接口不能直接使用，必须有一个实现类来实现接口。\n> 2. 接口的实现类必须重写接口中所有的抽象方法\n> 3. 创建实现类对象，进行使用。\n> 注意事项：如果实现类并没有重写接口中的所有方法，那么这个实现类就必须是抽象类。   \n\n> ## 接口可以包含、常量、抽象方法、默认方法、静态方法、私有方法\n    > 1. <font color=red>默认方法：就是定义在接口中的静态方法。包含public default 方法名 { 方法体 }</font>。\n        > * 作用：可以解决接口升级的问题，因为接口中添加新的抽象方法，其实现类必须全部重写，\n        > * 注意：并且可以通过接口实现类对象直接调用，也可以被接口实现类覆盖重写。\n    > 2. <font color=red>静态方法：就是定义在接口中的静态方法。包含public static 方法名 { 方法体 }</font>。\n        > * 作用：不创建对象直接调用接口中的方法。静态方法和对象无关\n        > * 注意：不能通过接口实现类的对象来调用接口中的静态方法。而是直接用接口名称调用（一个类可以实现多个接口，多个接口中静态方法有可能产生冲突）（默认方法和静态方法只有在java 8会以上版本才支持）\n    > 3. <font color=red>私有方法：就是在接口中定义private关键字的方法，默认接口中方法必须是public的。（私有方法只有在java 9 或以上版本才支持）</font>\n        > * 普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名称（参数列表）{ 方法体 }\n        > * 静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名称（参数列表）{ 方法体 }\n        > * 作用：某些场景，我们需要在接口中抽取一个公有的方法，来解决两个或多个方法之间代码重复的问题，并规定只能在接口中调用，就可以通过私有方法来解决。  \n    > 4. <font color=red>常量：接口当中也可以定义“成员变量”</font>。\n        > * 类和类之间是单继承的，直接父类只有一个。\n        > * 类和接口之间是多实现的，一个接口可以实现（implements）多个接口，注意处理抽象方法的冲突问题就行。\n        > * 接口与接口之间是多继承的。就是一个接口可以继承（extends）多个接口，那么该接口就拥有了其他接口的全部抽象方法。  \n    > 5. <font color=red>注意事项（总结）</font>。\n        > *  接口不能有静态代码块或者构造方法。\n        > *  一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。\n        > *  如果实现类所实现的接口中，存在重复的抽象方法，那么只需要重写覆盖一次即可。\n        > *  如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类必须是一个抽象类。\n        > *  如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类必须冲突的默认方法进行重写。\n        > *  如果一个类的直接父类当中的方法，和接口当中的默认方法产生了冲突，会优先用父类的方法。（先继承，后实现的特点）。\n\n---\n\n# 内存管理\n> ## 堆\n    > 1. 堆中存储new出来的对象(包括实例变量)\n    > 2. 垃圾：没有任何引用所指向的对象，垃圾回收器(GC)不定时到内存中清扫垃圾，回收过程是透明的，调用System.gc()可以建议虚拟机尽快调度GC来回收\n    > 3. 内存泄漏:不再使用的内存还没有被及时的回收、建议:对象不再使用时及时将引用设置为null\n    > 4. 实例变量的生命周期：创建对象时存储在堆中，对象被回收时一并被回收  \n\n> ## 栈\n    > 1. 存储正在调用的方法中的局部变量(包括方法的参数)\n    > 2. 调用方法时，会在栈中为该方法分配一块对应的栈帧，栈帧中存储局部变量(包括方法的参数)，当方法执行结束后，栈帧被清除，局部变量一并失效\n    > 3. 局部变量的生命周期:调用方法时存储在栈中，方法结束时与栈帧一并被清除\n  \n> ## 方法区\n    > 1. 存储.class字节码文件(包括静态变量、方法)\n    > 2. 方法只有一份，通过this来区分具体的对象\n\n---\n\n\n# 集合总结  \n\n> ## 集合类的由来\n    >  &emsp;再开发过程中，我们一般用对象来封装特有数据，对象多了就需要存储，如果对象的个数不确定，就是用集合容器进行存储。  \n\n> ## 什么是集合\n\t>  &emsp;可以将集合理解为就是一个容器，因为面向对象编程会产生很多的对象，对了方便对对象的操作，所以把对象装入到集合，集合本身就是一个对象，能储存对象的对象就叫集合，存储对象的容器，就叫做集合，集合是可变长度的，数组不可变的。  \n\n> ## 集合的特点\n    >  &emsp;用于存储对象的容器，集合长度是可变的，集合中不可以存储基本数据类型值\n\n> ## 集合框架示意图\n![avatar](/images/collection.jpg)\n\n> ## Collection框架介绍\n    > &emsp;Collection是集合框架的顶级接口，Collections是是集合框架的工具类（提供集合共有的一些api）\n    > &emsp;Collection接口下有两个子接口，List接口和set接口，如上图  \n\n> ### List接口：有序可重复，存储对象有顺序，可以重复\n    > &emsp; Vector：最早的集合类，现在已经被ArrayList取代。底层也是数组\n    > &emsp; ArrayList：底层是数组，有序、可重复、有索引，异步线程不安全、特点：查找效率高，增删效率低\n    > &emsp; LinkedList：底层是双向链表，异步线程不安全，特点：增删效率高，查询效率低。不支持高效的随机元素访问。\n\n> ### Set接口：无序不可重复。不可存储重复对象，如果有重复，会覆盖。\n    > &emsp; TreeSet：底层是红黑树(自平衡的排序二叉树)，特点：有序，唯一 \n    > &emsp; hashSet：底层采用HashMap保存数据。特点：集合元素必须唯一，并且不可重复，无序的。\n    > &emsp; LinkHashSet：LinkHashSet继承HashSet，内部是通过LinkedHashMap实现。特点：集合元素必须唯一，并且不可重复，但是有序的。\n> ### Map集合：  \n\n> #### &emsp; map集合的特点:\n    > &emsp; map集合是一个双列集合，一个元素包含两个值，一个key，一个value\n    > &emsp; map集合中的元素，key和value的数据类型可以相同，也可以不同\n    > &emsp; map集合中的元素，key不允许重复，value可以重复\n    > &emsp; map集合中的元素，key和value是一一对应的关系。  \n\n> #### Map集合与collection集合的区别： \n    > &emsp; map集合中元素是成对存在的，每个元素由键与值两个部分组成的，通过键可以找到所对应的值，称之为双列集合。\n    > &emsp; collection集合中的元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储，称之为单列集合。  \n\n> #### Map集合常用子类：\n    > &emsp; HashMap：实现了Map接口，底层是哈希表。无序集合（存储元素和取出元素的顺序有可能不一致），异步多线程，查询的速度块，\n    > &emsp; LinkedHashMap：HashMap的子类，底层是哈希表+链表，是一个有序的集合，存取出元素的顺序是一直的，保证迭代的顺序。\n    > &emsp; HashTable：实现了Map接口，底层也是哈希表，不允许存储空key和value，线程安全的集合，速度慢，\n    > &emsp; properties：HashTable的子类，唯一一个和IO流相结合的集合  \n\n> #### HashMap底层原理\n    > &emsp; HashMap中维持了一个数组，数组的每一个位置称之为一个桶，每一个桶维持了一个链表，一个元素根据哈希吗进行运算，根据运算的结果平均的分配到这个桶中，放用到75%的桶的时候，会进行扩容，桶的数量会增加一倍，已有元素会重新计算哈希吗重新分布，这个过程称之为rehash，默认初始容量为16，即一开始有16个桶，当用到13个桶的时候要进行扩容。由16个桶扩容为32个桶，加载因子越大，碰撞概率越大，加载因子越小，扩容和rehash操作越频繁。  \n\n> #### HashMap 为什么速度快？\n    > &emsp; HashMap 之所以速度快，因为他使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）  \n    \n> #### hashcode为什么使用31来做相乘？\n    > &emsp; 之所以使用 31，是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代\t。替乘法，可以得到更好的性能： 31 * i == (i << 5） - i， 现代的 JVM 可以自动完成这种优化。这个公式可以很简单的推导出来  \n\n\n\n\n> ## 集合常见方法\n集合容器因为内部的数据结构不同，有多种具体容器，不断的向上抽取，就形成了集合框架，集合框架的顶层接口是collections，包含集合的共性方法\n> ### 常见方法：\n> 1. 添加 ：添加对象  boolean add（Object obj），boolean addAll\n> 2. 删除： boolean remove（object obj），boolean removeAll（object obj）\n> 3. 判断：boolean contains(Object obj），boolean containsAll(Boject ooll)，boolean ifEmpty\n> 4. 获取：int size()；获取集合元素集合的长度。\n\n> ## Iterator迭代器：\n> &emsp;专门取出集合中元素的方式，迭代器对象该对象必须依赖具体的容器，因为每一个容器的数据结构都不同，所以迭代器实在容器中进行内部实现的，对于适用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象就可以，也就是iterator方法   \n\n> ## 迭代器的实现原理：\n    > 迭代器就是实现了Iterator接口的每一个容器内部的内部对象\n    > 注意：在迭代器过程中，不要视同集合操作元素，容易出现异常，但是可以使用Iterator接口的子接口，ListIterator来完成在接待中对元素进行更多的操作，他可以实现在迭代过程中，完成对元素的增删改查，注意，只有list集合具备该迭代功能。   \n\n---\n\n# 线程总结  \n\n> ## 什么是进程？\n    > 计算机在执行的任务就是进程,比如JVM、QQ、微信、迅雷等服务本质上也是进程\n> ## 什么是线程？\n    > 进程中的小任务，多个小任务一起执行就是多线程 \n> ## 线程定义的三种方式\n    > 1. 继承Thread类，重写run()方法，将要执行的逻辑写入run方法，并调用start()方法\n    > 2. 实现Runable接口，重写run()方法，通过runnable对象来构建一个Thread对象来启动线程\n    > 3. 实现Callable<T>接口，重写call()方法.\n    > 4. 注意：为什么以上1、2两种方式都需要重写run方法？因为Thread类也实现了Runable接口。\n\n> ## api\n    > 1. Thread.currentThread().getName()获取线程的名字\n    > 2. Thread.seelp(毫秒值) 线程休息一会儿\n\n> ## 多线程的并发安全问题\n    > 线程的执行不存在先后，而是相互抢占执行，抢占并不是只发生在线程执行的开始，而是发生在线程执行的每一步过程中。由于多个线程并发导致出现一些不符合常理的数据现象---多线程并发安全问题\n\n> ## 同步代码块\n    > 同步代码块可以解决多线程并发安全问题,可以利用synchronize同步代码块来解决此问题\n    > synchronize需要指定锁对象,锁对象必须要求是这个类的所有线程都认识\n    > 共享资源，类的字节码、this（需要是同一个对象，一个对象启动四个线程）\n    > synchronize去修饰方法 ，同步方法的锁对象是this   \n\n> ## 什么是同步和异步\n    > 一段逻辑同一时间内只能一个线程执行，称之为反之叫做异步。\n    >  线程同步一定是安全的，而线程不安全一定是异步的。\n\n> ## 什么是死锁？如何解决死锁问题\n> 多个线程之间的锁形成了嵌套，导致程序无法继续运行的现象叫做死锁\n>  思考如何避免死锁？\n>  &emsp;1.减少线程数量  （理论上是可以，实际开发中不现实）。\n>  &emsp;2.统一锁对象     \n>  &emsp;3.减少锁嵌套\n\n\n> ## 线程的状态\n> 1. 创建状态\n> 2. 就绪状态\n> 3. 执行状态\n> 4. 阻塞状态 / 挂起状态   （人为阻塞 冻结状态）    \n> 5. 消亡状态\n \n> ## Sleep和wait有什么区别：\n> sleep在使用的时候需要指定休眠时间，到点自然醒。释放执行权，不释放锁。是一个静态方法，设计在了Thread类上。wait在使用的时候可以指定等待时间，也可以不指定，如果不指定等待时间就需要唤醒，释放执行权，释放锁，是一个非静态方法，设计在了Object类上。\n\n> ## 守护线程：\n> 守护别的线程，当被守护的线程结束，守护线程无论执行完成与否都得随之结束。 Daemon\n> 一个线程要么是守护线程要么是被守护的线程\n> 守护线程是随着最后一个被守护线程的结束而结束。   --GC就是一个守护线程。\n\n> ## 线程的优先级\n> 线程的优先级。1-10个等级   没有手动设置的情况下优先级默认是5。\n> 理论上数字越大等级越高，这个线程抢到资源的几率越大，相邻的两个线程的优先级的差异性不明显，至少要相差5个等级才能体现的相对明显\n","tags":["基础知识"],"categories":["Java基础知识"]}]