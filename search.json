[{"title":"SpringBoot学习","url":"/2020/03/21/SpringBoot学习/","content":"\n# SpringBoot\n\n## Java框架演变\n1. SSH（structs2、spring、hibernate）\n2. SSM（springmvc、spring、mybatis）\n3. SpringBoot：约定大约配置的概念\n\n## IOC&DI\n1. Inversion of Control：控制反转\n2. Dependency Injection：依赖注入\n\n## Springboot版本号\n例如：2.2.1.RELEASE\n2.主版本\n2.次版本\t新特性\t发布新特性\t要保证兼容\n1.增量版本\tbug修复\nRELEASE\t发布版本、里程碑版本\n\n## springboot创建项目\n1. 官网创建\n2. idea创建\n3. maven创建\n\n## springboot热部署\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n    <optional>true</optional>\n</dependency>\n```\n\n## 软件设计原则\n开闭原则(OCP) Open Closed Principle：对软件、函数、类的扩展是开放的，对修改是封闭的。\n\n修改：修改原来的代码，可能会因为某处改动，从而引起多个bug、这个bug又会引起其余的bug，这叫做修改。\n扩展：不修改原来的代码，只在原来基础上进行扩展，新增业务模块、类，来替代原来的类，这叫做扩展。\n\n面向抽象编程才能更好的实现OCP原则\n\njava中的抽象：interface abstract  不依赖于某一个具体的类，而是去依赖抽象。\n\n## DI IOC 过程\t\ninterface\n设计模式：工厂模式\nIOC/DI\n\n=>面向抽象=>OCP=>可维护的代码\n\n\n## 重点理论\n1. 单纯的interface可以统一方法的调用，但是不能统一对象的实例化。\n2. 面向对象\t实例化方法，调用方法。\n3. 只有一段代码中没有new的出现，才能保持代码的相对稳定，才能逐步实现OCP。\n4. 上面的这句话只是表象，实质是一段代码如果要保持稳定，就不应该负责对象的实例化。\n5. 对象实例化是不可能消除的。\n6. 把对象实例化的过程，转移到其他的代码片段里。\n7. 代码中总会存在不稳定，隔离这些不稳定，保证其他的代码是稳定\n8. 变化造成了不稳定，业务需求发生变化、技术选择发生变化\n9. 配置文件属于系统外部，而不属于代码本身。\n\n\n## Spring、SpringMVC与SpringBoot的关系与区别\nSpring: Spring Framework、Spring Boot 、 Spring Cloud 、Spring Data\n\nSSM Spring + Spring MVC + Mybatis\n\nSpring Framework   核心 IOC (CORE)  AOP  SpringMVC(WEB)\n\nspring boot 其实是 Spring Framework 的应用 \n\n为什么这么说，很多人讲spring-boot其实是简化配置，他比spring-framework更加方便，简单的几个注解就开始项目，无需要过多的xml配置，难道spring-framework中没有注解的方式完成一些配置吗？其实不是，springBoot是基于springFramework的，就是因为xml配置太繁琐，所以spring官方将spring-framework这个基础框架，抽象成一个更好用的上层框架，从而推出springboot，大家以后就用springboot就好了。\n\n## 什么是SpringBoot的核心优势\n\n自动配置: \n1. 原理是什么\n2. 为什么要自动转配\n\n不光是要给我们自己写的类加上注解，注入到IOC容器，SpringBoot还要注入很多第三方的SDK，便于我们开发使用，所以才会有这个自动装配。看了这句话后，在想想springboot自动装配真正要解决的问题是什么？   \n\n**SpringBoot比其他框架多出来一个IOC容器的概念，他就是将各种bean，不管是我们自己写的业务bean，还是一些第三方的SDK、去发现这些Bean，并把这些配置的Bean加入到IOC容器中去，这才是Springboot真正解决的问题。**\n\n原理要从下面三个注解讲起。\n\n@SpringBootApplication包含下面三个注解，其实springboot的启动类，我们理解成就是一个超级大的配置类\n\n@EnableAutoConfiguration\n这个注解的主要的作用就是，部分的属性是需要写入配置文件中的，允许从配置文件中去更改bean的相关属性，比如支持Redis，Mysql等等，是需要在配置文件中去配置一些属性，你才能将这些第三方的bean注入到容器中，所以该注解自动装备的一般都是用来加载第三方的SKD或依赖，不是来加载你自己写的类，而@Configuration这个注解，才是来加载你自己写的一些业务bean的。\n\n如何加载到的第三方的SDK呢？其实原理还是不变，\n@EnableAutoConfiguration中有一个重要的注解@Import(AutoConfigurationImportSelector.class)\n@Import注解有一个AutoConfigurationImportSelector.class的类\nSelector类中有一个重要的方法,selectImports()就是这个方法，\n\n```java\n\t@Override\n\tpublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n\t\tif (!isEnabled(annotationMetadata)) {\n\t\t\treturn NO_IMPORTS;\n\t\t}\n\t\tAutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n\t\t\t\t.loadMetadata(this.beanClassLoader);\n\t\tAutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,\n\t\t\t\tannotationMetadata);\n\t\treturn StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n\t}\n```\n这个方法会加载springboot-autoconfigure这个jar包中的spring-factoris这个配置文件，这个配置文件里配置了很多第三方的配置，就是通过这样的一种机制，找到第三方包中带有@Configuration的类，然后注入到ioc容器中的。跟我们自己写一个配置类是一个道理，只不过第三方的类、源码，不可能全部都丢在自己的项目中，所以还是那句话，@Configuration一般用来加载自己写的业务bean，真正加载第三方的bean，还是得依靠@EnableAutoConfiguration这个注解！但是原理，跟自己写配置类大概是一个意思，肯定比我们复杂很多啦 哈哈.. 就这么理解吧。\n\n@EnableXXXX这一类的注解，其实是模块装配！\n\n\n\n@SpringBootConfiguration\n@ComponentScan 扫描注解，将有注解的bean加入到IOC容器。\n\n## 把握Spring的几个重要目的，提升学习效率\n\nOCP ---> IOC\n\nIOC的实现：容器  加入容器\t 注入\n\nIOC的目的：\n抽象意义：控制权交给用户\n灵活的OCP\n\n把对象注入到容器中去最主要的几种方式\n1. XML\n2. 注解\n\n## Stereotype Annotations 模式注解\n\n@Component   组件/类/bean 注入ioc容器\n\n@Service \n@Controller  \n@Repository\n这三个注解和Component没有区别，\n\n\n@Configuration\n可以一次加载多个bean进入容器。\n\n\n## Spring的实例化和依赖注入时机与延迟实例化 \n\n> IOC容器 对象 实例化 注入 时机\n\n默认立即/提前实例化\n可以设置 延迟实例化  通过@Lazy注解 \n\n> 注意，假如如果容器启动就会立即实例化A和B，但是我们想让B延迟加载，可以在B类上添加@Lazy，但A依赖B  B添加@Lazy注解，但是A没有添加，springboot会忽略B的延迟加载，也就是说如果想让B延迟加载，那么还需要在A上添加@Lazy注解\n\n## 成员变量注入、Setter注入与构造注入\n\n三种注入方式：\n1. 属性注入（最常用）\n2. 构造方法注入\n3. set方法注入\n\n```java\n@RestController\n@RequestMapping( \"/v1/banner\" )\npublic class BannerController {\n// 通过属性注入\n    @Autowired\n    private Diana diana;\n\n// 通过构造函数注入\n//    @Autowired\n//    public BannerController(Diana diana){\n//        this.diana = diana;\n//    }\n\n\n// 通过set方法注入\n//    @Autowired\n//    public void setDiana(Diana diana) {\n//        this.diana = diana;\n//    }\n\n    @RequestMapping( \"/test\" )\n    public String test() {\n        diana.r();\n        return \"hello,post,snow\";\n    }\n}\n\n```\n\n## Spring中一个接口多个实现类的处理\n\n### @Autowired被动注入方式\n1. byType\n\t当注入一个Skill类型的skill，他会先找实现了Skill接口的bean\n\t当找不到任何一个bean则报错\n\t当找到一个bean，直接注入\n\t当找到多个bean，并不一定会报错\n\n2. byName\n\t当byType的方式找到多个实现了Skill接口的bean时，就会启动byName的机制\n\t从而自动判断后，帮你注入你需要的bean\n\n### @Autowired主动注入方式\n看似注入的是Iralia，实则注入的是Daina，这就是主动注入方式\n```java\n@Autowired\n@Qualifier(\"Daina\")\nprivate Skill Iralia;\n```\n\n### 面向对象中变化的应对方案\n1. 制定一个接口，然后用多个实现类实现同一个interface   （策略模式，多个策略选择一个策略）\n2. 只有一个类，通过类的属性，来达到对应变化\n\n\n两个类同时实现Skill接口，在注入的时候，Spring如何知道，注入的到底是哪一个实例？\n```java\n@Component\npublic class Diana implements Skill{\n\n    public Diana(){\n        System.out.println(\"hello diana\");\n    }\n\n    public void q() {\n        System.out.println(\"Diana Q\");\n    }\n\n    public void w() {\n        System.out.println(\"Diana W\");\n    }\n\n    public void e() {\n        System.out.println(\"Diana E\");\n    }\n\n    public void r() {\n        System.out.println(\"Diana R\");\n    }\n}\n\n@Component\npublic class Iralia implements Skill{\n\n    public Iralia(){\n        System.out.println(\"hello Iralia\");\n    }\n\n    public void q() {\n        System.out.println(\"Iralia Q\");\n    }\n\n    public void w() {\n        System.out.println(\"Iralia W\");\n    }\n\n    public void e() {\n        System.out.println(\"Iralia E\");\n    }\n\n    public void r() {\n        System.out.println(\"Iralia R\");\n    }\n}\n\n\npublic interface Skill {\n\n    void q();\n    void w();\n    void e();\n    void r();\n\n}\n\n\n// 当注入一个Skill类型的diana，则会调用diana的r方法\n// 当注入一个Skill类型的iralia，则会调用iralia的r方法\n// 当然在真实的开发中，这种写法很少，因为都是面向接口编程，不可能依赖某一个具体的对象,也违反了OCP原则。\n\n// 当注入一个Skill类型的skill，他会先找实现了Skill接口的bean\n// 当找不到任何一个bean则报错\n// 当找到一个bean，直接注入\n// 当找到多个bean，并不一定会报错\n\n@RestController\n@RequestMapping( \"/v1/banner\" )\npublic class BannerController {\n\n    // @Autowired\n    // private Skill diana;\n\n    // @Autowired\n    // private Skill iralia;\n\n    @Autowired\n    private Skill skill;\n\n    @RequestMapping( \"/test\" )\n    public String test() {\n        // diana.r();\n        // iralia.r();\n        skill.r();\n        return \"hello,post,snow\";\n    }\n}\n```\n\n\n## @ComponentScan包扫描机制\n\nspringboot的@SpringbootApplication注解会默然扫描该类同包及子包下所有的注解\n如果需要扫描别的包，则需要用到@ComponentScan注解。\n@@ComponentScan(\"xxx.xxx.xxx\")\n\n## 策略模式的变化模式\n1. 通过切换byname 切换bean\n2. 通过@Qualifier 指定bean \n3. 有选择的注入一个bean，注释掉某个bean上的@Component注解\n4. @Primary 优先注入\n\n\n\n## 条件注解\n满足条件，才会将bean加入IOC容器，不满足则不会加入IOC容器中去\n\n@Conditional + Conditional(接口)   可以用来编写自定义条件注解\n\n```java\n\n@Configuration\npublic class HeroConfiguration {\n\n    @Bean\n    @Conditional(DianaCondition.class)\n    public Skill diana() {\n        return new Diana(\"戴安娜\", 20);\n    }\n\n    @Bean\n    @Conditional( IreliaCondition.class )\n    public Skill iralia() {\n        return new Iralia();\n    }\n}\n\n// 编写一个条件类，实现Condition接口，\npublic class DianaCondition implements Condition {\n\n\t// 重写方法，返回true则注入，返回false则不注入。\n    @Override\n    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {\n\n    \t// ....判断是否注入到容器的逻辑\n\n        return false;\n    }\n}\n\n\n```\n\n## SpringBoot内置的成品条件注解\n@ConditionalOnProperty\n\n```java\n\tyml  hero.condition = diana\n\n    @Bean\n    @ConditionalOnProperty(value = \"hero.condition\",havingValue = \"diana\")\n    public Skill diana() {\n        return new Diana(\"戴安娜\", 20);\n    }\n```\n\n\n## 增强型SpringBoot\n\n全局异常处理类\n@ControllerAdvice 标注该类为一个异常处理类\n@ExceptionHandler(value = Exception.class)   捕获所有Exception类型的异常会执行该注解下的方法。\n\n```java\n\n@ControllerAdvice\npublic class GlobalExceptionAdvice  {\n\n    @ExceptionHandler(value = Exception.class)\n    public void handleException(HttpServletRequest req, Exception e){\n        System.out.println(\"hello \");\n    }\n\n}\n\n\n```\n\n\n## 异常分类 \n\nThrowable\n\nError  系统级错误\n\nException  异常\n\tcheckedException  编译时异常，强制要求处理，比如try catch 或继续抛出异常、或记录日志、或返回到前端\n\tRuntimeException  运行时异常   unchecked\n\n异常可以处理时，定义为checkedException\n异常无能为力时，定义为RuntimeException\n\n\n### 已知异常&未知异常\n1. 已知异常：比如判断业务逻辑，知道为某个对象或数据为空时，主动抛出的异常\n\n2. 未知异常：对于前端开发者和用户、都是无意义的，服务端开发者代码逻辑有问题，只需要自己知道就好了。打印到控制台，或者保存到日志中去\n\n全局异常处理Demo\n```java\n// \npublic class HttpException extends RuntimeException {\n    protected Integer code;\n    protected Integer httpStatusCode=500;\n}\n\n// 继承自定义的HttpException\npublic class ForbiddenException extends HttpException {\n\n    public ForbiddenException(Integer code) {\n        this.code = code;\n        this.httpStatusCode = 403;\n    }\n}\n// 继承自定义的HttpException \npublic class NotFoundException extends HttpException {\n\n    public NotFoundException(Integer code) {\n        this.httpStatusCode = 404;\n        this.code = code;\n    }\n}\n\n// response对象，需要序列化到前端的\npublic class UnifyResponse {\n    private Integer code;\n    private String message;\n    private String request;\n\n    public UnifyResponse(Integer code, String message, String request) {\n        this.code = code;\n        this.message = message;\n        this.request = request;\n    }\n\n    get set 方法、\n}\n```\n\n```java\n\n@ControllerAdvice\npublic class GlobalExceptionAdvice  {\n    // 拦截所有Exception的异常\n    @ExceptionHandler(value = Exception.class)\n    @ResponseBody\n    @ResponseStatus(code = HttpStatus.INTERNAL_SERVER_ERROR)  // 状态码改为500.但是不够灵活，需要使用ResponseEntity\n    public UnifyResponse handleException(HttpServletRequest req, Exception e){\n        String requestUrl = req.getRequestURI();\n        String method = req.getMethod();\n        System.out.println(e);\n        UnifyResponse unifyResponse = new UnifyResponse(9999, \"服务器异常\", method + \"\" + requestUrl);\n        return unifyResponse;\n    }\n\n\n    // 拦截所有自定义的Http异常   可以灵活的设置异常的状态码\n    @ExceptionHandler( value = HttpException.class )\n    public ResponseEntity<UnifyResponse> handleHttpException(HttpServletRequest req, HttpException e) {\n        String requestUrl = req.getRequestURI();\n        String method = req.getMethod();\n        UnifyResponse unifyResponse = new UnifyResponse(e.getCode(), \"xxxxxx\", method + \"\" + requestUrl);\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpStatus httpStatus = HttpStatus.resolve(e.getHttpStatusCode());\n        ResponseEntity<UnifyResponse> responseEntity = new ResponseEntity<>(unifyResponse, headers, httpStatus);\n        return responseEntity;\n    }\n\n}\n```\n\n封装好这些异常处理之后，在处理业务逻辑的时候，只需要new不同自定义异常对象即可\n```java\n\n@RequestMapping( \"/test\" )\n    public String test() throws Exception {\n        skill.r();\n        throw new ForbiddenException(10001);\n    }\n```\n\n**开发细节优化：这些code码是传递给前端用于判断请求或业务是否执行成功的，有一点，如果我们将这些code以硬编码的形式传递返回给前端是没有任何问题的，但是，但是，如果后期要修改这些code，那么项目维护起来还是有点费劲的，又或者如果我们要做国际化，那是不可能的，最好的方式，还是将这些code的定义，单独写到配置文件中来管理。**\n\n```properties\nsnow.codes[10000]= 通用错误   #中文需要进一步处理，不然到前端会出现乱码，之后会继续解决这个问题\nsnow.codes[10001]= this is error   #英文就没有问题\n\n# 注意配置文件中不需要给属性加\"\"号，不然返回给前端的数据会变为转义后 `\\ this is error \\` 这种形式\n```\n```java\n@ConfigurationProperties( prefix = \"snow\" )   // 获取配置文件中前缀为snow的属性\n@PropertySource( value = \"classpath:config/exception-code.properties\" )  // 和自己定义的配置文件关联\n@Component //加入到IOC容器\npublic class ExceptionCodeConfiguration {\n\n    // 根据配置文件中的数据结构设置为map数据接口\n    // 数据格式    100001 = \"通用参数异常\"  10000=\"用户名不存在\" 就是 key-value格式的\n    private Map<Integer, String> codes = new HashMap<>();\n\n    public Map<Integer, String> getCodes() {\n        return codes;\n    }\n\n    public void setCodes(Map<Integer, String> codes) {\n        this.codes = codes;\n    }\n\n    // 根据传入的code值，获得message消息\n    public String getMessage(Integer code) {\n        String message = codes.get(code);\n        return message;\n    }\n}\n```\n\n```java\n// 硬编码形式\nUnifyResponse unifyResponse = new UnifyResponse(e.getCode(), \"xxxxxx\", method + \"\" + requestUrl);\n//配置文件动态获取 @Autowired ExceptionCodeConfiguration 这个对象\nUnifyResponse unifyResponse = new UnifyResponse(e.getCode(), codeConfiguration.getMessage(e.getCode()), method + \"\" + requestUrl);\n```\n\n思想总结：\n1. 配置文件和类对应起来，在代码中操作配置文件，就相当于在操作一个类，更加方便，要用类的思想去操作配置文件。\n2. 如果业务中配置项较多的时候，建议提取成一个配置文件。\n3. 异常处理不要定义涉及到业务的具体的异常(比如订单未找到、商品未找到等等..)，太麻烦，但也不能定义的太抽象，比如Http异常..尽量定义通用的异常,粒度自己把握。根据Http状态码定义自定义异常就比较好，因为Http的状态码是有限的 哈哈。 \n4. 异常处理流程\n    1. 需要抛出异常时，新建异常类，继承Expection，传入一个code码，表某一类异常，根据code码定义配置文件，对应的message\n    2. GlobleExcepttionAdvice中统一处理，自定义异常、系统异常\n    3. 建议自己处理返回给前端的状态码，不要用springboot的注解，因为不够灵活\n    4. ResponseEntity对象初始化，需要三个值\n        * unifyResponse(自定义返回的Response对象，httpStatus(状态码)、headers(响应头信息))\n","tags":["SpringBoot"],"categories":["SpringBoot"]},{"title":"React基础知识点-时常看看","url":"/2020/03/11/React基础知识点-时常看看/","content":"\n# React\n\n## React之绑定属性\n   \n&emsp; 主要注意着三点就好了，其余跟html基本类似。\n1. class属性要换成className\n2. 和label中的for要换成 htmlFor\n3. style如果写行内样式，因为是jsx语法要求传递的为一个对象，所以要用双花括号包裹，如下\n ```html\n<div className='title'>我是一个标题</div>\n\n<label htmlFor=\"name\">姓名</label>\n<input id=\"name\"  />\n\n<div style={{\"color\":'red'}}>我是一个div</div>\n ```\n<br/><br/>\n   \n## React中引入图片的三种方式\n1. 可以直接通过img的src属性引入远程图片url\n ```html\n  \t<img src=\"https://www.baidu.com/img/xxxxxxx_353asadasdsadsaa259394dea9b.png\" />\n ```\n2. 可以在组件内引入本地图片,之后用ES6语法引入 \n ```javascript\n \timport logo from '../assets/images/1.jpg';\n \t<img src={logo} />\n ```\n3. 或者直接用ES5的语法简写\n ```html\n\t<img src={require('../assets/images/1.jpg')} />\n ```\n<br/><br/>\n\n## React中循环数组数据渲染\n\n &emsp; 在需要循环渲染数据的地方直接调用数组的map方法即可，没有别的花样。注意要在加key属性。有时候返回的数组中还有数据，那么直接在里层在调用map函数就好了，内层数组直接用`item.数组名.map()`\n```html\nstate中的数据：list:['11111111111','222222222222','3333333333333']\n<ul>\n {\n \tthis.state.list.map(function(item,index){\n \t\treturn (<li key={index}>{value.title}</li>);\n\t})\n}\n</ul>\n\n最好不要用index作为key值。可以用数组中不唯一的，例如常用的id属性，像这样。\n<li key={value.id}>{value.title}</li>\n```\n<br/><br/>\n\n## React中改变this指向的三种方式\n&emsp; 一定要注意this的指向，在函数调用，组件传值中如果this指向不正确，很容易导致获取不到数据等系列bug。\n1. 直接在自己定义的事件处理的函数后添加.bind(this)\n```html\n\t<button onClick={this.getData.bind(this)}>获取数据--第一种改变this指向的方法</button>\n```\n2. 事件处理函数后面不用.bind(this),但需要在组件的构造函数内绑定。\n```html\n\t <button onClick={this.getMessage}>获取信息</button>\n```\n```javascript\nconstructor(props){\n  super(props);   //固定写法\n  this.state={\n   msg:'我是一个home组件', \n  }   \n  //第二种改变this指向的方法\n  this.getMessage= this.getMessage.bind(this);\n}\n\n```\n3. 直接使用箭头函数，这样就不需要在函数后.bind(this).也不需要造构造函数内些那么一堆重复代码。 （推荐）\n```html\n\t<button onClick={this.getData}>获取数据--第一种改变this指向的方法</button>\n```\n```javascript\n\nsetData=()=>{\n  ...\n}\n\n```\n<br/><br/>\n\n## React中给方法传递参数\n&emsp; 这里也要注意一下，要把当前组件this传递到方法中去，这样当你对当前组件中state里定义的数据做一些修改时，才能赋值成功，或者在调用的该方法中调用另一个方法时，才可以调用成功，不传递this的话，指向的不是当前组件，会出bug，张三为方法的第一个参数，李四为方法的第二个参数，多个参数以此类推，<font color=\"red\">this是一定要传递的</font>\n```html\n<button onClick={this.setName.bind(this,'张三','李四')}>执行方法传值</button>\n```\n<br/><br/>\n\n## React中获取表单数据\n&ensp;思路大概如下：\n1. 在表单元素上定义onchange()事件，来监听用户输入的值\n```html\n<input onChange={this.inputChange}/> <button onClick={this.getInput}>获取input的值</button>\n```\n2. 在onChange事件函数里面获取表单输入的值,即通过event对象来获取用户输入的值，然后将数据setState()保存到state中\n```javascript\ninputChange=(e)=>{\n   console.log(e.target.value);\n   this.setState({\n       username:e.target.value\n   })\n}\n```\n3. 数据已经保存到state中了，在需要的地方直接调用就好了。\n\n> 注意：如果你给input标签定义value属性，记得添加onChange事件,否则会报错。添加defaultValue，可以不用添加onChange事件   \n\n<br/><br/>\n\n## React中通过ref获取dom\n1. 给需要获取值的元素定义ref属性\n```html\n <input ref=\"username\" onChange={this.inputChange}/>\n```\n2.通过this.refs.username 获取dom节点\n```javascript\nlet val=this.refs.username.value;   //这样直接就可以获取到input元素的value值\n\ninputChange=()=>{\n this.setState({\n   username:val\n })\n}\n```\n\n<br/><br/>\n\n## React创建一个简单的可提交表单\n&emsp; 这个表单虽然很简单，但是越往后，我们用到ES6中的语法，对多个input框绑定同一个事件就可以一次性赋值等等，这些都是需要以这些为基础的，我因为不是主要做前端，有时候可能会忘记这些什么事件定义啊，setData是阿之类的，看是看到这些基础代码，就会想起来。\n```javascript\nimport React, { Component } from 'react';\n\nclass ReactForm extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            msg: \"react表单\",\n            name: '',\n            sex: '1',\n            city: '',\n            citys: [\n                '北京', '上海', '深圳'\n            ],\n            hobby: [\n                {\n                    'title': \"睡觉\",\n                    'checked': true\n                },\n                {\n                    'title': \"吃饭\",\n                    'checked': false\n                },\n                {\n                    'title': \"敲代码\",\n                    'checked': true\n                }\n            ],\n            info: ''\n        };\n        this.handleInfo = this.handleInfo.bind(this);\n    }\n\n\n    handelSubmit = (e) => {\n        //防止页面因提交刷新，阻止submit的提交事件。\n        e.preventDefault();\n\t\t// 控制台打印提交数据\n        console.log(this.state.name, this.state.sex, this.state.city, this.state.hobby, this.state.info);\n    }\n\n\n    handelName = (e) => {\n        this.setState({\n            name: e.target.value\n        })\n    }\n\n    handelSex = (e) => {\n        this.setState({\n            sex: e.target.value\n        })\n    }\n\n    handelCity = (e) => {\n        this.setState({\n            city: e.target.value\n        })\n    }\n\n    handelHobby = (key) => {\n        var hobby = this.state.hobby;\n        hobby[key].checked = !hobby[key].checked;\n        this.setState({\n            hobby: hobby\n        })\n    }\n\n    handleInfo(e) {\n        this.setState({\n            info: e.target.value\n        })\n    }\n\n    render() {\n        return (\n            <div>\n                <h2>{this.state.msg}</h2>\n\n                <form onSubmit={this.handelSubmit}>\n                    用户名:<input type=\"text\" value={this.state.name} onChange={this.handelName} /><br />\n                    \n\t\t\t\t\t性别:<input type=\"radio\" value=\"1\" checked={this.state.sex == 1} onChange={this.handelSex} />男\n                         <input type=\"radio\" value=\"2\" checked={this.state.sex == 2} onChange={this.handelSex} />女<br />\n                 \n\t\t\t\t 居住城市:<select value={this.state.city} onChange={this.handelCity}>\n                        {\n                            this.state.citys.map(function (value, key) {\n                                return <option key={key}>{value}</option>\n                            })\n                        }\n                    </select>\n                    <br /><br />\n                 \n\t\t\t\t 爱好:\n                    {\n                        // 注意this指向\n                        this.state.hobby.map((value, key) => {\n                            return (\n                                <span key={key}>\n                                    <input type=\"checkbox\" checked={value.checked} onChange={this.handelHobby.bind(this, key)} /> {value.title}\n                                </span>\n                            )\n                        })\n                    }\n                    <br />\n                  备注：<textarea vlaue={this.state.info} onChange={this.handleInfo} />\n                    <input type=\"submit\" defaultValue=\"提交\" /><br />\n                </form>\n            </div>\n        );\n    }\n}\nexport default ReactForm;\n```\n\n<br/><br/>\n\n## React中巧妙获取多个input框的值\n&emsp;看了上面的表单，你是否觉得这有多少个表单元素，就需要定义多少个onchange函数来监听他的改变，之后都是调用setState中，改变state里的数据，如果input框的数量少也还好说，假如有100个Input框呢？那我们不得写100次... 所以我们可以采取以下的方式，来巧妙的解决这个问题,直接上代码了。\n\n```javascript\nimport React, { Component } from 'react';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: '',\n      deion: '',\n    };\n  }\n\n  handleChange = name => event => {\n\t//  [name]表示一个可变的参数，也就是你handleChange()中传递的参数。\n\t//  你传递的是name，就将event.target.value赋值给name\n\t//  你传递的是deion，就将event.target.value赋值给name\n    this.setState({ [name]: event.target.value });\n    console.log(this.state.name,)\n    console.log(this.state.deion)\n  }\n\n  render() {\n    return (\n      <div>\n        <input onChange={this.handleChange('name')} />\n        <input onChange={this.handleChange('deion')} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n当然也有人写成这种方式，其实也是一个意思，也贴上来吧。\n```javascript\nimport React, { Component } from 'react';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: '',\n      deion: '',\n    };\n  }\n\n   onInputChange(e){  \n        let inputValue  = e.target.value,\n            inputName   = e.target.name;\n        this.setState({\n            [inputName] : inputValue\n        });\n    }\n\n  render() {\n    return (\n      <div>\n        <input name=\"username\" onChange={this.handleChange()} />\n        <input name=\"password\" onChange={this.handleChange()} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n<br/><br/>\n\n## React中localStorage的使用\n&emsp;既然提到了localStorage，就简单讲讲吧。\n1. 什么是localStorage\n> 在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。\n   \n\n2. localStorage的优势\n> 1. localStorage拓展了cookie的4K限制\n> 2. localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却只有在高版本的浏览器中才支持的   \n   \n\n3. localStorage的局限\n> 1. 浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性\n> 2. 目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换\n> 3. localStorage在浏览器的隐私模式下面是不可读取的\n> 4. localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n> 5. localStorage不能被爬虫抓取到\n   \n\n4. localStorage与sessionStorage的区别\n> 唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空\n\n一般像用户登录，就可以将用户的数据保存到localStorage中，还有比如实现todolist功能，你新增一个待办事项等都会用到localStorage存储数据。防止页面刷新，需要重新设置数据，或者重新发送http请求获取数据等。在react中使用也没什么好说的，两个几个函数注意一下。这代码是对localStorage的简单封装，模块化，方便在组件里写业务的时候调用。\n\n```js\nvar storage={\n    // 将数据保存进缓存(注意，必须将数据序列化为JSON字符串)\n    set(key,value){\n        localStorage.setItem(key,JSON.stringify(value));\n    },\n    // 取出本地缓存（注意，取出本地缓存中的数据时，需要将json字符串转换成对象类型）\n    get(key){\n        return JSON.parse(localStorage.getItem(key));\n    },\n    // 移除本地缓存。\n    remove(key){\n        localStorage.removeItem(key)\n    }\n};\nexport default storage;\n```\n<br/>\n<br/>\n<br/>\n\n## React中父子组件传值\n&emsp; **什么叫父子组件：组件的相互调用中，我们把调用者称为父组件，被调用者称为子组件。**   \n\n###  父组件给子组件传值   \n   \n1. 父组件在引用子组件的时候定义一个属性\n2. 子组件里面可以通过 `this.props.name` 获取到父组件传递过来的值。  \n   \n```javascript\nimport React, { Component, } from 'react';\nimport Children from '../children'\n//父组件\nclass Parent extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n\n    render() {\n        return (\n            <Children name='jack'></Children>\n        );\n    }\n}\nexport default Parent;\n```\n\n```javascript\nimport React, { Component } from 'react';\n//子组件\nclass Children extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n\n    render() {\n        return (\n            <h4>{this.props.name}</h4>\n        );\n    }\n}\nexport default Children;\n```\n### 父组给子组件传递方法   \n   \n1. 父组件调用子组件的时候将方法定义在子组件上      \n2. 子组件通过this.props.run接收\n   \n\n```javascript\nimport React, { Component, } from 'react';\nimport Children from '../children'\n// 父组件\nclass Parent extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n\n    run=()=>{\n       alert('我是parent组件的run方法');\n    }\n\n    render() {\n        return (\n            // 将run方法传递给子组件， parentFn自定义叫啥都行，子组件接收以你自定义的属性名为准\n            <Children parentFn={this.run}></Children>\n        );\n    }\n}\nexport default Parent;\n```\n\n```javascript\nimport React, { Component } from 'react';\n// 子组件\nclass Children extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n\n    render() {\n        return (\n            // 获取父组件传递的run方法。\n            <button onClick={this.props.parentFn}>点击执行parent的run方法</button>\n        );\n    }\n}\nexport default Children;\n```\n\n### 将整个父组件传递给子组件\n1. 父组件调用子组件的时候将this(父组件自己)定义在子组件上 \n2. 子组件还是通过`this.props`来调用\n\n```javascript\nimport React, { Component, } from 'react';\nimport Children from '../children'\n\nclass Parent extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            msg:'我是父组件'\n        };\n    }\n\n    run=()=>{\n       alert('我是parent组件的run方法');\n    }\n\n    render() {\n        return (\n            //parent组件引用Children组件，将parent组件中的run方法传递给子组件。\n            <Children parent={this}></Children>\n        );\n    }\n}\nexport default Parent;\n```\n```javascript\nimport React, { Component } from 'react';\n\nclass Children extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n\n    render() {\n        return (\n            <div>\n                {/* 因为将整个父组件传递过来了，所以子组件用props既可以接收方法，也可以接受参数。 */}\n                <button onClick={this.props.parent.run}>点击执行parent的run方法</button>\n                <h1>  {this.props.parent.state.msg}  </h1>\n            </div>\n        );\n    }\n}\nexport default Children;\n```\n\n### 父组件调用子组件的数据和方法\n1. 父组件调用子组件时定义`ref`属性\n2. 在父组件内通过`this.refs.`来获取子组件的数据或者方法\n\n```javascript\nimport React, { Component } from 'react';\n\nclass Children extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            hero: '寒冰射手'\n        };\n    }\n\n    childrenFn(){\n        alert(\"我是子组件方法\")\n    }\n    \n    render() {\n        return (\n            <h1>我是子组件</h1>\n        );\n    }\n}\n\nexport default Children;\n```\n\n```javascript\nimport React, { Component, } from 'react';\nimport Children from '../children';\n\nclass Parent extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n          \n        };\n    }\n\n    getChildren = (result) => {\n        // 父组件获取子组件里的数据\n        alert(this.refs.children.state.hero);\n        // 父组件调用子组件里的方法\n        this.refs.children.childrenFn();\n    }\n\n    render() {\n        return (\n           \n            <div>\n\t\t{/* 引用子组件时定义ref属性*/}\n                <Children ref='children'></Children>\n                <button onClick={this.getChildren}>点击获取children的数据和方法</button>\n            </div>\n        );\n    }\n}\n\nexport default Parent;\n\n```\n\n### 子组件主动向父组件传递数据\n1. 先在父组件内定义一个获取子组件数据的方法，供子组件调用。\n2. 在子组件调用父组件的方法即可，需要什么参数，在.bind(this, param1,param2...)即可\n3. 注意：父组件在接收参数时，时默认从param1开始的。并不会将this作为第一个参数。详细请看代码。\n```js\nimport React, { Component, } from 'react';\nimport Children from '../children';\n\nclass Parent extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n\n        };\n    }\n    \n    // 定义一个获取子组件数据的方法，供子组件调用。\n    getChildrenData = (result) => {\n        console.log(result)   //  接收到子组件传递过来的 \"盖伦\"\n    }\n\n    render() {\n        return (\n            <div>\n                {/* 可以为子组件传递整个父组件*/}\n            \t<Children parent={this}></Children>\n\t\t{/* 也可以为子组件传递一个方法 */}\n                <Children getChildrenData={this.getChildrenData}></Children>\n            </div>\n\n        );\n    }\n}\n\nexport default Parent;\n```\n\n```javascript\nimport React, { Component } from 'react';\n\nclass Children extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n\n        };\n    }\n\n    render() {\n        return (\n            <div>\n                {/* 先获取父组件，在调用父组件的getChildrenData方法，传递数据给父组件 */}\n            \t<button onClick={this.props.parent.getChildrenData.bind(this,\"盖伦\")}>发送数据给父组件</button>\n\t\t\t\t{/* 直接调用父组件的getChildrenData方法，传递数据给父组件 */}\n                <button onClick={this.props.getChildrenData.bind(this,\"盖伦\")}>发送数据给父组件</button>\n            </div>\n        );\n    }\n}\n\nexport default Children;\n```\n<br/><br/>\n\n\n## React中的生命周期函数\n### 什么是声明生命周期函数？\n> 生命周期函数是组件在某一个时刻会自动执行的函数，总共有8个如下：\n```js\n1. componentWillMount();\n2. render() \n3. componentDidMount()\n4. shouldComponentUpdate()\n5. componentWillUpdate()\n6. componentDidUpdate()\n7. componentWillReceiveProps()\n8. componentWillUnmount()\n```\n **一: 挂载阶段 (Mounting) 执行的生命周期函数：**\n> 1. UNSAFE_componentWillMount() == componentWillMount() 组件将要挂载阶段自动执行\n> 2. render() 渲染页面内容时自动执行\n> 3. componentDidMount() 组件挂载完成自动执行\n> 4. 页面第一次加载的时候生命周期函数的执行顺序...![avatar](/images/生命周期函数1.png)\n\n\n**二: 更新阶段 (updation) 执行的生命周期函数：**props更新和states更新会执行的生命周期函数\n> 1. shouldComponentUpdate()  数据需要更新吗？需要返回true或false\n> 2. UNSAFE_componentWillUpdate()  == componentWillUpdate()  更新将要更新\n> 3. componentDidUpdate()  更新完成时执行\n> 4.执行顺序如下![avatar](/images/生命周期函数2.png)\n       \n\n **三: 其他几个声明周期函数**\n> 1. componentWillReceiveProps()  只有子组件才有这个生命周期函数,当子组件接收到父组件传递的新的数据props会执行。\n> 2. componentWillUnmount() 组件将要被移除的时候执行的函数\n\n<br/><br/>\n\n## React中的defaultProps和PropTypes\n> 1. defaultProps:父子组件传值中，如果父组件调用子组件的时候不给子组件传值，可以在子组件中使用defaultProps定义的默认值\n> 2. propTypes：验证父组件传递给子组件的类型合法性\n```javascript\nclass Children extends Component {\n    constructor(props) {\n        super(props);\n        this.state = { \n           \n        };\n    }\n    render() {\n        return (\n            <div>\n                // 父组件如果没有传递title给Children,则会调用defaultProps中的默认值'标题'\n                // 父组件如果传递了num属性过来，则会在propTypes中校验是否为num类型\n                <h2>---{this.props.title}--- {this.props.num}</h2>\n            </div>\n        );\n    }\n}\n//defaultProps如果父组件调用子组件的时候不给子组件传值，可以在子组件中使用defaultProps定义的默认值\nChildren.defaultProps={\n    title:'标题'\n}\n//同行propTypes定义父组件给子组件传值的类型\nHeader.propTypes={\n    num:PropTypes.number\n}\nexport default Children;\n```\n<br/><br/>\n\n## React获取服务器APi接口的数据\nreact中没有提供专门的请求数据的模块，但是我们可以使用任何第三方请求数据模块实现请求数据，使用很简单，官方文档介绍都比较详细，这里就不贴演示代码了。\n> 1. 使用[axios](https://github.com/axios/axios)\n> 2. 使用[fetch-jsonp](https://github.com/camsong/fetch-jsonp)\n\n## React路由\n### React路由的配置\n> 1. 找到官方文档 https://reacttraining.com/react-router/web/example/bas1. \n> 2. 安装  yarn add  react-router-dom\n> 3. 找到项目的根组件引入 import { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\n> 4. 复制官网文档根组件里面的内容进行修改  （加载的组件要提前引入）\n### React动态路由传值取值\n1. 动态路由配置\n```js\n<Route path=\"/content/:aid\" component={Content} />\n```\n2. 对应的动态路由加载的组件里面获取传值 `this.props.match.params`\n\n3. 常用到动态路由的场景：\n&emsp;首页点击某个商品，获取对应的商品详情 思路：\n> 1. 在首页定义跳转的url路径，并携带商品的id         `<Link to = 'product/:${item.id}'>`\n> 2. 在详情页面解析url，并获取到传递到详情页面的id，  `this.props.match.id`\n> 3. 根据id的不同动态的发送不同的请求获取商品详情数据, `axios.get(\"http://xxxxx/xxxx/\"+id)`\n> 4. 将获取到的数据保存到变量中                     ` setState({})`\n> 5. 在页面渲染数据。                              `render()`\n\n### React中路由的嵌套\n> &emsp;在很多项目中，通常有一个通用的模板样式，比如头部菜单栏固定，底部公司信息固定，左边子菜单固定，只是某一个主要显示的内容区域根据你选择的功能模块不同，渲染出不同的页面信息，这就需要用到动态路由。常见的管理系统。用户管理、个人中心、等等。你点击那个页面，就跳转到那个页面。\n\n> `this.props.match.url`可以直接匹配上一级的路由\n\n> 比如商品下有商品列表和商品添加，就可以如下配置，在主页引入shop组件，shop组件里引入shopList和shopAdd组件。\n```javascript\n<Route exact path={`${this.props.match.url}/`} component={ShopList} />  //后面加个`/`相当于默认加载shopList页面。\n<Route  path={`${this.props.match.url}/add`} component={ShopAdd} />\n```\n### React路由模块化\n\n> 参考[react-router-dom](https://reacttraining.com/react-router/web/example/route-config)的模块化功能\n> 我自己的理解，路由模块化其实解决的也就是路由抽取、路由封装，统一管理的管理。\n\n> 我们想一下，如果按照普通的路由配置，根组件配置路由规则，每就要多增加一个功能模块，对应就要多增加一条Route规则，最基础的路由是如下配置的吧！如果项目小，这样配置是没有问题的，可如果项目规模较大，这样配置，后期肯定是不好维护的。\n```js\nimport React, { Component } from 'react';\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nimport Home from './components/Home';\nimport User from './components/User';\nimport Shop from './components/Shop';\n\nclass App extends Component {\n\n  render() {\n    return (\n      <Router>\n        <div>\n          <header className=\"title\">\n            <Link to=\"/\">首页组件</Link>\n            <Link to=\"/user\">用户页面</Link>\n            <Link to=\"/shop\">商户</Link>\n          </header>\n          \n          <Route exact path=\"/\" component={Home} />\n          <Route path=\"/user\" component={User} />\n          <Route path=\"/shop\" component={Shop} />\n        </div>\n      </Router>\n    );\n  }\n}\nexport default App;\n\n```\n\n> 模块化后，相当于将路由的规则定义在了一个`routes`数组里，专门来存放你的路由。在`rander()`函数中去循环routes里的数据，这样你是不是就不用再改下面的代码了，直接在上面先引入组件，然后在`routes`中配置一下数据就好了。\n\n```js\nimport React, { Component } from 'react';\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\n\nimport Home from './components/Home';\nimport User from './components/User';\nimport Shop from './components/Shop';\nimport News from './components/News';\n\n\nlet routes = [\n  {\n    path: \"/\",          //路由跳转路径\n    component: Home,    //需要加载的组件\n    exact:true          //知否精准匹配\n  },\n  {\n    path: \"/shop\",\n    component: Shop\n  },\n  {\n    path: \"/user\",\n    component: User\n  },\n  {\n    path: \"/news\",\n    component: News\n  }\n];\n\nclass App extends Component {\n\n  render() {\n    return (\n\n      <Router>\n        <div>\n            <header className=\"title\">\n                <Link to=\"/\">首页组件</Link>\n                <Link to=\"/user\">用户页面</Link>\n                <Link to=\"/shop\">商户</Link>\n                <Link to=\"/news\">新闻</Link>\n            </header> \n            {\n              routes.map((route,key)=>{\n                  //如果上面定义的exact为true则按如下加载配置路由\n                  if(route.exact){\n                    return <Route key={key} exact path={route.path} component={route.component}/>\n                  }else{\n                  //如果没设置精准匹配，这样加载。\n                    return <Route  key={key}  path={route.path} component={route.component}/>\n                  }\n              })\n            }                \n        </div>\n      </Router>\n    );\n  }\n}\n\nexport default App;\n\n```\n\n> 上面的这种方式也并不是真正的模块化，真正的模块化是将路由定义在一个单独文件当中形成一个模块。如下，我们可以一个`router.js`的路由配置文件。然后`export`出去，供外部使用，如下，在看我们的`App`根组件代码是不是清爽了很多，全部都交由`router.js`去实现了，这不就是封装、模块化的概念。\n\n```js\n// router.js\n\nimport Home from '../components/Home';\nimport User from '../components/User';\nimport Shop from '../components/Shop';\nimport News from '../components/News';\n\nlet routes = [\n    {\n      path: \"/\",\n      component: Home,\n      exact:true\n    },\n    {\n      path: \"/shop\",\n      component: Shop\n    },\n    {\n      path: \"/user\",\n      component: User\n    },\n    {\n      path: \"/news\",\n      component: News\n    }\n];\nexport default routes;\n```\n\n\n```js\n//  App.js\n\n\nimport React, { Component } from 'react';\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nimport routes from './model/router.js'; //引入我们定义好的router模块。\n\nclass App extends Component {\n\n  render() {\n    return (\n\n      <Router>\n        <div>\n            <header className=\"title\">\n                <Link to=\"/\">首页组件</Link>\n                <Link to=\"/user\">用户页面</Link>\n                <Link to=\"/shop\">商户</Link>\n                <Link to=\"/news\">新闻</Link>\n            </header> \n            {\n              routes.map((route,key)=>{\n                  if(route.exact){\n                    return <Route key={key} exact path={route.path} component={route.component}/>\n                  }else{\n                    return <Route  key={key}  path={route.path} component={route.component}/>\n                  }\n              })\n            }                 \n        </div>\n      </Router>\n    );\n  }\n}\nexport default App;\n```\n\n> 最后说一下`模块化嵌套路由`，比如User组件下有UserAdd和UserList，我们来看一下如何模块化配置吧，具体原理，可以简单理解为，把父组件的路由当做React中的父组件，子路由当做子组件，父组件如何给子组件传值？ 是不是在引入子组件的地方定义好属性，子组件通过props来接收？对的，在模块化嵌套路由中，也是这种思路实现的，只不过写法得照react-route-dom这样规定的写。\n\n\n```js\n// router.js\n\nimport Home from '../components/Home';\nimport User from '../components/User';\n    import UserList from '../components/User/UserList';\n    import UserAdd from '../components/User/UserAdd';\n    import UserEdit from '../components/User/UserEdit';\nimport Shop from '../components/Shop';\nimport News from '../components/News';\n\n\nlet routes = [\n    {\n      path: \"/\",\n      component: Home,\n      exact:true\n    },\n    {\n      path: \"/shop\",\n      component: Shop\n    },\n    {\n      path: \"/user\",\n      component: User,  \n      routes:[   /*嵌套路由,你的子路由，就要在User下在定义一个routes数组*/\n        {\n          path: \"/user/\",\n          component: UserList\n        },\n        {\n          path: \"/user/add\",\n          component: UserAdd\n        },\n        {\n          path: \"/user/edit\",\n          component: UserEdit\n        }\n      ]\n    },\n    {\n      path: \"/news\",\n      component: News\n    }\n];\nexport default routes;\n```\n\n```js\n// App.js\n\nimport React, { Component } from 'react';\n\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nimport routes from './model/router.js';\n\nclass App extends Component {\n\n  render() {\n    return (\n\n      <Router>\n        <div>\n            <header className=\"title\">\n                <Link to=\"/\">首页组件</Link>\n                <Link to=\"/user\">用户页面</Link>\n                <Link to=\"/shop\">商户</Link>\n                <Link to=\"/news\">新闻</Link>\n            </header> \n\n            {\n              routes.map((route,key)=>{\n                  if(route.exact){\n                    return <Route key={key} exact path={route.path}                     \n                    render={props => (\n                        // route.component是一级路由，routes是嵌套路由\n                      <route.component {...props} routes={route.routes} />\n                    )}\n                    />\n                  }else{\n                    return <Route  key={key}  path={route.path} \n                    render={props => (\n                      <route.component {...props} routes={route.routes} />\n                    )}\n                    />\n                  }\n              })\n            }            \n        </div>\n      </Router>\n    );\n  }\n}\nexport default App;\n```\n\n还有一些关于react的知识，后续再整理吧... \n关与React我觉得GitHub这篇写的总结还比较好。有兴趣可以看看   --->    [GitHub地址](https://github.com/bailicangdu/react-pxq)","tags":["React"],"categories":["React"]},{"title":"CSS技巧总结","url":"/2020/03/04/CSS技巧总结/","content":"# CSS技巧总结\n\n## CSS控制缩略缺省显示...\n比如有些时候，因为文字太长，影响了页面的样式，可以使用如下的css样式。\n```java\nwidth: 150rpx; \t\t\t// 因为设置了overflow：hidden属性，控制显示长度，不设置的话，无法出现...省略的效果，\ntext-align: center;\t\t// 文字居中显示\noverflow: hidden; \t\t// 必要\nwhite-space: nowrap; \t\t// 必要 控制不换行\ntext-overflow: ellipsis;\t// 必要 控制省略部分以...结束\n```\n小程序拓展：Lin-UI有对WXS的支持，可以直接这样使用\n\n```html\n// 先引入wxs\n<wxs src=\"../../miniprogram_npm/lin-ui/filter/string.wxs\" module=\"strWxs\"></wxs>\t\n\n// 然后在需要的地方写上一小段表达式，这样就不需要去写Css啦。\n<text class=\"spu-text\">\n  {{item.title.length>8 ? strWxs.substring(item.title,0,7)+\"...\" : item.title}}\n</text>\n\n```","tags":["css"]},{"title":"SKU和SPU","url":"/2020/03/02/SKU和SPU/","content":"\n# SKU和SPU到底是个啥？\n\n* SKU(stock keeping unit):库存量单位\n* SPU(standard product unit):标准化产品单元\n\n**帮你去记忆，SKU和SPU的区别就是一个K，一个P的区别！**\n英文和我一样记不住这么长单词的这么理解吧，K(库存)，P(product)所以SKU就是和库存相关的一个概念。   \n\n\n## SKU\n装逼一点的说法，就是库存量单位。   \n\n用人话讲就是你上网买东西，是不是要先确定买什么商品？选好商品后再来机型、再选自己喜欢的颜色、配置、尺寸等等等，等选好后你发现，你要的这个颜色的机型没货了.....   \n\n话说到这里大家应该知道什么是SKU了吗？其实就是电商重通过商品不同的属性，来计算库存，同一件商品搭配不同的属性，就会有很多很多种组合，这些组合，称之为SKU。一台mac有灰色、白色、这就是两个SKU。 对照下图自己脑补... 有多少种组合就有多少个SKU。可以找些女装商品去试试...数清楚有多少种组合了，你就彻底知道什么叫SKU了。\n![avatar](/images/sku.png)  \n\n\n## SPU\n装逼一点的说法，就是标准化产品单元\n\n用人话讲，就是商品，只是这个商品加了一个标准化，还是用刚刚的例子，比如你要去买一个手机，你能确定是买苹果，还是买华为？华为Mate10、华为Mate20、iphone100 plus、iphone250 plus、这些都叫标准化产品，即华为、苹果是一个品牌，加上具体的机型，就是一个SPU，你不能说华为手机就是一个SPU，而是要加上确切的型号，组合成一个SPU，你上网买手机，你选的iphone100plus，人给你发个iphone5你乐意吗？不都是苹果手机吗？（杠精别说话...）不乐意吧。所以一个商品加上标准的型号，就可以称之为一个SPU，而加上颜色，内存大小、送手机壳、送充电器、等等这些又可以组合成多个SKU。了解了吗？\n![avatar](/images/spu.png)  \n\n总结：\n\tSKU，确定库存、多重组合\n\tSPU，单个商品，具体型号，组成一个单品。","tags":["sku spu"]},{"title":"组件设计原则","url":"/2020/02/29/组件设计原则/","content":"\n# 组件设计原则总结   \n\n## 你必须在组件的灵活性和易用性/稳定之间做出一个选择，找到一个平衡点\n> 越是灵活的组件，易用性就越差，简单说就是复杂性越高；而越是简单的组件，灵活性和定制型就不够。\n\n## 组件的意义是什么？\n> 组件从三方面：样式、骨架、业务逻辑/行为 上对代码进行封装，方便我们在日后重用/复用样式，骨架和业务逻辑。\n\n## 组件必须要提供给用户的几个特点和方法\n> 组件必须允许用户通过某种方式对组件进行`自定义`,不能自定义的组件或者说自定义程度很弱的组件不是一个好的组件设计。`自定义`性通常包括：\n> 1. 对样式的自定义\n> 2. 对骨架的自定义\n> 3. 对业务逻辑的自定义\n\n> 从现有的技术来讲，对于以上的自定义性来讲，微信小程序有以下几个方式来支持自定义。\n> 1. 外部样式类（样式自定义）\n> 2. Slot插槽（骨架自定义）\n> 3. 业务逻辑(Behaior行为)\n\n> 但是业务逻辑自定义也会面临两个问题\n> 1. Behaior依旧繁琐\n> 2. 组件的业务逻辑自定义从某种程度来讲，是伪命题\n\n> 为什么是伪命题？因为组件A之所以是组件A，而不是组件B，正是由于他自己独特的业务逻辑，如果业务逻辑改变了，那么组件A可能就不应该是组件A，所以组件对于业务逻辑的自定义性是有待探讨的。\n\n#### 怎么样设计通用的组件呢？\n试想一下我们如果需要使用第三方UI框架，每一个样式都需要你去定义，会不会就失去了使用UI框架的意义，为什么要去用UI框架，无非就是为了方便，不用重复造轮子，直接用现成的就好。\n\n那如果针对我们自己的项目，需要自定义组件的时候，怎么根据第三方库设计出更加灵活通用的组件呢？\n1. 设计出合理的默认值，样式默认值，插槽默认值。\n2. 能不固定元素高和宽，就不要将高和宽写死。\n\n\n\n待总结.....","tags":["UI框架"]},{"title":"Semver","url":"/2020/02/27/什么是semver/","content":"\n# Semver 语义化版本   \n<br>\n&emsp;今天学习小程序的时候听到这个技术名词，上网查了一下，做个总结，方便查阅。\n\n## Semver 简介\n&emsp;semver 是[<font color=blue>语义化版本</font>](https://semver.org/lang/zh-CN/)（Semantic Versioning）规范的一个实现，目前是由npm的团队维护，实现了版本和版本范围的解析、计算、比较。\n \n## semver 的两个概念\n* 固定版本：是指例如 0.4.1、1.2.7、1.2.4-beta.0 这样表示包的特定版本的字符串。\n* 范围版本：是对满足特定规则的版本的一种表示，例如 1.2.3-2.3.4、1.x、^0.2、>1.4.\n\n## 版本号格式\n&emsp; 主版本号[MAJOR].次版本号[MINOR].修订号[PATCH]，版本号递增规则如下:\n1. 主版本号：当你做了不兼容的 API 修改。\n2. 次版本号：当你做了向下兼容的功能性新增，可以理解为Feature版本。\n3. 修订号：当你做了向下兼容的问题修正，可以理解为Bug fix版本。\n\n## 先行版本号 (Pre-release Version)\n&emsp; 先行版本号可以作为发布正式版之前的版本，格式是在修订版本号后面加上一个连接号（-），再加上一连串以点（.）分割的标识符，标识符可以由英文、数字和连接号（[0-9A-Za-z-]）组成。example：\n```javascript\n1.0​​.0-alpha   内部版本\n1.0.0-alpha.1 公测版本\n1.0.1-rc      正式版本的候选版本(Release candiate)\n1.0.0-0.3.7\n1.0.0-x.7.z.92\n```\n## 版本发布准则\n1. 标准的版本号必须采用XYZ的格式，并且X、Y 和 Z 为非负的整数，禁止在数字前方补零，版本发布需要严格递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n2. 某个软件版本发行后，任何修改都必须以新版本发行。\n3. 1.0.0 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的API时，就可以发布1.0.0版本了。\n4. 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。\n\n## npm包依赖\n&emsp; 当执行npm install package -S 来安装三方包时，npm 会首先安装包的最新版本，然后将包名及版本号写入到 package.json 文件中。\n\n比如，通过npm 安装 react 时：\n```json\n{\n  \"dependencies\": {\n    \"react\": \"~16.2.0\"\n  }\n}\n```\n&emsp; 项目对包的依赖可以使用下面的 3 种方法来表示(假设当前版本号是 16.2.0):\n* 兼容模块新发布的补丁版本：~16.2.0、16.2.x、16.2\n* 兼容模块新发布的小版本、补丁版本：^16.2.0、16.x、16\n* 兼容模块新发布的大版本、小版本、补丁版本：*、x\n\n## npm包发布\n&emsp; 通常我们发布一个包到npm仓库时，我们的做法是先修改 package.json 为某个版本，然后执行 npm publish 命令。手动修改版本号的做法建立在你对Semver规范特别熟悉的基础之上，否则可能会造成版本混乱。npm 考虑到了这点，它提供了相关的命令来让我们更好的遵从Semver规范：\n* 升级补丁版本号：npm version patch\n* 升级小版本号：npm version minor\n* 升级大版本号：npm version major\n\n> 当执行 npm publish 时，会首先将当前版本发布到 npm registry，然后更新 dist-tags.latest 的值为新版本。\n> 当执行 npm publish --tag=next 时，会首先将当前版本发布到 npm registry，并且更新 dist-tags.next 的值为新版本。这里的 next 可以是任意有意义的命名（比如：v1.x、v2.x 等等）\n> OK，现在你应该知道 npm install package@next时next代表的含义了吧  \n\n\n<br><br>\n\n原作者地址：https://segmentfault.com/a/1190000014405355 、 https://www.jianshu.com/p/a7490344044f\n","tags":["semver"],"categories":["开发小知识"]},{"title":"微信小程序开发","url":"/2020/02/24/微信小程序开发/","content":"\n## 微信小程序\n\n### wxecce373e86f54d1e\n\n### 891c8c73ae3e3b6c7992ecc7161d6e38","tags":["小程序"]},{"title":"常用命令大全","url":"/2020/02/06/常用命令大全/","content":"\n# Nginx命令\n```\n说明:Nginx命令需要在nginx.exe文件所在位置运行。\n\nstart nginx  启动\nnginx -s reload 重启\nnginx -s stop   nginx停止\n```\n<font color=red size=2>Nginx命令结束</font>\n\n---\n\n# Linux命令\n\n## cd命令集\n```\ncd命令是linux中最基本的命令语句，必须熟练掌握\n\ncd /        返回根目录\ncd ~        用户主目录\ncd .        当前目录\ncd ..       返回到上一级目录\ncd /usr/    进入到usr目录\ncd –        返回上一个目录\ncd          直接回家\n```\n\n## ls目录和文件\n```\nls –l       详细格式，文件权限，时间\nll          和ls –l作用相同\nls *.txt    查看所有的txt类型文档\n```\n\n\n## 目录操作\n```\nmkdir 创建目录\nmkdir a 创建 a目录\nmkdir -p a/b 创建 a目录，并在a目录里创建b目录\nmkdir -m 777 c 创建一个权限为777的C目录\nrmdir  删除目录（如果目录里有文件，则不能用此命令）\n```\n\n\n\n\n## vi创建/查看/编辑文件\n```\n命令行：Esc切换到命令行模式。\n编辑模式：\n按i，在光标前开始编辑\n按a，在光标后开始编辑\n按o，在当前行的下一行开始编辑\n底行模式：按  shift+：冒号。\n:q! 不保存退出\n:wq 保存退出\n:/world 从当前光标处，向上查找world关键字\n:?world 从当前光标处，向后查找world关键字\n```\n## 删除文件\n```\nrm 删除文件\nrm n.txt 提示y删除n放弃\nrm –f n.txt 不提示\nrm –rf dirname 不提示递归删除目录下所以内容\nrm –rf * 删除所有文件\nrm –rf /* 删除所有子目录所有和文件\n```\n## 复制和移动文件\n\n```\ncp复制文件\n\ncp nginx.conf n.txt\ncp –R tomcat1 tomcat2      #复制整个目录\nmv  修改文件名，移动文件\nmv  n.txt m.txt\n```\n## 浏览文件\n```\ncat                 输出文件所有的内容\nmore                输出文档所有的内容，分页输出，空格浏览下一屏，q退出\nless                用法和more相同，只是通过PgUp、PgOn键来控制\ntail                用于显示文件后几号，使用频繁\ntail -10 nginx.conf 查看nginx.conf的最后10行\ntail –f nginx.conf  动态查看日志，方便查看日志新增的信息\nctrl+c              结束查看\n```\n## 打包命令\n```\ntar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成name.tar.gz的文件。\n-c 创建一个新的tar文件\n-v 显示运行过程的信息\n-f 指定文件名\n-z 调用gzip压缩命令进行压缩\n-t 查看压缩文件的内容\n-x 解开tar文件\ntar –cvf n.tar ./*      压缩当前目录下的所有文件和目录，文件名为n.tar\ntar –xvf n.tar          解压压缩包中的文件到当前目录（如果长时间未解压成功 Ctrl+C推出）\ntar –cvzf m.tar ./*     解压m.tar文件到当前目录\n```\n## grep命令\n```\ngrep root  /etc/passwd                  在文件中查找关键字root\ngrep root  /etc/passwd  –-color         高亮显示\ngrep root  /etc/passwd  –A5 –B5         高亮显示，A后5行，B前5行\ngrep -n root /etc/passwd                查找并显示行数\ngrep -v root /etc/passwd                 取反，查出不含root的数据\n```\n##  Linux防火墙\n```\nservice iptables stop       临时关闭\nservice iptables start      临时开启\nchkconfig iptables on       永久开启\nchkconfig iptables off      永久关闭\n```\n## 查看安装版本及卸载mysql\n```\nrpm -qa|grep -i mysql \n```\n\n## linux下查看mysql安装版本及卸载mysql\n```\nrpm -qa|grep -i mysql \n```\n\n<font color=red size=2>linux命令结束</font>\n\n---\n\n# Redis命令\n## Redis解压安装指令\n```\nmake            解压完之后需要mke编译redis\nMake install    编译完之后需要Make install 安装redis\n```\n## Redis基本命令\n```\nredis-server redis.conf   启动命令:  \nredis-cli -p 端口         进入客户端: \nexit                      退出客户端 \n```\n## 编辑redis.conf\n> 1. 注释IP绑定   61行附近\n> 2. 关闭保护模式  80行附近\n> 3. 开启后台启动 128行附近\n\n<font color=red size=2>Redis命令结束</font>\n\n---\n\n# Mysql命令\n## 启动Mysql\n```\nservice mysql start   启动命令\nservice mysql stop    停止命令\nservice mysql restart 重启命令\n```\n## 开放Mysql对外权限\n```\ngrant [权限] on [数据库名].[表名] to ['用户名']@['web服务器的ip地址'] identified by ['密码'];\n\ngrant all on *.* to 'root'@'%' identified by 'root';\n\t\n或者指定IP地址\ngrant all on *.* to 'root'@'192.168.1.103' identified by 'root';\n```\n\n## 配置主库配置文件\n```说明:主库的二进制文件默认的是关闭的.需要手动开启日志文件\n编辑文件:\n\tvim /etc/my.cnf\n```\n\n\n## 搭建数据库主从的命令及步骤\n### 查看主库状态(操作的是主库)\n```\nSHOW MASTER STATUS;\n```\n\n### 设置从库连接主库IP地址/端口/二进制文件 (操作的是从库)\n```\nCHANGE MASTER TO MASTER_HOST=\"192.168.186.132\",\nMASTER_PORT=3306,\nMASTER_USER=\"root\",\nMASTER_PASSWORD=\"root\",\nMASTER_LOG_FILE=\"mysql-bin.000001\",\nMASTER_LOG_POS=120\n```\n### 开启主从服务(操作的是从库)\n```\nSTART SLAVE;\n```\n###  查看主从同步状态(操作的是从库)\n```\nSHOW SLAVE STATUS;成功数据表中会显示两个yes\n```\n### 如果报错了可以断开,重新执行上面的操作\n```\nstop slave  关闭主从服务 \n```\n\n## amoeba\n```\n./launcher  启动命令   \n\n如果搭建一主多从需要直接克隆 需要进入/var/lib/mysql/ 更改auto的server-uuid  序列号。\n```\n\n<font color=red size=2>mysql命令结束</font>\n\n---\n\n# Mycat命令\n```\n\t./mycat start       启动\n\t./mycat stop        停止\n\t./mycat restart     重启\n\t./mycat status      检测状态\n\t./mycat dump        临时存储\n```\n<font color=red size=2 >mycat命令结束</font>\n\n\n   \n\n---  \n\n\n\n","tags":["常用命令"],"categories":["常用命令"]},{"title":"SSO单点登录","url":"/2020/02/06/SSO单点登录/","content":"# 单点登录\n## 没有单点登录存在的问题\n> 在分布式项目中，我们通常会使用Nginx来分发客户请求，从而更好缓解请求对服务器的压力。通过Nginx做负载均衡后，用户的每次请求都会发往不同的服务器。如果采用Session保存用户信息，则可能导致用户登陆多次，这样友好性差。  \n\n> 如何解决这个问题呢？ 我们可以使用单点登录这个技术。实现单点登录的方式有很多，这里只说下利用redis实现单点登录。\n\n## 实现SSO方式-Redis\n> 1. 用户进行登录操作时，输入用户名和密码.\n> 2. JT-WEB服务器接收用户请求时.利用httpClient技术，将用户信息发送给JT-SSO单点登录系统.\n> 3. JT-SSO单点登录系统接收前台数据之后进行校验.如果用户名和密码不正确，直接提示返回。如果用户名和密码正确，首先生成加密的秘钥token，之后将user转化为JSON数据，保存到Redis中，之后将token数据返回给JT-WEB服务器.\n> 4. JT-WEB接收JT-SSO单点登录系统的返回值数据.如果用户名密码不正确则友好提示给用户.\n> 5. 如果用户名和密码正确，将token数据保存到用户浏览器的Cookie中。\n\n![avatar](/images/sso.png)\n\n# 单点登录流程: \n> 1. 发送用户请求， 用户将用户名及密码发送至前台服务器 \n> 2. 前台服务器利用httpClent向后台SSO服务器发起请求，后台SSO服务器会对用户信息进行校验， \n> 3. SSO服务器接收前台数据后进行校验，如果用户名密码不正确，直接提示返回， \n> 4. 如果正确生成秘钥并将user转化为JSON数据，保存到token中，将token返回给前台服务器. \n> 5. 前台服务器接收SSO的返回值数据没如果用户名密码不正确则友好提示用户 \n> 6. 如果用户名密码正确，将token数据保存到用户浏览器的Cookie中\n> 7. 任何一台服务器都能访问Redis，通过redis通过token， 缓存有数据，放行， 缓存没有重新登录\n\n> 为什么存在Cookie中 ， 如果客户第二次发起请求，首先前台会判断用户是否登录，因为Cookie中，任何一个前台服务器都能接受用户请求，并且能获取到Cookie信息，拿到Cookie就能拿到最重要的Token数据。","tags":["SSO单点登录"],"categories":["JavaWeb"]},{"title":"Redis基础知识","url":"/2020/02/06/Redis基础知识/","content":"\n# Redis\n## Redis官方简介\n> Redis是一个开源（BSD许可），采用key-value结构进行数据存储，用作数据库，缓存和消息队列。它支持数据结构，如字符串，散列，列表，集合，带有范围查询的排序集，位图，超级日志，具有半径查询和流的地理空间索引。Redis具有内置复制，Lua脚本，LRU算法，事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用性并使用Redis Cluster自动分区。\n\n## 人话版什么是Redis\n> 1. Redis就是一个数据库软件，作用是存储数据的。\n> 2. Redis是一个开源的，基于K-V进行存储的内存型数据库，可以用作数据库，缓存，和消息队列。\n> 3. Redis是一个Nosql（没有sql）非关系型数据库。\n> 4. Redis读写效率高，平均每秒10万读写。\n> 5. Redis支持丰富的数据类型String、Hash 、LIST 、Set 、SortedSet 有序集合。\n> 6. Redis中操作可以添加事务的支持。\n\n##\t应用的一些场景\n> 比如京东前端页面，基本上都是查询的操作，涉及到删除，更新，添加的操作，用户一般涉及不到后端管理这一块的操作，所以我们只需要吧这些常用的查询数据存储到NoSQL数据库中，客户端可以直接请求NoSQL数据库，如果NoSQL数据库中没有用户需要的数据，就会到关系型数据库中去查找，如果查询到，就会将关系型数据库中的数据，在添加到NoSQL数据库，从而提升性能。\n\n## Redis 持久化策略 RDB模式和AOF模式\n### 什么是RDB模式\nRDB模式是通过保存数据库中的键值对来记录数据库的状态 ，每隔一段时间就会将数据写入(Snapshot)快照， 恢复时在将快照文件直接读到内存里。\n>优点:\n> 1. RDB备份效率是最高的.  \n> 2. RDB是一个非常紧凑(compact)的文件，它保存了redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。\n> 3. 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。\n> 4. RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。\n> 5. 持久化文件大小可以控制.  \n\n>缺点:\n> 1. RDB方式数据没办法做到实时持久化/秒级持久化。如果需要持久化 ， 我们可以手动执行save或者BGsave命令 ， 频繁执行成本过高.\n> 2. RDB文件使用特定二进制格式保存，Redis版本迭代过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题\n> 3. 数据过于集中，所有数据都存储到一个文件中 ，一定时间内做一次备份，如果redis意外挂掉的话，就会丢失最后一次快照后的所有修改(数据有丢失)\n> 4. Redis作为数据库或者或者队列时不要使用RDB模式.  \n\n### 什么是AOF模式\n AOF 是通过保存Redis服务器所执行的写命令来记录数据库状态， (set，sadd，lpush 三个命令保存到 AOF 文件中)。\n>优点:\n> 1. 监听Redis的日志文件，监听如果发现执行了修改，删除，新增命令，立即根据这条命令把数据持久化，\n> 2. AOF持久化方法提供多种的同步频率，默认是每秒同步一次 ， 可以保证数据的准确性. \n\n>缺点:\n> 1. 对于具有相同数据的的 Redis，AOF 文件通常会比 RDF 文件体积更大。\n> 2. 虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。\n> 3. AOF只是每次将执行命令追加到AOF文件中，RDB是用快照的形式来持久化整个Redis数据，理论上来讲，RDB模式比AOF模式更加健壮，并且AOF好像有一些BUG  \n\n> AOF如何恢复数据:   重启 Redis 之后就会进行 AOF 文件的载入。异常修复命令：redis-check-aof --fix 进行修复\n\n### AOF 和 RDB 两种持久化方式，我们应该如何选择呢？\n> 如果可以接受小时间内的数据丢失，使用RDB肯定是最好的选择，定时生成快照，便于数据库备份.并且RDB模式恢复数据集的速度比AOF模式恢复的速度要快，RDB还可以避免AOF一些隐藏的BUG.否则就用AOF重写.一般情况下不建议单独使用某一种持久化机制，应该两者结合使用.\n\n\n## Redis的回收策略（淘汰策略）\n> 1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰  \n> 2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰  \n> 3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰  \n> 4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰  \n> 5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 \n> 6. no-enviction（驱逐）：禁止驱逐数据\n\n\n## Redis-主从复制\n> 在不设置主从复制的情况下，我们对数据的操作都是在一台Redis服务器上进行操作的，也就是说读和写以及备份操作都是在一台Redis服务器上进行的，那么随着项目访问量的增加，对Redis服务器的操作也越加频繁，虽然Redis读写速度都很快，但是一定程度上也会造成一定的延时，那么为了解决访问量大的问题，通常会采取的一种方式是主从架构Master/Slave，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机Slave 节点。\n\n\n## Redis分片技术(主要实现扩容)\n> * 思考：单台redis中使用的内存大小有限，默认的内存的大小为10M，如果使用时内存不足，如何处理?\n> * 解决：采用分片方式 ， 准备多台redis.实现内存扩容.\n> * Redis分片的缺点:\n> 1. 安全性不好，用户可以利用客户端直接set操作，修改数据。\n> 2. 由于单调性的要求，节点只能增，不能减，如果redis节点宕机，整合服务不能运行. 分片没有实现高可用。\n\n### Hash一致性\n>\t角色: node(节点)   key \n>\t内存:  node*n 实现内存扩容.\n![avatar](/images/redishash.png)\n\n\n### 均衡性\n> 说明:尽可能的让节点均匀的保存数据.\n> 问题:如果没有均衡性算法，则会导致数据负载不均.\n> 解决方法:引入虚拟节点的概念.通过虚拟节点动态的平衡数据.\n![avatar](/images/均衡性.png)\n\n\n### 单调性\n>说明:当节点新增时，节点信息会动态的划分，实现数据的挂载. \n>原则:如果节点新增时，尽肯能的保证原有的数据保持不变!只平衡部分数据.\n>单调性中描述节点只能新增，不能减少，如果节点个数少了.则内存缺失.分片不能使用.\n\n\n\n## Redis-哨兵机制总结(主要实现高可用)\n> 1. 前提:数据必须同步，搭建redis主从.\n> 2. 哨兵只会监听主机的状态，通过心跳机制进行检测 ping-pong。\n> 3. 当哨兵发现主机3次都没有响应时，这时认为主机宕机.内部进行推选。\n> 4. 当哨兵通过读取主机的配置文件，发现当前的主机中有2个从机.所以哨兵推选一台从机当做现在的主节点。\n> 5. 当哨兵成功推选了从机当主节点时.哨兵会修改另外节点的配置文件.重新定义主从结构。\n\n> 基于Redis主从复制这一机制，存在一个问题，因为主节点Master只有一个，一旦主节点挂掉之后，从节点没法担起主节点的任务，那么整个也无法运行。如果主节点挂掉之后，从节点能够自动变成主节点，那么问题就解决了，于是哨兵模式诞生了。哨兵模式就是不定时的用过心跳检测机制，对redis进行监控，若一台主机出现问题时，哨兵会自动将该主机下的某一个从机设置为新的主，、，并让其他从机和新主机建立主从关系。(内部是用的投票机制)\n\n> PS：哨兵模式也存在单点故障问题，如果哨兵机器挂了，那么就无法进行监控了，解决办法是哨兵也建立集群，Redis哨兵模式是支持集群的。\n\n\n## Redis集群搭建\n>### 为什么要搭建Redis集群?\n> 分析: Redis分片主要的功能实现redis内存扩容，哨兵主要实现了redis的高可用，而使用redis集群实现分片和哨兵的全部的功能。\n\t\t\n> ### 脑裂现象 : \n    > 由于在集群/推选机制中，长时间出现平票的结果.则容易出现脑裂的现象.从而导致整个推选机制出现问题(脑袋炸裂)\n    > 如何降低此现象的发生 : 增加主节点的数量!!  主节点的数量一般大于等于7\n\n> ### Redis集群高可用推选原理\n> 1. redis所有的节点都会保存redis集群中的全部主从状态信息，\n> 2. 子节点之间可以互相通信，如果某个节点宕机，则其他节点会通过ping-pang检测机制检查该节点是否宕机。\n> 3. 如果有一半的节点认为宕机，则认为主节点宕机，剩余的节点会进行推选，投票推选出链接主节点的从机，实现故障的迁移。\n\n\n\n##\t缓存三大问题\n### 1. 缓存穿透\n> * 条件:访问一个不存在的数据\n> * 说明:当访问一个不存在的数据时，因为缓存中没有这个key，导致缓存形同虚设.最终访问后台数据库.但是数据库中没有该数据所以返回null.\n> * 隐患:如果有人恶意频繁查询一个不存在的数据，可能会导致数据库负载高导致宕机。\n> * 总结:业务系统访问一个不存在的数据，称之为缓存穿透。\n\n### 2. 缓存击穿\n> * 条件:当缓存key失效/过期/未命中时，高并发访问该key。\n> * 说明:如果给一个key设定了失效时间，当key失效时有一万的并发请求访问这个key，这时缓存失效，所有的请求都会访问后台数据库.称之为缓击穿。\n> * 场景:微博热点消息访问量很大，如果该缓存失效则会直接访问后台数据库，导致数据库负载过高。  \n\n### 3. 缓存雪崩\n> * 前提:高并发访问，缓存命中较低或者失效时。\n> * 说明:假设缓存都设定了失效时间，在同一时间内缓存大量失效，如果这时用户高并发访问，缓存命中率过低，导致全部的用户访问都会访问后台真实的数据库.\n> * 场景:在高并发条件下，缓存动态更新时。","tags":["基础知识","redis"],"categories":["Redis基础知识"]},{"title":"Mysql数据库高可用","url":"/2020/02/06/Mysql数据库高可用/","content":"\n\n# 数据库备份策略\n\n## 冷备份策略\n> 说明：定期将数据库文件进行转储.\n> 缺点：\n> &emsp;1.数据库冷备份，则需要手动的人工完成.效率低\n> &emsp;2.定期数据备份，不能保证数据的安全的.仅仅能够恢复部分数据\n> &emsp;3.如果数据量比较庞大，导入导出时耗费的时间较多\n> &emsp;4.由于网络传输问题.可能会导致备份多次  \n> 优点：数据库冷备份是恢复数据最后有效的手段.\n\n\n## 热备份策略\n> 说明： 当主数据库数据进行\"更新\"操作时，数据会自动的同步到slave(从数据库中)该操作可以实现数据实时备份。  \n![avatar](/images/databasecopy.jpg)\n\n## 数据备份原理\n> 1. 当数据库主库发生数据改变时，会将改变的数据写入二进制日志文件中(主库)。\n> 2. 从库中会启动IO线程会实时的监控主库的二进制文件是否发生改变.如果主库的二进制改变了，则将改变的数据进行读取.读取之后，将二进制内容写入中继日志中。\n> 3. 从库会启动Sql线程.会读取中继日志中的消息，将它写入数据库中，最终实现数据同步。\n\n\n## 数据库双机热备\n>   根据数据库主从的配置.当主数据库做更新操作时，从库复制备份数据.当主库宕机时，通过某些技术手段可以数据库的高可用，实现故障迁移.当用户再有写入操作时，应该将数据写入从库中.如果主库修复完成重启数据库时，主库发现从库的数据较多.则数据库备份将失效.最终导致数据不一致的问题.\n\n### 双机热备意义\n> 说明：实现数据库双机热备是实现高可用的前提，如果数据不同步则无法实现数据库高可用.一般公司都有自己的运维团队.所以负责java开发的程序员不需要手动的配置数据库主从.但是需要了解mysql数据备份策略.为以后转岗做准备。\n\n\n\n\n## 数据库读写分离\n### Amoeba\n> #### 什么是amoeba?\n> Amoeba是一个以MySQL为底层数据存储，并对应用提供MySQL协议接口的proxy。它集中地响应应用的请求，依据用户事先设置的规则，将SQL请求发送到特定的数据库上执行。基于此可以实现负载均衡、读写分离、高可用性等需求。与MySQL官方的MySQL Proxy相比，作者强调的是amoeba配置的方便（基于XML的配置文件，用SQLJEP语法书写规则，比基于lua脚本的MySQL Proxy简单）。\n\n>Amoeba相当于一个SQL请求的路由器，目的是为负载均衡、读写分离、高可用性提供机制，而不是完全实现它们。用户需要结合使用MySQL的 Replication等机制来实现副本同步等功能。amoeba对底层数据库连接管理和路由实现也采用了可插拨的机制，第三方可以开发更高级的策略类来替代作者的实现。这个程序总体上比较符合KISS原则的思想。\n\n> amoeba作用：<font color=red>可以实现数据库的读写操作分离，高可用。 (数据库分库分表中间件)</font>  \n> &nbsp; 需求分析： 如果所有的访问压力都访问一台mysql服务器.如果遇到高并发问题可能导致数据库服务器宕机影响整个服务.\n> &nbsp; 解决方案： 使用读写分离策略.提高数据库的执行效率，当用户有更新操作时，访问主数据库.当用户有读操作时访问从数据库.同时从数据库可以有多台.并且主从实现数据同步.实现读和写分离.高升数据库性能.\n![avatar](/images/amoeba.png)\n\n\n\n### Mycat\n> #### 什么是Mycat\n> 官网copy了一份：\n> 1. 一个彻底开源的，面向企业应用开发的大数据库集群\n> 2. 支持事务、ACID、可以替代MySQL的加强版数据库\n> 3. 一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群\n> 4. 一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server\n> 5. 结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品\n> 6. 一个新颖的数据库中间件产品  \n\n> Mycat作用：<font color=red>能满足数据库数据大量存储， 提高了查询性能 (数据库分库分表中间件)</font>  \n\n![avatar](/images/mycat.png)\n> Mycat工作原理说明：\n> 1. 后台服务器需要将数据入库时通过mycat代理服务器操作数据库.\n> 2. 如果是更新操作.则将数据发往主数据库，如果是读操作则将数据发送给从数据库或者空闲的主数据库.\n> 3. 当主数据库发生宕机后，Mycat内部有心跳检测机制.判断主库宕机后，实现故障迁移.将所有的写库操作发往第二台主库.也就是从机.\n> 4. 当运维人员修复主库后.Mycat还会将写操作发往主库.从而实现数据库高可用.\n\n\n#### 垂直拆分和水平拆分\n> 业务需求： 当公司的业务积累到一定量，数据库和数据表都有大量的数据，无论从运维/查询角度而言效率都很慢，这就是通常所说的数据库瓶颈问题。 \n> <font color=red>那么如何解决这一问题呢？ 核心思想：将大量的数据分别保存到不同的数据库和数据表中</font>。\n\n#### 数据拆分概念引入\n> ##### 垂直拆分：  \n> 特点：根据不同的业务，将数据表拆分到不同的数据库中.\n> 规定：如果有业务关联，则尽可能拆分到一个数据库中.  \n> ##### 水平拆分： \n> 特点：  按照数据量进行拆分，将一个表中的数据分别保存到不同的数据表中，分散存储  \n\n#### 使用Mycat实现数据库 1.高可用性 2.读写分离 3.负载均衡\n> ##### 数据库垂直拆分  \n\n> &nbsp;根据功能模块(业务)将一个数据库中的表，拆分为多个数据库.降低了数据库中的数据量.提高数据库效率\n> * 优点：将数据表根据功能存放到不同的数据库中，可以提高数据库的性能。\n> * 拆分策略：将具有关联意义的数据表尽可能保存到同一个数据库中.否则关联查询时不能正确关联.因为在不同的数据库中。  \n\n> ##### 数据表水平拆分  \n\n> &nbsp;由于单表数据表的量很大，造成了数据库查询的瓶颈.所以需要将数据表中的数据拆分到多个数据库中.降低单表的数据量。\n> * 数据存取问题：由于使用数据库水平拆分，那么数据库中的数据应该按照什么规则存取呢?\n> * 问题解决：Mycat对于数据水平拆分，指定了很多策略.课上介绍一种根据Id取模运算.\n> * 原理说明：当信息入库时根据Id%分库数量=值.这个值就是数据存储的位置.同样当用户读取数据库时，也会取模快速定位数据库中的表.快速获取数据，如下图。\n![avatar](/images/拆分策略.png)\n\n\n\n# 数据库优化策略(重点知识)\n> 1. 优化sql语句(多表操作)  where 左连接 右连接 内连接 原则:尽可能根据主键查询,尽可能少用关联查询.\n> 2. 创建索引(对经常查询的数据创建索引)\n> 3. 添加缓存(Redis/MemCache)\n> 4. 定期进行数据转储(将一些查询较少的数据保存到历史表,让当前表维护可控的数据量)\n> 5. 分库分表(需要大量的数据库服务器)\n\n","tags":["基础知识","mysql"],"categories":["数据库基础知识"]},{"title":"数据库Mysql基础知识","url":"/2020/02/06/数据库Mysql基础知识/","content":"# 数据库概述\n## 什么是数据库\n> 数据库：英文为Database，简称DB，数据库是按照数据结构来组织、存储和管理数据的仓库，简而言之，数据库就是存储数据的仓库。\n\n## 数据库的分类\n> 数据库根据存储采用的数据结构的不同可以分为许多种，其中包含早期的层次式数据库、网络式数据库。\n> 目前占市场主流的是关系型数据库。当然还有非关系(NoSQL)型数据库（键值对数据库，例如：MongoDB、Redis）等其他类型的数据库\n\n## 什么是关系型数据库？\n> 底层是以二维表的及其之间的关系所组成的数据库，即是关系型数据库。例如：\n\n## 常见的关系型数据库\n> SQL Server      微软提供（收费、Java中使用不多）\n> Oracle            甲骨文公司（收费、功能强大、性能优异，Java中使用者很多）\n> DB2                IBM（收费、中型/大型、银行/电信等企业）\n> MySQL           瑞典MySQL AB（免费开源、小型、性能也不差、适用于中小型项目、可集群）\n> SQLite            迷你数据库，嵌入式设备中\n> ...\n## MySQL建库、建表\n> 查看数据库、查看数据表：show databases；\n```sql\n    show databases;\n```\n> 进入数据库：\n```sql\n    use 数据库名；\n```\n> 查看当前库中的所有表：show tables；\n```sql\n    show tables；\n```\n> 创建数据库、创建数据表\n> 创建数据库： \n```sql\n    drop database if exists 数据库名;\n```\n> 设置数据库编码：\n```sql\n    create database mydb1 charset utf8；\n```\n> 创建数据表：\n```sql\ndrop table if exists 表名;\n\ncreate table stu(\n    id int,                -- 学生编号\n    name varchar(20),    -- 学生姓名\n    gender char(1),    -- 学生性别\n    birthday date,        -- 出生年月\n    score double        -- 考试成绩\n        );\n```\n\n## MySQL数据类型及\n### 数值类型：\n> MySQL中支持多种整型，其实很大程度上是相同的，只是存储值的大小范围不同而已。\n> 1. tinyint：   占用1个字节，相对于java中的byte\n> 2. smallint： 占用2个字节，相对于java中的short\n> 3. int：          占用4个字节，相对于java中的int\n> 4. bigint：    占用8个字节，相对于java中的long ，其次是浮点类型即：float和double类型\n> 5. float：      占用4个字节，单精度浮点类型，相对于java中的float\n> 6. double：    占用8个字节，双精度浮点类型，相对于java中的double\n\n### 字符串类型\n> 1. char(n)  定长字符串，最长255个字符。n表示字符数，所谓的定长，是当插入的值长度小于指定的长度10（上面指定的）时, 剩余的空间会用空格填充。（这样会浪费空间）\n> 2. varchar(n)变长字符串，最长不超过 65535个字节，n表示字符数，一般超过255个字节，会使用text类型。所谓的不定长，是当插入的值长度小于指定的长度10（上面指定的）时, 剩余的空间可以留给别的数据使用。（节省空间）\n> 3. 大文本（长文本）类型，最长65535个字节，一般超过255个字符列的会使用text。text也分多种，其中bigtext存储数据的长度约为4GB。\n \n### 总结： \n> &emsp; char、varchar、text都可以表示字符串类型，其区别在于：\n> 1. char在保存数 据时, 如果存入的字符串长度小于指定的长度n,后面会用空格补全。 \n> 2. varchar和text保存数据时, 按数据的真实长度存储, 剩余的空间可以留给别的数据用.\n> 3. char会造成空间浪费(不足指定长度的会用空格补全), 但是由于不需要计算数据的长度, 因此速度更快。（即以空间换时间）\n> 4. varchar和text是节省了空间，但是存储的速度不如char快，因为要计算数据的实际长度。（即以时间换空间）\n\n### 日期类型\n> 1. date：年月日    time：时分秒     datetime：年月日 时分秒    \n> 2. timestamp：时间戳(实际存储的是一个时间毫秒值)，与datetime存储日期格式相同。\n> 3. timestamp最大表示2038年，而datetime范围是1000~9999\n> 4. timestamp在插入数、修改数据时，可以自动更新成系统当前时间(后面用到时再做讲解)\n\n## 字段约束\n> &emsp; 创建表时, 除了要给每个列指定对应的数据类型, 有时也需要给列添加约束。常见的约束有：主键约束、唯一约束、非空约束、外键约束。\n> 1. 主键(primary key)：主键是数据表中，一行记录的唯一标识。比如学生的编号，人的身份证号, 主键的特点：唯一且不能为空，当主键为数值时，为了方便维护，可以设置主键为自增 auto_increment              \n> 2. 唯一(unique)：保证所约束的列必须是唯一的，即不能重复出现，例如：用户注册时，保存的用户名不可以重复。唯一约束特点是不能重复(允许为空)\n> 3. 非空(not null) ：保证所约束的列必须是不为空的，即在插入记录时，该列必须要赋值，例如：用户注册时，保存的密码不能为空。非空约束的特点是：不能为空值，即插入数据时该列必须得有值。\n> 4. 外键约束：外键是用于表和表之间关系的列\n \n\n## SQL语言\n### 什么是SQL语言?\n> Structured Query Language：结构化的查询语言，SQL是操作所有关系型数据库的通用的语言\n\n###   SQL语言的分类：\n> 1. DDL -- 数据库定义语言，指CREATE、ALTER、DROP等操作（ 即创建、删除、修改数据库和数据表 ）\n> 2. DML -- 数据操作语言，指INSERT、UPDATE、DROP等操作（ 即数据表中数据的增、删、改操作 ）\n> 3. DQL  -- 数据查询语言（指SELECT操作，即数据表中数据的查询操作）\n \n\n### 更新表记录（insert/update/delete）\n#### insert--插入表记录\n> 格式: <font color=red>insert into 表名称 values (值1, 值2,....)</font>\n```sql\n    insert into emp  (字段1，字段2，)  values(值1, 值2...)\n```\n#### update修改表记录\n> 格式: <font color=red>update 表名称 set 列名称 = 新值 where 列名称 = 某值</font>\n```sql\n-- \n    update stu set score=score+10 where name='xxx';\n    select * from stu where name='xxx';\n    update stu set score=ifnull(score, 0)+10;\n    注意: null值和任何值计算结果还是null, 因此, 可以通过ifnull函数将null置为零对待.\n```\n\n#### delete删除表记录\n> 格式: <font color=red>delete from 表名称 where 列名称 = 值</font>\n```sql\n    delete from stu where name='xxx'; \n    delete from stu;    \n--若没有where子句, 则默认删除所有记录\n```\n\n#### select查询表记录\n> 格式: <font color=red>select 列名称 from 表名称</font>\n```sql\n    -- 查询emp表中的所有员工，显示员工姓名、薪资、奖金\n        select name,sal,bonus from emp;\n        select * from emp;\n        select distinct dept from emp;           \n        distinct  --关键字，用于剔除指定列中的重复值\n```\n\n#### where子句查询\n> 格式: <font color=red>select 列名称 from 表名称</font>\n```sql\n        -- 查询薪资大于300的姓名及工资大于3000的所有员工，显示员工姓名、薪资\n                select name,sal from emp where sal>3000; \n         \n        -- 查询emp表中总薪资(薪资+奖金)大于3500的所有员工，显示员工姓名、总薪资\n                select name, sal+bonus from emp where (sal+bonus)>3000; \n                select name, sal+bonus as 总薪资 from emp where (sal+bonus)>3000;\n        \n        --as用于定义别名(仅在查询的结果中作为列的表头显示)，也可以省略as\n        -- where子句中不能使用列别名（但是可以使用表别名）\n         \n        -- 查询emp表中薪资在3000和4500之间的员工，显示员工姓名和薪资\n                select name,sal from emp where sal between 3000 and 4500; \n         \n        -- 查询emp表中姓名中以\"刘\"开头的员工，显示员工姓名。\n                select name,sal from emp where name like '刘%';\n        \n        -- 查询emp表中姓名以\"刘\"开头，字数为两个字的员工，显示员工姓名。\n                select * from emp where name like '刘_';\n         \n        -- 查询emp表中姓名中包含\"涛\"字的员工，显示员工姓名。\n                select * from emp where name like '%涛%';\n                --提示：\"%\" 表示任意0或多个字符。\"_\" 表示任意一个字符\n         \n        -- 查询emp表中薪资为1400、1600、1800的员工，显示员工姓名和薪资\n                select name,sal from emp where sal in(1400,1600,1800);\n        \n        -- 查询emp表中薪资小于2000和薪资大于4000的员工，显示员工姓名、薪资。\n                select name,sal from emp where sal<2000 or sal >4000;\n         \n        -- 查询emp表中薪资大于3000并且奖金小于600的员工，显示姓名、薪资、奖金。\n                select name,sal,bonus from emp where sal>3000 and bonus<600; \n```\n#### 排序查询\n> 对查询的结果进行排序使用 order by关键字。\n> 1. order by 排序的列 asc    升序 ↑    \n> 2. order by 排序的列 dasc   降序 ↓\n```sql\n-- 对emp表中所有员工的薪资进行升序(从低到高)排序，显示姓名、薪资。\n            select name,sal from emp order by sal asc;\n     \n    -- 对emp表中所有员工的总薪资进行降序(从高到低)排序，显示姓名、总薪资。\n            select name, sal+bonus as 总薪资 from emp order by (sal+bonus) desc;\n\n    --分组查询：对所查询的记录可以根据某一列进行分组, 分组使用group by。\n\n    -- 将员工按照部门进行分组\n            select * from emp group by dept;\n     \n    -- 对emp表按照部门进行分组, 并统计每个部门的人数, 显示部门和对应人数\n            select dept 部门名称, count(*) 部门人数 from emp group by dept;\n     \n    -- 对emp表按照部门进行分组, 求每个部门的最高薪资(不包含奖金)\n            select max(sal) 总薪资 from emp group by dept;\n     \n    --注意：分组之前使用聚合函数表示对查询的所有记录进行统计计算,分组之后使用聚合函数表示对每一个组中的所有记录进行统计计算。\n```\n\n#### 聚合函数查询：\n> 1. max()或min() -- 某列的最大值或最小值，\n> 2. count() 某列的行数，\n> 3. sum() 某列值之和，\n> 4. avg() 某列的平均值\n```sql\n        -- 查询emp表中最高薪资\n                select max(sal) as 最高薪资 from emp;\n        -- 查询emp表中最高总薪资(薪资加奖金)\n                select max(sal+bonus) as 最高薪资 from emp;\n         \n        -- 统计emp表中薪资大于3000的员工人数\n                select count(*) from emp where sal>3000;\n         \n        -- 统计emp表中所有员工的总薪资(不包含奖金)\n                select sum(sal) as 员工总薪资 from emp;\n         \n        -- 统计emp表员工的平均薪资(不包含奖金)\n                select avg(sal) as 员工总薪资 from emp;\n         \n        -- 重要提示：可以使用count(*)统计记录行数，多个聚合函数可以一起查询。\n        -- 例如:根据部门进行分组，统计每个部门员工人数和平均薪资\n                select dept, count(*) 员工人数, avg(sal) 平均薪资 from emp group by dept; \n         \n        -- 聚合函数不能用在where子句中，在没有分组的情况下，聚合函数不能和其他普通字段一起查询\n        -- 错误的例如: 查询emp表中薪资最高的员工姓名。\n                select name, max(sal) from emp;--结果是错的\n        -- 正确的查询：\n                select name, sal from emp where sal=(select max(sal) from emp);-- \n```\n \n#### 数值函数：\n> 1. ceil(数值) -- 向上取整、\n> 2. floor(数值) -- 向下取整、\n> 3. round(数值) -- 向下取整\n> 4. rand(数值) -- 随机数\n``` sql\n--  查询emp表中所有员工薪资上涨15.47%, 向上取整。\n    select name,sal, ceil(sal*1.1547) from emp;\n```\n\n#### 日期函数\n> 1. curdate() -- 返回当前日期(年月日)\n> 2. curtime() -- 返回当前时间(时分秒)\n> 3. now() -- 返回当前日期+时间(年月日 时分秒)\n> 4. date_add()、date_sub() -- 增加/减少日期\n> 5. year()、month()、day()、hour()、minute()、second()，分别用来获取日期中的年、月、日、时、分、秒\n```sql\n        -- 查询系统当前时间。\n                select now();\n        -- 查询emp表中所有员工的年龄，显示姓名、年龄。\n                select name,year(curdate()) - year(birthday) 年龄 from emp;\n         \n        -- 查询emp表中所有在1993和1995年出生的，显示姓名、出生日期。\n                select name,birthday from emp where year(birthday) between 1993 and 1995;\n ```\n\n\n### 外键和表关系\n#### 外键：\n> 唯一标识其他表中的一条记录，用来通知数据库两张表列与列之间的对应关系, 并让数据库帮我们维护这样关系的键就叫做外键。  \n> 外键作用: 确保数据库数据的完整性和一致性，添加外键: 例如:foreign key(dept_id) references dept(id)  \n> 例如：员工表的部门id列（dept_id）和部门表的id列具有一 一对应的关系, 其中dept_id就是外键。\n\n#### 表关系：\n> 1. 一对多：一对多，反过来就是多对一，对于一对多的两张表，可以在多的一方添加列，保存一的一方的主键，从而保存两张表之间的关系\n> 2. 一对一：对于一对一关系的两张表，可以在任意一张表中添加列，保存另一张表的主键，从而保存两张表之间的关系\n> 3. 多对多：对于多对多的关系，可以拆分成两张一对多的关系，无法在两张表中添加列保存关系，但我们可以添加一张第三方的表,保存两张表的主键，从而保存两张表的关系。\n\n \n### 连接查询：将两张或者两张以上的表，按照指定条件查询，将结果显示在一张表中。\n> 多张表查询的语法：  <font color=red>Select 字段 from 表1,表2... where...</font>\n> 如果表名过长，可以为表添加别名以方便书写<font color=red>select... from A a, B b... where…</font>    \n```sql\n-- 查询部门和员工两张表\n    select * from dept,emp;   \n    ---上面查询的结果中存在大量错误的数据, 如果想正确显示部门及部门对应的员工，可以通过where子句从中筛选正确的数据.\n-- 查询部门和部门下的员工。\n    select * from dept d,emp e where d.id=e.dept_id;\n    select * from dept d inner join emp e on d.id=e.dept_id;          \n    --- (inner join...on...)方式也叫做内连接查询\n```\n\n### 外连接查询：\n> 左外连接查询，显示左侧表中的所有记录，如果在右侧表中没有对应的记录，则显示为null\n> 语法：<font color=red>select ...from a left join b on (a.id=b.xid)</font>\n \n```sql\n-- 查询所有部门和部门下的员工，如果部门下没有员工，显示null\nselect * from dept d left join emp e on d.id=e.dept_id;\n以上结果会显示（左侧表）所有部门，如果某部门下没有员工，（右侧表）则显示为null\n```\n\n### 右外连接查询：\n> 显示右侧表中的所有记录，如果在左侧表中没有对应的记录，则显示为null\n>语法：<font color=red>select 字段 from a right join b on (a.id=b.xid)</font>\n \n```sql\n-- 查询部门和所有员工，如果员工没有所属部门，显示null\nselect * from dept d right join emp e on d.id=e.dept_id;\n以上结果会显示（右侧表）所有员工，如果员工没有所属部门，（左侧表）则显示为null\n```\n\n\n \n### 子查询：\n> 其实就是将一个查询得出的结果，作为另外一个查询的条件。\n> 格式：<font color=red>select...from...where...(select...from...)</font>\n```sql\n---列出薪资比'xxx'高的所有员工，显示姓名、薪资      -- 先查询出'王海涛'的薪资\nselect name, sal from emp where sal>( select sal from emp where name='xxx');\n \n---列出与'刘沛霞'从事相同职位的所有员工，显示姓名、职位、部门。\nselect e.name, e.job, d.name from emp e, dept d where e.dept_id=d.id and job=(select job from emp where name='xxx');\n```\n\n### 多表查询\n\n```sql\n（左外连接）列出所有部门和部门下的员工，如果部门下没有员工, 显示为null。\nselect d.id, d.name, e.name, e.dept_id from dept d left join emp e on e.dept_id=d.id;\n\n--（关联查询）列出在'培优部'任职的员工，假定不知道'培优部'的部门编号。\nselect e.name, e.dept_id, d.id, d.name from emp e, dept d where e.dept_id=d.id;\n-- 再筛选过滤，查询部门名称为'培优部'的员工\nselect e.name, d.id, d.name from emp e, dept d where e.dept_id=d.id and d.name='培优部';\n \n（自连接查询）列出所有员工及其直接上级，显示员工姓名、上级编号，上级姓名\n-- 先查询员工表（emp e1）\nselect name, topid from emp e1;\n-- 再查询上级表（还是员工表，emp e2）\nselect id, name from emp e2;\n-- 最后查询员工及其员工的直接上级\nselect e1.name,e1.topid, e2.id, e2.name from emp e1, emp e2 where e1.topid = e2.id;  \n\n\n（分组、聚合函数）列出最低薪资大于1500的各种职位，显示职位和该职位最低薪资\n--先查询出各种职位的最低薪资\nselect job, min(sal) 最低薪资 from emp group by job;\n--提示：对分组后的记录筛选过滤请使用having替换where，并且having书写在最后\n--再查询出最低薪资>1500的职位\nselect job, min(sal) 最低薪资 from emp group by job having min(sal)>1500;  \n\n\n（分组、聚合函数查询）列出在每个部门就职的员工数量、平均工资。显示部门编号、员工数量，平均薪资。\nselect dept_id, count(*) 员工数量, avg(sal) 平均薪资 from emp group by dept_id;  \n\n \n（分组、关联、聚合函数查询）查出至少有一个员工的部门。显示部门编号、部门名称、部门位置、部门人数。\n--先关联查询, 查询出员工和员工对应的部门\nselect d.id, d.name, d.loc, e.name from emp e, dept d where e.dept_id=d.id;\n--再根据部门进行分组, 统计每个部门的员工数量\nselect d.id, d.name, d.loc, count(*) 员工数量 from emp e, dept d where e.dept_id=d.id group by e.dept_id;  \n\n \n（自连接查询）列出受雇日期早于直接上级的所有员工的编号、姓名、部门名称。\n-- 关联查询\nselect e1.id, e1.name, d.name from emp e1, emp e2, dept d where e1.dept_id=d.id and e1.topid=e2.id and e1.hdate < e2.hdate;  \n\n```\n\t\n","tags":["基础知识","mysql"],"categories":["数据库基础知识"]},{"title":"设计模式","url":"/2019/08/22/设计模式/","content":"\n# Java中的设计模式\n\n## 工厂模式\n工厂模式中包含三个子工厂模式、\n* 简单工厂模式\n* 抽象工厂模式\n* 工厂方法模式\n\n### 简单工厂模式\n简单工厂模式是属于`创建型`模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。   \n\n用英雄联盟举例说明工厂模式\n```java\n// 青钢影-卡密尔类 分别有四个技能QWER  并实现Skill接口\npublic class Camille implements Skill {\n\n    public void q() {\n        System.out.println(\"Camille Q\");\n    }\n\n    public void w() {\n        System.out.println(\"Camille W\");\n    }\n\n    public void e() {\n        System.out.println(\"Camille E\");\n    }\n\n    public void r() {\n        System.out.println(\"Camille R\");\n    }\n}\n\n// 皎月女神-戴安娜类 分别有四个技能QWER 并实现Skill接口\npublic class Diana implements Skill {\n\n    public void q() {\n        System.out.println(\"Diana Q\");\n    }\n\n    public void w() {\n        System.out.println(\"Diana W\");\n    }\n\n    public void e() {\n        System.out.println(\"Diana E\");\n    }\n\n    public void r() {\n        System.out.println(\"Diana R\");\n    }\n\n\n}\n// 刀妹-艾瑞莉娅类 分别有四个技能QWER 并实现Skill接口\npublic class Irelia implements Skill {\n    public void q() {\n        System.out.println(\"Irelia Q\");\n    }\n\n    public void w() {\n        System.out.println(\"Irelia W\");\n    }\n\n    public void e() {\n        System.out.println(\"Irelia E\");\n    }\n\n    public void r() {\n        System.out.println(\"Irelia R\");\n    }\n}\n\n// skill接口 定义四个抽象方法，在实例化对象的时候可以确保方法的调用时统一的。\npublic interface Skill {\n    void q();\n    void w();\n    void e();\n    void r();\n\n}\n\n//简单工厂模式\npublic class HeroFactory {\n\t// 根据用户传入的不同英雄名，利用反射，直接得到该英雄实例。\n    public static Skill getHero(String name) throws Exception {\n        Skill skill;\n//        反射\n//        元类,用来描述一个类的\n//        类是对象的抽象\n        String classStr = \"reflect.hero.\" + name;\n        Class<?> cla = Class.forName(classStr);\n        Object object = cla.newInstance();\n        return (Skill) object;\n    }\n}\n\n// 主函数\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n    \t// 获取用户的输入\n        String name = Main.getPlayerInput();\n        // 隐藏new的细节，全部交给工厂对象的getHero方法来创建对象\n        Skill skill = HeroFactory.getHero(name);\n        skill.r();\n    }\n\n\n    // 获取玩家输入\n    private static String getPlayerInput() {\n        System.out.println(\"Enter a Hero's Name\");\n        Scanner scanner = new Scanner(System.in);\n        String name = scanner.nextLine();\n        return name;\n    }\n}\n\n```\n\n这里直接贴上测试代码，工厂模式隐藏了对象的创建细节，不然的话，想想代码是多么的糟糕，我们在主函数里接收到用户输入的英雄名，用switch来判断，然后实例化英雄，在调用英雄的QWER方法。例如如下代码\n```java\npublic static void main(String[] args) {\n        String name = Main.getPlayerInput();\n\n        switch (name) {\n            case \"Diana\":\n                Diana diana = new Diana();\n                diana.r();\n                  break;\n            case \"Irelia\":\n                Irelia irelia = new Irelia();\n                irelia.r();\n                  break;\n            case \"Camille\":\n                Camille camille = new Camille();\n                camille.r();\n                  break;\n        }\n\n    }\n```\n如果有100个英雄呢？你是否需要这样判断100次，在创建100个英雄实例，在调用100次r()函数呢？\n毫无疑问，这样的代码是糟糕的。\n\n在回顾上面的代码，所以我们定义了skill接口，不同的对象实现统一的接口，可以实现方法的统一调用，不管你new的是哪个对象，我全部都用skill来调用，实现接口后，我们的mian中就可以这样写了\n```java\n    public static void main(String[] args) throws Exception {\n        String name = Main.getPlayerInput();\n        Skill skill;\n        switch (name) {\n            case \"Daina\":\n                skill = new Diana();\n                break;\n            case \"Irelia\":\n                skill = new Irelia();\n                break;\n            case \"Camille\":\n                skill = new Camille();\n                break;\n            default:throw new Exception();\n        }\n        //通过实现类来调用方法，不用关注你具体new的是谁了。\n        skill.r();\n\n    }\n\n```\n\n但是，我们在想一想，这样代码还是很繁琐，我们还是需要去new不同的实现类，如何才能不new实现类，隐藏创建对象的细节呢？外部只管调用即可，及时出现别的需求，我们的main函数式不需要改变的，即实现OCP原则呢？引出了工厂模式\n```java\n// 简单工厂模式\n// 创建一个工厂类，提供一个静态的方法来创建实例对象，方法返回一个实例对象供外部使用\npublic class HeroFactory {\n\n    public static Skill getHero(String name) throws Exception {\n        Skill skill;\n        switch (name) {\n            case \"Daina\":\n                skill = new Diana();\n                break;\n            case \"Irelia\":\n                skill = new Irelia();\n                break;\n            case \"Camille\":\n                skill = new Camille();\n                break;\n            default:\n                throw new Exception();\n        }\n\n        return skill;\n\n    }\n}\n\n// 在看我们的主函数，直接通过HeroFactory类的静态方法getHero，即可得到一个实例对象，隐藏了对象创建的过程。\npublic static void main(String[] args) throws Exception {\n        String name = Main.getPlayerInput();\n        Skill skill = HeroFactory.getHero(name);\n        skill.r();\n    }\n\n```\n\n这就是简单工厂模式！实现了OCP原则，以后无论你需要增加多少个英雄，你只需要在工厂方法内部去增加就可以了，main函数你无需关心，只要你工厂类能给我创建对象，main函数中就可以实现业务功能！但是，我们想一想，其实只是实现了main函数的OCP原则，但是工厂内部创建对象还是很麻烦，对吧，如果要增加英雄，你还是得根据用户的输入，再去判断，再去new，从而供外部调用获得新的英雄对象，如何解决这个问题呢？需要用到反射，也就是说，原本是需要用户输入字符串，我们根据字符串去判断，帮玩家new出来这个英雄，用了反射后，用户输入的不再是一个字符串，而是直接给你一个英雄对象，你帮我利用反射创建出来即可。最终代码，如下\n```java\npublic class HeroFactory {\n    public static Skill getHero(String name) throws Exception {\n        Skill skill;\n//        反射\n//        元类,用来描述一个类的\n//        类是对象的抽象\n        String classStr = \"reflect.hero.\" + name;   //用户输入Daina，相当于输入的是reflect.hero.Daina这个类\n        Class<?> cla = Class.forName(classStr); //根据包路径，获得元类\n        Object object = cla.newInstance(); //通过元类，实例化对象\n        return (Skill) object;//在强转成Skill接口类型对象\n    }\n}\n```\n\n写了这么多，其实就是一个慢慢演变的过程，在spring框架中，ioc的概念，底层其实也就是工厂+反射，你不需要new对象，你只需要告诉spring容器，你需要什么对象，spring容器就会自动帮你创建对象。当然spring框架中比这个复杂的多。但是原理大概是这样子的。","tags":["工厂模式"],"categories":["设计模式"]},{"title":"Spring框架基础知识","url":"/2018/03/12/Spring框架基础知识/","content":"\n\n# Spring框架\n\n\n## Spring框架简述\n> 是企业级应用中的一个软件开发框架，是一个半成品。最大优势是更好的实现了资源的整合(整合mybatis，整合springmvc，整合Redis…)。Spring框架中最核心是:IOC控制反转、DI依赖注入、Bean工厂、SpringAOP面向切面、事物控制例如整合JDBC，MyBatis，Hibernate等框架资源以更好的简化应用软件开发，降低软件开发周期。  \n\n> Spring的目的：就是让对象与对象之间的关系没有通过代码来关联，都是通过配置类说明管理的。\n> Spring就是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。\n> Spring里用的最经典的一个设计模式就是模板方法模式。\n\n## Spring核心架构：\n> * Spring Core：spring的核心容器，提供Spring框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC）模式，将应用程序的配置和依赖性规范与实际的应用程序代码分开  \n\n> * Spring Context：Spring上下文，是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。  \n\n> * Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。可以很容易地使 Spring框架管理的任何对象支持AOP。Spring AOP模块为基于Spring 的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，就可以将声明性事务管理集成到应用程序中。  \n\n> * Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。  \n\n> * Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括JDO、Hibernate和iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。  \n\n> * Spring Web：Web上下文模块建立在应用程序上下文模块之上，为基于Web 的应用程序提供了上下文。所以Spring 框架支持与Jakarta Struts的集成。Web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。  \n\n> * Spring MVC：\tMVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。\n\n## Spring 核心组件：\n> * BeanFactory：Spring内部使用，创建bean的工厂。\n> * ApplicationContext：外部应用程序调用，也成为spring容器的上下文。\n> * IoC控制反转：开发者在无需自己new对象，无需关心对象的创建过程。\n> * DI依赖注入：松耦合方式实现对象之间的依赖\n> * AOP：面向切面编程,补充java面向对象的不足\n","tags":["Spring"],"categories":["Spring框架"]},{"title":"Nginx扩展知识总结","url":"/2018/03/09/Nginx扩展知识总结/","content":"\n# Nginx  \n\n>  Nginx同Apache一样都是一种WEB服务器。基于REST架构风格，以统一资源描述符URI或者统一资源定位符URL作为沟通依据，通过HTTP协议提供各种网络服务。当然每一种web服务器在设计之初手当时的环境局限,比如用户规模、网络宽带、产品特点等,并且各自的定位和发展都不尽相同。这也使得各个WEB服务器有着各自鲜明的特点\n\n>  Apache发展时间长，优点是稳定、开源、跨平台，但是缺点就是因为出现的时间太久了，他兴起的年代、互联网产业远远比不是现在，所以他被设计为重量级，并不支持高并发，在Apache上运行数以万计的访问，会导致服务器小号大量内存，操作系统对其进行进程或线程间的切换也会消耗大量的cpu资源，导致http请求的平均响应水平变低，Apache是以进程为基础的结构，进程要比线程消耗更多的系统开支，不太适合于多处理器环境，这些都决定Apache不可能成为高性能的WEB服务器，所以轻量级高并发服务器Nginx就应运而生了。\n\n## 什么是正向代理\n>  正向代理也是大家最常接触的到的代理模式，像我们平时需要访问外国的某些网站，可能会用一个操作FQ进行访问，FQ的方式主要就是找到一个可以访问外国网站的代理服务器，我们讲请求发送给代理服务器去访问国外的网站，然后将访问到的数据传递给我们，这种模式成为正向代理，正向代理最大的特点及时客户端非常明确要访问的服务器地址，服务器只清楚请求来自哪个代理服务，而不清楚来自哪个具体的客户端，正向代理模式屏蔽或隐藏了真是客户端信息。\n\n> 总结来讲，正向代理，它代理的是客户端，是一个位于客户源和原始服务器之间的服务器，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。\n\n## Nginx反向代理服务器\n> 反向代理：\"它代理的是服务端\"，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。也就是说在多个客户端给服务器发送请求，在Nginx服务器接收到之后，会按照一定的规则分发给后端的阢处理服务器进行处理，此时客户端发起的请求的来源是明确的，但是请求具体由哪台服务器处理的并不明确，Nginx扮演的就是一个反向代理的角色，客户端是感知不到代理存在的，反向代理对外都是透明的。访问者可能根本都不知道访问的是代理，因为客户端不需要任何配置就可以访问。\n\n## Nginx负载均衡调度算法：\n> 1. weight轮询(默认)：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。\n> 2. ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。\n> 3. fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。\n> 4. url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。\n\n\n## 几种web服务器比较：\n![avatar](/images/webservice.png)\n\nTengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。\n> 1. 继承Nginx-1.15.9的所有特性，兼容Nginx的配置；\n> 2. 支持HTTP的CONNECT方法，可用于正向代理场景；\n> 3. 支持异步OpenSSL，可使用硬件如:QAT进行HTTPS的加速与卸载；\n> 4. 更加强大的负载均衡能力，包括一致性hash模块、会话保持模块，还可以对后端的服务器进行主动健康检查，根据服务器状态自动上线下线，以及动态解析upstream中出现的域名；\n> 5. 输入过滤器机制支持。通过使用这种机制Web应用防火墙的编写更为方便；\n> 6. 支持设置proxy、memcached、fastcgi、scgi、uwsgi在后端失败时的重试次数\n> 7. 动态脚本语言Lua支持。扩展功能非常高效简单；\n> 8. 支持按指定关键字(域名，url等)收集Tengine运行状态；\n> 9. 组合多个CSS、JavaScript文件的访问请求变成一个请求；\n> 10. 自动去除空白字符和注释从而减小页面的体积\n> 11. 自动根据CPU数目设置进程个数和绑定CPU亲缘性；\n> 12. 监控系统的负载和资源占用从而对系统进行保护；\n> 13. 显示对运维人员更友好的出错信息，便于定位出错机器；\n> 14. 更强大的防攻击（访问速度限制）模块；\n> 15. 更方便的命令行参数，如列出编译的模块列表、支持的指令等；\n> 16. 可以根据访问文件类型设置过期时间；\n\n\n\n","tags":["Nginx"],"categories":["Nginx"]},{"title":"SpringMVC基础知识","url":"/2018/03/09/SpringMVC基础知识/","content":"# SpringMVC\n\n## Servlet:\n> 在认识SpringMVC前先回顾Servlet\n> Servlet本质上一段java程序\n> Servlet程序无法独立运行，必须放在服务器中，由服务器调用才可以执行！\n> Servlet的作用是：接受请求、处理请求、将结果响应给浏览器。  \n\n\t\n## Servlet的缺点\n每个Servlet声明时需要在web.xml中配置8行代码，配置繁琐，内容多，web.xml结构不清晰，不易维护。团队开发冲突不断。一般来说，每个Servlet只处理一个请求，如果要实现数据库表的CRUD操作，需要写4个Servlet。获取参数繁琐只能强制转类型，复杂的还需特殊处理。如日期类型转换，代码繁多重复手工劳动，非业务代码。  \n\n\n## Web MVC架构及分析\n基于servlet，jsp，javabean技术实现的MVC架构,具体架构图如下：\n![avatar](/images/mvc.png)  \n\n\n## MVC设计模式:\n> 用来进行分层的结构，这样代码分离结构清晰，各层代码，各司其职，易于开发大型项目。MVC(Model模型层、View视图层、Control控制层(servlet层))，将软件进行分层达到松耦合的效果。\n> 优势：提高代码的可读性，实现程序间的松耦合、提高代码复用性。\n![avatar](/images/mvc2.png)  \n\n\n## 什么是SpringMVC  \n> SpringMVC他不是一个框架，而是Spring框架中的WEB应用模块\n> SpringMVC属于SpringFrameWork的后续产品。\n> SpringMVC就是基于MVC设计模式来实现的。\n> 我们的POJO就是Model层，我们的JSP就是视图层，我们的Controller就是控制层。  \n\n## SpringMVC的工作原理：\n>SpringMVC底层就是一个servlet\n![avatar](/images/springmvc.png)\n> 1. 当浏览器发起一个请求，访问我们的程序，就会被前端控制器拦截，（DispatcherServlet，SpringMVC的第一个组件）。\n> 2. DispatcherServlet只负责接受请求和响应请求，它会解析URL调用处理器映射器（HandlerMapping）找到对应能处理这段业务的Controller，把Controller的名字返回给前端控制器，这时候DispatcherServlet就知道那个类可以处理业务。\n> 3. 拿到能处理业务的类名后，会调用（处理器适配器）HandlerAdaptor开始处理业务，一层一层的调用，从controller到service到dao层操作数据库，操作完数据库之后把所有的数据封装给ModelAndView对象，返回给DispatcherServlet，前段控制器就有了可以展示的视图和数据。\n> 4. 拿到ModelAndView对象之后，因为既有页面信息又有数据，所以会找到视图解析器（ViewReslover）解析完后会将View页面先发给前端控制器，前端控制器就可以准备页面演示了。\n> 5. 页面有了之后前端控制器就会将model也给到view。之后将model和view的内容一整合，就可以做最后响应的这一步了。","tags":["Spring"],"categories":["Spring框架"]},{"title":"Mybatis基础知识","url":"/2018/03/02/Mybatis基础知识/","content":"\n# MyBatis\n\n## JDBC回顾\n> 再讲Mybatis之前，先回顾一下JDBC开发步骤：\n> 1. 注册驱动Class.forName(\"  \");\n> 2. 获取数据库连接DriverManager.getConnection();\n> 3. 获取传输器conn.preparedStatement();\n> 4. 执行SQL   ps.executeQuery(), 返回结果集对象ResultSet\n> 5. 遍历结果集\n> 6. 释放资源\n```java\npublic static void main(String[] args) {\n\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        \n        try {\n            //加载数据库驱动\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            //通过驱动管理类获取数据库链接\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\", \"root\", \"root\");\n            //定义 sql 语句 ?表示占位符\n            String sql = \"select * from user where username = ?\";\n            //获取预处理 statement\n            preparedStatement = connection.prepareStatement(sql);\n            //设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为设置的参数值\n            preparedStatement.setString(1, \"王五\");\n            //向数据库发出 sql 执行查询，查询出结果集\n            resultSet = preparedStatement.executeQuery();\n            //遍历查询结果集\n            while (resultSet.next()) {\n                System.out.println(resultSet.getString(\"id\") + resultSet.getString(\" username\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            //释放资源\n            if (resultSet != null) {\n                try {\n                    resultSet.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (preparedStatement != null) {\n                try {\n                    preparedStatement.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n//  上边使用 jdbc 的原始方法（未经封装）实现了查询数据库表记录的操作。\n\n```\n### 使用JDBC的劣势\n> 1. 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。\n> 2. Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java代码。\n> 3. 使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能多也可能少，修改 sql 还要修改代码，系统不易维护。\n> 4. 对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成 pojo 对象解析比较方便。\n\n## MyBatis框架概述\n>mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。\n\n### 简单记重点\n> Mybatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架,也是用来操作是数据库的。\n>优点：底层封装JDBC，可以简化JDBC的开发，并且可以更好的完成ORM（对象关系映射）\n\n\n### Mybatis开发环境搭建\n> 1. 创建 maven 工程\n> 2. 添加 Mybatis的坐标\n```xml  \n<dependencies>\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.4.5</version>\n    </dependency>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.10</version>\n    <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.6</version>\n        <scope>runtime</scope>\n    </dependency>\n    <dependency>\n        <groupId>log4j</groupId>\n        <artifactId>log4j</artifactId>\n        <version>1.2.12</version>\n    </dependency>\n </dependencies>\n```\n> 3. 编写 User 实体类\n```java\npublic class User implements Serializable {\n    private Integer id;\n    private String username;\n    private Date birthday;\n    private String sex;\n    private String address;\n    public Integer getId() {\n        return id;\n    }\n    public void setId(Integer id) { this.id = id; }\n    public String getUsername() { return username; }\n    public void setUsername(String username) { this.username = username; }\n    public Date getBirthday() { return birthday; }\n    public void setBirthday(Date birthday) { this.birthday = birthday; }\n    public String getSex() { return sex; }\n    public void setSex(String sex) { this.sex = sex; }\n    public String getAddress() { return address; }\n    public void setAddress(String address) { this.address = address; }\n    @Override\n    public String toString() {\n        return \"User [id=\" + id + \", username=\" + username + \", birthday=\" + birthday\n        + \", sex=\" + sex + \", address=\"\n        + address + \"]\";\n    }\n}\n\n```\n> 4. 编写持久层接口 Dao\n```java\npublic interface IUserDao {\n    /**\n    * 查询所有用户\n    * @return\n    */\n    List<User> findAll();\n    }\n```\n> 4. 编写持久层接口的映射文件\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.itheima.dao.UserDao\">\n    <!-- 配置查询所有操作 -->\n    <select id=\"findAll\" resultType=\"com.itheima.domain.User\">\n        select * from user\n    </select>\n</mapper>\n\n```\n\n> 5. 编写 SqlMapConfig.xml 配置文件\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration\n PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n<!-- 配置 mybatis 的环境 -->\n    <environments default=\"mysql\">\n<!-- 配置 mysql 的环境 -->\n        <environment id=\"mysql\">\n<!-- 配置事务的类型 -->\n        <transactionManager type=\"JDBC\"></transactionManager>\n<!-- 配置连接数据库的信息：用的是数据源(连接池) -->\n        <dataSource type=\"POOLED\">\n            <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n            <property name=\"url\" value=\"jdbc:mysql://localhost:3306/数据库名\"/>\n            <property name=\"username\" value=\"root\"/>\n            <property name=\"password\" value=\"1234\"/>\n        </dataSource>\n    </environment>\n</environments>\n<!-- 告知 mybatis 映射配置的位置 -->\n<mappers>\n    <mapper resource=\"com/itheima/dao/UserDao.xml\"/>\n</mappers>\n</configuration>\n```\n> 6. 编写测试类\n```java\npublic static void main(String[] args)throws Exception {\n    //1.读取配置文件\n    InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n    //2.创建 SqlSessionFactory 的构建者对象\n    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n    //3.使用构建者创建工厂对象 SqlSessionFactory\n    SqlSessionFactory factory = builder.build(in);\n    //4.使用 SqlSessionFactory 生产 SqlSession 对象\n    SqlSession session = factory.openSession();\n    //5.使用 SqlSession 创建 dao 接口的代理对象\n    IUserDao userDao = session.getMapper(IUserDao.class);\n    //6.使用代理对象执行查询所有方法\n    List<User> users = userDao.findAll();\n    for(User user : users) {\n    System.out.println(user);\n    }\n    //7.释放资源\n    session.close();\n    in.close();\n\n    // 这简单的几行代码中，使用了三种设计模式，\n\t// 1. 创建工厂的时候，mybatis使用了构建者模式。     优势：吧对象的创建细节隐藏起来，使用者直接调用build即可拿到对象。\n\t// 2. 生产sqlSession使用了工厂模式。               优势：解耦（降低类之间的依赖关系）。\n    // 3. 创建Dao接口实现类使用了代理模式。             优势：不修改源码的基础上对已有的方法增强。\n}\n```\n\n### 小结 \n> 通过快速入门示例，我们发现使用 mybatis 是非常容易的一件事情，因为只需要编写 Dao 接口并且按照mybatis 要求编写两个配置文件，就可以实现功能。远比我们之前的 jdbc 方便多了。（我们使用注解之后，将变得更为简单，只需要编写一个 mybatis 配置文件就够了。）但是，这里面包含了许多细节，比如为什么会有工厂对象（SqlSessionFactory）,为什么有了工厂之后还要有构建者对象（SqlSessionFactoryBuilder），为什么 IUserDao.xml 在创建时有位置和文件名的要求等等。这些问题我们在自定义 mybatis 框架的章节，通过层层剥离的方式，给大家讲解。请注意：我们讲解自定义 Mybatis 框架，不是让大家回去自己去写个 mybatis，而是让我们能更好了了解mybatis 内部是怎么执行的，在以后的开发中能更好的使用 mybatis 框架，同时对它的设计理念（设计模式）有一个认识。\n\n\n\n## Mybatis图解\n![avatar](/images/mybatis.PNG)\n> 1. SqlMapConfig.xml：此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。\n> 2. xxxMapper.xml：sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。\n> 3. SqlSessionFactory：通过mybatis环境等配置信息构造会话工厂对象。\n> 4. SqlSession：由会话工厂对象创建会话对象，操作数据库需要通过Session进行。\n> 5. User：Executor把执行sql后的内容输出映射到java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程  \n\n## Mybatis工作原理解析简述\n> 1. mybatis应用程序通过SqlSessionFactoryBuilder核心配置文件中构建出会话工厂对象，\n> 2. 通过会话工厂的实例开启一个会话，\n> 3. 通过会话对象获得一个mapper对象并运行mapper映射的SQL语句，\n> 4. 完成对数据库的增删改查（CRUD）和事物提交，之后关闭sqlSession\n\n\n## MyBatis中的重要对象\n> 分别是SqlSessionFactory和SqlSession。  \n\n> * SqlSessionFactory：可以理解为会话工厂，在整个项目中共享，是线程安全的。通过openSession方法创建SqlSession对象，该方法存在很多重载方式可以有参数可以无参数。\n> * SqlSession：可以通过会话工厂产生，线程不安全。用来执行SQL，提供了丰富的方法来完成数据库的操作。返回结果集. 框架底层直接将查询到的数据封装为实体对象  \n\n>Mybatis不会自动提交事物，需要手动提交。提交方式有两种：openSession（true）或者session.commit（）；\n\n## 拓展\n### #{}取值和${}取值的区别\n> 1. Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；\n> 2. Mybatis在处理${}时，就是把${}替换成变量的值。\n> 3. 使用#{}可以有效的防止SQL注入，提高系统安全性。\n\n### #resultType 和 resultMap的区别？\n> 1. resultType：类的名字和数据库相同时，可以直接设置resultType参数为Pojo类。\n> 2. resultMap：类的名若不同，需要设置resultMap将结果名字和Pojo名字进行转换。\n> 3. ResultMap用于映射不规范字段自动匹配规范驼峰规则，数据库字段与pojo对象的属性名不符合的时候可以使用此规则，属性名首字母小写，第二个单词首字母大写\n","tags":["Mybatis"],"categories":["Mybatis框架"]},{"title":"Mycat配置文件","url":"/2018/03/01/Mycat配置文件/","content":"\n# Mycat配置文件介绍\n\n## schema.xml文件配置\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE mycat:schema SYSTEM \"schema.dtd\">\n<mycat:schema xmlns:mycat=\"http://io.mycat/\">\n\n        <!--name属性是自定义的  dataNode表示数据库的节点信息-->\n        <schema name=\"jtdb\" checkSQLschema=\"false\" sqlMaxLimit=\"100\" dataNode=\"jtdb\"/>\n\n        <!--定义节点名称/节点主机/数据名称-->\n        <dataNode name=\"jtdb\" dataHost=\"localhost1\" database=\"jtdb\" />\n                <!--参数介绍-->\n                <!--balance 0表示所有的读操作都会发往writeHost主机 -->  \n                <!--1表示所有的读操作发往readHost和闲置的主节点中-->\n                <!--writeType=0 所有的写操作都发往第一个writeHost主机-->\t\n                <!--writeType=1 所有的写操作随机发往writeHost中-->\n                <!--dbType 表示数据库类型 mysql/oracle-->\n                <!--dbDriver=\"native\"  固定参数 不变-->\n                <!--switchType=-1 表示不自动切换, 主机宕机后不会自动切换从节点-->\n                <!--switchType=1  表示会自动切换(默认值)如果第一个主节点宕机后,Mycat会进行3次心跳检测,如果3次都没有响应,则会自动切换到第二个主节点-->\n                <!--并且会更新/conf/dnindex.properties文件的主节点信息 localhost1=0 表示第一个节点.该文件不要随意修改否则会出现大问题-->\n        <dataHost name=\"localhost1\" maxCon=\"1000\" minCon=\"10\" balance=\"1\"\n                  writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\" switchType=\"1\"  slaveThreshold=\"100\">\n                <heartbeat>select 1</heartbeat>\n\n        <!--配置第一台主机主要进行写库操作,在默认的条件下Mycat主要操作第一台主机在第一台主机中已经实现了读写分离.因为默认写操作会发往137的数据库.读的操作默认发往141.如果从节点比较忙,则主节点分担部分压力.\n        -->\n        <writeHost host=\"hostM1\" url=\"192.168.65.128:3306\" user=\"root\" password=\"root\">\n                <!--读数据库-->\n                <readHost host=\"hostS1\" url=\"192.168.65.130:3306\" user=\"root\" password=\"root\" />\n        </writeHost>\n\n        <!--定义第二台主机 由于数据库内部已经实现了双机热备.-->\n        <!--Mycat实现高可用.当第一个主机137宕机后.mycat会自动发出心跳检测.检测3次.-->\n        <!--如果主机137没有给Mycat响应则判断主机死亡.则回启东第二台主机继续为用户提供服务.-->\n        <!--如果137主机恢复之后则处于等待状态.如果141宕机则137再次持续为用户提供服务.-->\n        <!--前提:实现双机热备.-->\n        \n        <writeHost host=\"hostM2\" url=\"192.168.65.128:3306\" user=\"root\" password=\"root\">\n                <readHost host=\"hostS1\" url=\"192.168.65.130:3306\" user=\"root\" password=\"root\" />\n        </writeHost>\n        </dataHost>\n</mycat:schema>\n\n```\n\n\n## server.xml文件配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- - - Licensed under the Apache License, Version 2.0 (the \"License\"); \n        - you may not use this file except in compliance with the License. - You \n        may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 \n        - - Unless required by applicable law or agreed to in writing, software - \n        distributed under the License is distributed on an \"AS IS\" BASIS, - WITHOUT \n        WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the \n        License for the specific language governing permissions and - limitations \n        under the License. -->\n<!DOCTYPE mycat:server SYSTEM \"server.dtd\">\n<mycat:server xmlns:mycat=\"http://io.mycat/\">\n        <system>\n        <property name=\"nonePasswordLogin\">0</property> <!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0-->\n        <property name=\"useHandshakeV10\">1</property>\n        <property name=\"useSqlStat\">0</property>  <!-- 1为开启实时统计、0为关闭 -->\n        <property name=\"useGlobleTableCheck\">0</property>  <!-- 1为开启全加班一致性检测、0为关闭 -->\n        <property name=\"sequnceHandlerType\">2</property>\n      <!--  <property name=\"useCompression\">1</property>--> <!--1为开启mysql压缩协议-->\n        <!--  <property name=\"fakeMySQLVersion\">5.6.20</property>--> <!--设置模拟的MySQL版本号-->\n        <!-- <property name=\"processorBufferChunk\">40960</property> -->\n        <!-- <property name=\"processors\">1</property> \n        <property name=\"processorExecutor\">32</property> -->\n        <!--默认为type 0: DirectByteBufferPool | type 1 ByteBufferArena | type 2 NettyBufferPool -->\n        <property name=\"processorBufferPoolType\">0</property>\n        <!--默认是65535 64K 用于sql解析时最大文本长度 -->\n        <!--<property name=\"maxStringLiteralLength\">65535</property>-->\n        <!--<property name=\"sequnceHandlerType\">0</property>-->\n        <!--<property name=\"backSocketNoDelay\">1</property>-->\n        <!--<property name=\"frontSocketNoDelay\">1</property>-->\n        <!--<property name=\"processorExecutor\">16</property>-->\n        <!--\n                <property name=\"serverPort\">8066</property> <property name=\"managerPort\">9066</property> \n                <property name=\"idleTimeout\">300000</property> <property name=\"bindIp\">0.0.0.0</property> \n                <property name=\"frontWriteQueueSize\">4096</property> <property name=\"processors\">32</property> -->\n        <!--分布式事务开关，0为不过滤分布式事务，1为过滤分布式事务（如果分布式事务内只涉及全局表，则不过滤），2为不过滤分布式事务,但是记录分布式事务日志-->\n        <property name=\"handleDistributedTransactions\">0</property>\n        <!--off heap for merge/order/group/limit      1开启   0关闭-->\n        <property name=\"useOffHeapForMerge\">1</property>\n        <!--单位为m-->\n        <property name=\"memoryPageSize\">64k</property>\n        <!--单位为k-->\n        <property name=\"spillsFileBufferSize\">1k</property>\n        <property name=\"useStreamOutput\">0</property>\n        <!--单位为m-->\n        <property name=\"systemReserveMemorySize\">384m</property>\n\n        <!--是否采用zookeeper协调切换  -->\n        <property name=\"useZKSwitch\">true</property>\n        <!-- XA Recovery Log日志路径 -->\n        <!--<property name=\"XARecoveryLogBaseDir\">./</property>-->\n        <!-- XA Recovery Log日志名称 -->\n        <!--<property name=\"XARecoveryLogBaseName\">tmlog</property>-->\n        </system>\n        <!-- 全局SQL防火墙设置 -->\n        <!--白名单可以使用通配符%或着*-->\n        <!--例如<host host=\"127.0.0.*\" user=\"root\"/>-->\n        <!--例如<host host=\"127.0.*\" user=\"root\"/>-->\n        <!--例如<host host=\"127.*\" user=\"root\"/>-->\n        <!--例如<host host=\"1*7.*\" user=\"root\"/>-->\n        <!--这些配置情况下对于127.0.0.1都能以root账户登录-->\n        <!--\n        <firewall>\n           <whitehost>\n              <host host=\"1*7.0.0.*\" user=\"root\"/>\n           </whitehost>\n       <blacklist check=\"false\">\n       </blacklist>\n        </firewall>\n        -->\n        <!--用户标签-->\n        <user name=\"root\">\n                <property name=\"password\">root</property>\n                <!--与schema.xml中的配置相同 注意数据库的大小写-->\n                <property name=\"schemas\">jtdb</property>\n        </user>\n        <user name=\"user\">\n                <property name=\"password\">user</property>\n                <property name=\"schemas\">jtdb</property>\n                <property name=\"readOnly\">true</property>\n        </user>\n</mycat:server>\n\n```","tags":["常用配置文件"],"categories":["mycat配置"]},{"title":"Servlet基础知识","url":"/2018/02/15/Servlet基础知识/","content":"\n# Servlet\n\n## Servlet概述\n> 1. Servlet本质上一段java程序\n> 2. Servlet程序无法独立运行，必须放在服务器中，由服务器调用才可以执行！\n> 3. Servlet的作用是：接受请求、处理请求、将结果响应给浏览器。\n\n## Servlet的作用\n> Servlet的作用就是处理请求，服务器会将接受到的请求交给Servlet处理。这个过程为：\n> 1. 客户端发送请求至服务器端；\n> 2. 服务器将请求信息交给 Servlet 处理；\n> 3. 最终处理的结果交给服务器；\n> 4. 服务器将结果响应给客户端。\n\n## Servlet调用过程\n> ![avatar](/images/servlet调用执行流程.png)\n> 1. 浏览器向服务器发起请求\n> 2. 首先会根据请求头信息获知浏览器访问的是那个虚拟主机\n> 3. 然后根据请求行中的路径资源获知浏览器访问的是哪一个web应用\n> 4. 根据请求行中的资源路径获知访问的是哪一个资源\n> 5. 根据获取到的资源路径到web.项目文件中去匹配真实路径，创建servlet实例并调用service方法\n> 6. 调用service方法前，底层会创建两个对象，Requset、response，通过request获取请求相关信息\n> 7. 通过response想浏览器发送响应数据，然后按照Http协议规定的格式，组织成相应消息，最后发送给浏览器\n\n## Servlet生命周期\n> &emsp;Servlet在第一次被访问时创建Servlet实例, 创建之后服务器会立即调用init方法进行初始化的操作, 创建之后, Servlet实例会一直驻留在服务器的内存中, 为后续的请求服务. 只要有请求来访问这个Servlet, 服务器就会调用service方法来处理请求, 直到服务器关闭, 或者WEB应用被移出容器, 随着WEB应用的销毁, Servlet实例也会跟着销毁, 在销毁之前服务器会调用destroy方法进行善后的处理。\n\n## 请求、转发、域对象\n> 1. 域对象：\n    > &emsp;能够在指定的范围内, 利用自身的map实现数据的共享  \n\n> 2. 请求转发：\n    > &emsp;是指定服务器中的某一个资源（Servlet或JSP）在处理请求的过程中，将请求转发给一个其他的资源，让其他资源来处理请求转发只能在同一个Web应用内部的两个资源之间进行跳转, 不可以是不同的Web应用或者不同的服务器中进行跳转,请求转发是一次请求，一次响应，转发前后地址栏地址不会发生变化  \n\n> 3. 重定向：\n\t> &emsp;是指当用户浏览某个网址时，将其导向到另一个网址的技术。重定向和定时刷新都是两次请求两次响应，重定向和定时刷新前后，地址栏地址都会发生变化\n\n> 4. 总结:\n > 定时刷新和重定向都是两次请求, 两次响应\n > 定时刷新和重定向跳转前后, 地址栏地址都会发生变化。\n > 定时刷新和重定向在跳转时没有限制, 既可以在同一个Web应用内部的资源之间进行跳转, 也可以在不同的Web应用或者不同的主机之间进行跳转\n > 定时刷新和重定向不同的是, 重定向是立即跳转, 中间没有时间间隔, 而定时刷新可以指定多少秒之后再进行跳转, 在跳转之前, 可以输出内容到浏览器, 提示用户。\n\n### EL表达式的作用: \n> &emsp;在Web开发中, 实现很多功能的时候, 都是由Servlet接收请求、处理请求，但是处理的结果应该交给JSP显示，此时我们可以在Servlet中将请求处理的结果存入request域中，再通过转发将Request域带到JSP中，再通过EL表达式将request域中的数据取出来, 显示在网页上.\n\n","tags":["基础知识"],"categories":["Servlet基础知识"]},{"title":"会话技术基础知识","url":"/2018/02/10/会话技术基础知识/","content":"\n# 会话技术  \n\n## 什么是会话?  \n\n> &emsp;为了实现某一个功能(比如购物), 浏览器和服务器之间可能会产生多次的请求和响应。从浏览器访问服务器开始，到访问服务器结束，浏览器关闭为止，这期间产生的多次请求和响应加在一起就称之为浏览器和服务器之间的一次会话！  \n\n> &emsp;会话中往往会产生一些数据，而这些数据往往是需要我们保存起来的，如何保存会话中产生的数据呢？这里可以使用会话技术(也就是Cookie和session)来保存会话中产生的数据\n\n## Cookie 和 Session 保存数据的原理 \n### Cookie\n> &emsp;通过 Set-Cookie响应头 和 Cookie请求头 将会话中产生的数据保存在客户端( 浏览器 ) , 当浏览器在此访问服务器时,服务器会获取上一次会话发送给浏览器的Cookie信息,通过这种方式来保存会话中的数据。由于Cookie技术是将会话中产生的数据保存在客户端，每个客户端各自持有自己的数据，当需要时再带给服务器，因此不会发生混乱！  \n\n>  Cookie的API\n> \n```java\n// 1.创建Cookie对象\n    Cookie c = new Cookie(String name, String value);\n// 2.将Cookie添加到response响应中\n    response.addCookie(Cookie c);//可以调用多次, 表示将多个cookie添加到响应中\n// 3.获取请求中的所有cookie对象组成的数组\n    Cookie[] cs = request.getCookies();\n//注意：该方法会返回请求中的所有cookie组成的数组, 若请求中没有cookie, 该方法会返回null.\n```\n>  删除Cookie\n>  &emsp;没有直接删除cookie的方法，我们可以向浏览器再发送一个同名的cookie(比如名称为prod的cookie), 并设置cookie的存活时间为零, 最后将cookie发送给浏览器。由于浏览器是根据cookie的名字来区分cookie的，如果前后发送了两个名称一样的cookie，后发送cookie会覆盖之前发送的cookie。又由于后发送的cookie生存时间为零，浏览器收到后也会立即删除！！\n\n### Session\n> &emsp;浏览器第一次发送请求需要保存数据时，服务端获取到需要保存的数据，去服务器内部检查一下有没有为当前浏览器服务的session，如果有就直接拿过来用，如果没有session就创建一个新的session拿过来用。接着将数据保存在Session中，做出响应。当浏览器再去访问服务器时，服务器可以从session中获取到之前为当前浏览器保存的数据，通过这种方式，也可以来保存会话中产生的数据。\n\n### Cookie 和 Session的异同\n> 相同点：Cookie和Session都是用于保存会话中产生的数据，都是会话技术\n> 不同点:  \n    > Cookie：\n        >> 1. Cookie是将会话产生的数据保存在客户端，是客户端技术\n        >> 2. Cookie将数据保存在客户端，不占服务器内存，可以提高服务器性能\n        >> 3. Cookie适合存储安全性要求不高，但是需要长时间保存的数据  \n        （因为保存在浏览器客户端，数据容易丢失，或被窃取）\n\n> Session：\n        >> 1. Session是将会话产生的数据保存在服务器，是服务器端技术\n        >> 2. Session将数据保存在服务器端，占用服务器内存，影响服务器性能\n        >> 3. Session适合存储对安全性要求较高，但是不需要长时间保存的数据  \n        （不会随着用户操作，导致数据丢失或被窃取，安全性高）","tags":["基础知识"],"categories":["会话基础知识"]},{"title":"JDBC知识总结","url":"/2018/02/09/Jdbc知识总结/","content":"\n# JDBC：\n## 概念：Java DataBase Connectivity  \n> JDBC( Java DataBase Connectivity ) 翻译过来就是Java数据库连接，其实就是通过Java语言操作数据库的一门技术。\n\n### JDBC由来\n> 由于数据库厂商提供的数据库驱动（操作数据库的jar包）各不相同，导致开发人员的学习成本十分的高。因此SUN公司提出了JDBC这套规范，用来统一访问数据的标准。JDBC本质上是一套接口，SUN要求所有的数据库厂商在设计驱动时，都要实现JDBC这套标准。因此开发人员只要学会JDBC这套接口，所有的数据库驱动就都会使用了。\n\n### JDBC包的介绍\n> JDBC主要是由java.sql 和javax.sql包组成的，并且这两个包已经被集成到J2SE的规范中了，这意味着，只要一个普通的java程序就可以使用JDBC。需要注意的是，JDBC包中大部分都是接口，因此在开发数据库程序时，除了如上的两个包，还需要手动的导入具体的数据库驱动。\n\n## 快速入门：  \n> 开发步骤：\n> 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar\n> 2. 注册驱动\n> 3. 获取数据库连接对象 Connection\n> 4. 定义sql\n> 5. 获取执行sql语句的对象 Statement\n> 6. 执行sql，接受返回结果\n> 7. 处理结果\n> 8. 释放资源\n\t\n### 代码实现：\n```java \n    //1. 导入驱动jar包\n    //2.注册驱动\n    Class.forName(\"com.mysql.jdbc.Driver\");\n    //3.获取数据库连接对象\n    Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\");\n    //4.定义sql语句\n    String sql = \"update account set balance = 500 where id = 1\";\n    //5.获取执行sql的对象 Statement\n    Statement stmt = conn.createStatement();\n    //6.执行sql\n    int count = stmt.executeUpdate(sql);\n    //7.处理结果\n    System.out.println(count);\n    //8.释放资源\n    stmt.close();\n    conn.close();\n```\n## 详解各个对象：\n> 1. DriverManager：驱动管理对象,用于注册驱动，告诉程序该使用哪一个数据库驱动jar,获取数据库连接。\n> 2. Connection：数据库连接对象:获取执行sql的对象,管理事务\n> 3. Statement：执行sql的对象\t\t\t\n> 4. ResultSet：结果集对象,封装查询结果\n> 5. PreparedStatement：执行sql的对象\n>     1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题\n>     2. 解决sql注入问题：使用PreparedStatement对象来解决\n>     3. 预编译的SQL：参数使用?作为占位符\n  \n## SQL注入攻击：\n> &emsp; 由于后台的SQL语句是拼接而来的。其中的参数是由用户提交的，如果用户在提交参数时，在其中掺杂了一些SQL关键字或者特殊符号，就可能会导致SQL语句的语意发生变化。从而执行一些意外的操作。\n## 防止SQL注入攻击\n> &emsp; 使用PreparedStatement对象来替代Statement对象。PreparedStatement对象比Statement对象更安全，效率更高。\n\n\n## 数据库连接池\n> &emsp; 在开发中，所谓的池就是一个容器，来存储程序的中的数据.而数据库连接池就是用来存储数据库连接的池子，用于在整个程序中共享连接，减少连接开关的次数，实现连接的复用，从而提高程序执行的效率.\n\n### 为什么要使用数据库连接池?\n> &emsp; 对于数据库来说，频繁的开关连接会非常的耗费资源，也会导致程序执行效率的低下。我们可以在程序中创建一个池子，在程序启动时就初始化一批连接放在连接池中，当用户需要连接时，就直接从池子中拿一个连接使用，当用完连接后，也不要将连接关闭，而是将连接还回池中，下一个用户需要连接时也是如此。这样可以减少链接开关的次数，从而提供程序执行的效率.\n\n\n## 抽取JDBC工具类 ： JDBCUtils\n### 代码实现：\n```java \n    public class JDBCUtils {\n    private static String url;\n    private static String user;\n    private static String password;\n    private static String driver;\n    /**\n        * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块\n        */\n    static{\n        //读取资源文件，获取值。\n\n        try {\n            //1. 创建Properties集合类。\n            Properties pro = new Properties();\n\n            //获取src路径下的文件的方式--->ClassLoader 类加载器\n            ClassLoader classLoader = JDBCUtils.class.getClassLoader();\n            URL res  = classLoader.getResource(\"jdbc.properties\");\n            String path = res.getPath();\n            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties\n            //2. 加载文件\n            // pro.load(new FileReader(\"D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties\"));\n            pro.load(new FileReader(path));\n\n            //3. 获取数据，赋值\n            url = pro.getProperty(\"url\");\n            user = pro.getProperty(\"user\");\n            password = pro.getProperty(\"password\");\n            driver = pro.getProperty(\"driver\");\n            //4. 注册驱动\n            Class.forName(driver);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n​\t\n```java \n\t    /**\n\t     * 获取连接\n\t     * @return 连接对象\n\t     */\n\t    public static Connection getConnection() throws SQLException {\n\t\n\t        return DriverManager.getConnection(url, user, password);\n\t    }\n\t\n\t    /**\n\t     * 释放资源\n\t     * @param stmt\n\t     * @param conn\n\t     */\n\t    public static void close(Statement stmt,Connection conn){\n\t        if( stmt != null){\n\t            try {\n\t                stmt.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( conn != null){\n\t            try {\n\t                conn.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n```\n\n​\t\n```java\n\t    /**\n\t     * 释放资源\n\t     * @param stmt\n\t     * @param conn\n\t     */\n\t    public static void close(ResultSet rs,Statement stmt, Connection conn){\n\t        if( rs != null){\n\t            try {\n\t                rs.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( stmt != null){\n\t            try {\n\t                stmt.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t\n\t        if( conn != null){\n\t            try {\n\t                conn.close();\n\t            } catch (SQLException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t    }\n\t\n\t}\n```\t\n\n## JDBC控制事务：\n### 什么是事务？\n>\t就是讲一堆sql绑定在一起执行，要么全部执行成功，要么全部都执行失败。   \n\n### 事物的四大特性：\n> 1. 原子性：事务中的所有操作是一个整体，不能在分割，要么全部执行成功，要么全部都执行失败！\n> 2. 一致性：事务前后的业务数据保持不变。\n> 3. 隔离性：事务之间是具有隔离的，一个事务不能访问另外一个事务正在执行的操作。\n> 4. 持久性：事务一旦提交成功，数据的改变将会是永久的。  \n\n### 事务的并发读问题：\n> 1. 脏读：在一个事务中读取到了另外一个事务未提交的数据。\n> 2. 不可重复读：在一个事务中读取到了另一个事物已提交的数据，两次查询的结果不一致，（修改）操作。\n> 3. 幻读：对同一张表的两次查询结果不一致（插入/删除）操作。  \n\n### 事务的隔离级别\n> 1. 读未提交：安全性最低，不能防止任何读并发问题，但是效率高。\n> 2. 读已提交：安全性比<font color=red>读未提交</font>高，可以防止脏读，但是不能防止不可重复读，效率比<font color=red>读未提交</font>低。\n> 3. 可重复读：安全性比<font color=red>读已提交</font>高，可以防止脏读和不可重复读，但是不能防止幻读，效率比<font color=red>读未提交</font>低。\n> 4.   串行化：安全性高，可以防止一切并发读问题，效率最低，不使用这种隔离级别，因为效率太低。  \n\n### 事务隔离级别\n> 事务隔离级别分四个等级，在相同数据环境下，对数据执行相同的操作，设置不同的隔离级别，可能导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力也是不同的。\n> 1. READ UNCOMMITTED（读未提交数据）：安全级别最低, 可能出现任何事务并发问题(比如脏读、不可以重复读、幻读等) 性能最好。\n> 2. READ COMMITTED（读已提交数据）（Oracle默认）防止脏读，没有处理不可重复读，也没有处理幻读；性能比REPEATABLE READ好。\t \n> 3. REPEATABLE READ（可重复读）（MySQL默认）防止脏读和不可重复读，不能处理幻读问题；性能比SERIALIZABLE好。 \n> 4. SERIALIZABLE（串行化）不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的；性能最差。  \n\t \n> MySQL的默认隔离级别为REPEATABLE READ，即可以防止脏读和不可重复读\n\n\n​\t\t\t","tags":["基础知识"],"categories":["Jdbc基础知识"]},{"title":"Java常用API小Demo","url":"/2018/02/06/Java常用API小Demo/","content":"\n# charAt\n&emsp;获取给定位置对应的字符\n```java\n\tpublic static void main(String[] args) {\n\t\t//            0123456789012345\n\t\tString str = \"thinking in java\";\t\t\n\t\tchar c = str.charAt(10);\n\t\tSystem.out.println(c);\n\t\t\n\t\t//判断回文            0 1 2 3  5 6 7 8\n\t\tString line = \"上海自来水自来海上\";\t\n\t\tfor(int i=0;i<line.length()/2;i++) {\n\t\t\tif(line.charAt(i) !=\n\t\t\t   line.charAt(line.length()-1-i)\t\t\n\t\t\t) {\n\t\t\t\tSystem.out.print(\"不\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"是回文!\");\n\t}\n```\n# indexOf\n&emsp;获取给定字符串在当前字符串中的位置，若当前字符串中不含有给定内容则返回值为-1\n\n```java\npublic class IndexOfDemo {\n\tpublic static void main(String[] args) {\n\t\t//            0123456789012345\n\t\tString str = \"thinking in java\";\n\t\t\n\t\tint index = str.indexOf(\"in\");\n\t\tSystem.out.println(index);//2\n\t\t\n\t\t//从指定位置开始检索第一次出现指定内容的位置\n\t\tindex = str.indexOf(\"in\",3);\n\t\tSystem.out.println(index);//5\n\t\t\n\t\t//检索最后一次出现指定内容的位置\n\t\tindex = str.lastIndexOf(\"in\");\n\t\tSystem.out.println(index);//9\n\t\t\n\t}\n}\n```\n   \n\n# lenght\n&emsp;获取当前字符串的长度(字符个数)\n```java\npublic class LengthDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"我爱java\";\n\t\tint len = str.length();\n\t\tSystem.out.println(\"len:\"+len);\n\t}\n}\n\n```\n\n\n# startsWith,endsWith\n&emsp;判断字符串是否是以给定的字符串开始或结尾的\n\n```java\npublic class StartsWithDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"thinking in java\";\n\t\t\n\t\tboolean starts = str.startsWith(\"thin\");\n\t\tSystem.out.println(starts);\n\n\t\tboolean ends= str.endsWith(\"ava\");\n\t\tSystem.out.println(ends);\n\t\t\n\t}\n}\n```\n\n\n\n# String\n&emsp;String是不变对象。JVM对String有一个优化，即:常量池,当使用字面量形式创建字符串对象时，JVM会将其缓存在常量池中，当再次使用该字面量创建字符串对象时即重用对象，避免内存中堆积大量内容一样的字符串对象，减少内存开销。\n\n```java\npublic class StringDemo {\n\tpublic static void main(String[] args) {\n\t\t//字面量  直接量\n\t\tString s1 = \"123abc\";\n\t\tString s2 = \"123abc\";\n\t\tString s3 = \"123abc\";\n\t\t//s2,s3重用了s1创建的对象\n\t\tSystem.out.println(s1==s2);\n\t\tSystem.out.println(s1==s3);\n\t\t/*\n\t\t * 字符串为不变对象\n\t\t * 即:字符串一旦创建，内容是不可以改变的，若想\n\t\t * 改变内容一定会创建新对象\n\t\t */\n\t\tSystem.out.println(s1);//123abc!\n\t\tSystem.out.println(s2);//123abc\n\t\tSystem.out.println(s1==s2);//不再相同\n\t\t\n\t\t/*\n\t\t * 这里发挥了编译器的一个特性:\n\t\t * 编译器在编译源代码时，若发现一个计算表达式\n\t\t * 参与运算的内容是确定值时，会在编译期间直接\n\t\t * 进行计算，并将计算结果编译到class文件中。避免\n\t\t * JVM每次执行程序时再做运算，从而提高性能。\n\t\t * 如下代码，编译器编译后改为了:\n\t\t * String s4 = \"123abc\";\n\t\t */\n\t\tString s4 = \"123\"+\"abc\";\n\t\tSystem.out.println(s4);//123abc\n\t\tSystem.out.println(s2==s4);//true\n\t\t\t\t\n\t\tString s5 = \"123\";\n\t\tString s6 = s5 + \"abc\";\n\t\tSystem.out.println(s6);//123abc\n\t\tSystem.out.println(s2==s6);//false\n\t}\n}\n\n```\n\n\n\n# substring\n&emsp;截取指定范围内的字符串 String substring(int start,int end)\n\n```java\npublic class SubStringDemo {\n\tpublic static void main(String[] args) {\n\t\t//            01234567890\n\t\tString str = \"www.tedu.cn\";\n\t\t/*\n\t\t * java api中有一个特点，通常使用两个数字表示\n\t\t * 范围时，都是\"含头不含尾\"的.\n\t\t */\n\t\tString sub = str.substring(4, 8);\n\t\tSystem.out.println(sub);//tedu\n\t\t/*\n\t\t * 一个参数的为从指定位置截取到字符串末尾\n\t\t */\n\t\tsub = str.substring(4);\n\t\tSystem.out.println(sub);\n\t\t\n\t}\n}\n```\n\n\n\n# ToUpperCase\n&emsp;将当前字符串中的英文部分转换为全大写或全小写\n\n```java\npublic class ToUpperCaseDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"我爱Java\";\n\t\t\n\t\tString upper = str.toUpperCase();\n\t\tSystem.out.println(upper);\n\t\t\n\t\tString lower = str.toLowerCase();\n\t\tSystem.out.println(lower);\n\t}\n}\n```\n\n\n\n\n# trim\n&emsp;去除当前字符串两边的空白字符\n\n```java\npublic class TrimDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"  hello\t\t\t\";\n\t\tString trim = str.trim();\n\t\tSystem.out.println(str);\n\t\tSystem.out.println(trim);\n\t}\n}\n\n```\n\n\n# valueOf\n&emsp;字符串提供了一组重载的valueOf方法。可以将其他类型转换为字符串\n\n```java\n\tpublic static void main(String[] args) {\n\t\tint d = 123;\n\t\tString str = String.valueOf(d);\n\t\tSystem.out.println(str);\n\t\t//任何内容和字符串连接结果也能转换为字符串\n\t\tstr = d + \"\";\n\t\tSystem.out.println(str);\n\t\t\n\t\tdouble dou = 123.123;\n\t\tString str2 = String.valueOf(dou);\n\t\tSystem.out.println(str2);\n\t}\n```\n\n\n\n\n# trim\n&emsp;去除当前字符串两边的空白字符\n\n```java\npublic class TrimDemo {\n\tpublic static void main(String[] args) {\n\t\tString str = \"  hello\t\t\t\";\n\t\tString trim = str.trim();\n\t\tSystem.out.println(str);\n\t\tSystem.out.println(trim);\n\t}\n}\n\n```\n\n\n\n\n# Matches\n&emsp;字符串支持正则表达式方法一: 使用给定的正则表达式验证当前字符串是否符合格式要求,符合则返回true。\n\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString email = \"fancq@tedu.cn\";\n\t\t/*\n\t\t * 邮箱的正则表达式\n\t\t * \\w+@[a-zA-Z0-9]+(\\.[a-zA-Z]+)+\n\t\t */\n\t\tString regex = \"\\\\w+@[a-zA-Z0-9]+(\\\\.[a-zA-Z]+)+\";\n\t\tboolean match = email.matches(regex);\n\t\tif(match) {\n\t\t\tSystem.out.println(\"是邮箱!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"不是邮箱!\");\n\t\t}\n\t}\n\n```\n\n# replaceAll\n&emsp;字符串支持正则表达式方法三:\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString str = \"abc123def456ghi\";\n\t\t/*\n\t\t * 将当前字符串中的数字部分替换为\"#NUMBER#\"\n\t\t */\n\t\tstr = str.replaceAll(\"\\\\d+\", \"#NUMBER#\");\n\t\tSystem.out.println(str);\n\t}\n```\n\n\n# Split\n&emsp; 字符串支持正则表达式方法二: 将当前字符串中按照满足正则表达式的部分进行拆分，并将拆分出的每部分以一个字符串数组形式返回。\n\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString str = \"abc123def456ghi\";\n\t\t/*\n\t\t * 按照数字部分拆分，得到所有的字母部分\n\t\t */\n\t\tString[] arr = str.split(\"[0-9]+\");\n\t\tSystem.out.println(arr.length);\n\t\tSystem.out.println(Arrays.toString(arr));\n\t\t\n\t\t/*\n\t\t * 如果连续匹配了两次要拆分的内容时，中间会拆分\n\t\t * 出一个空字符串，但是若在字符串末尾连续匹配则\n\t\t * 所有拆分出的空字符串都会被忽略。\n\t\t */\n\t\tstr = \"abc,,,def,ghi,,,,,,,,,,,,,,,,,,,\";\n\t\tarr = str.split(\",\");\n\t\tSystem.out.println(arr.length);\n\t\tSystem.out.println(Arrays.toString(arr));\n\n```\n\n\n\n\n# StringBuilder  \n\n1. StringBuilder是专门设计用来编辑字符串内容的API。由于String不适合频繁修改，所以在实际开发中如果有经常，修改字符串的操作时，可以使用StringBuilder来完成。\n2. StringBuilder内部维护一个可变的字符数组，所以修改的过程中资源开销小。并且提供了对应的操作:增，删，改，插\n\n\n```java\n\tpublic static void main(String[] args) {\n\t\tString str = \"好好学习java\";\n\t\t//默认方式创建内部表示一个空字符串:\"\"\n//\t\tStringBuilder builder = new StringBuilder();\n\t\t//创建时表示给定字符串内容\n\t\tStringBuffer builder = new StringBuffer(str);\n\t\t/*\n\t\t * 好好学习java\n\t\t * 好好学习java,为了找个好工作!\n\t\t * append:将指定内容追加到当前字符串末尾\n\t\t */\n\t\tbuilder.append(\",为了找个好工作!\");\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t\t\n\t\t/*\n\t\t * 好好学习java,为了找个好工作!\n\t\t * 好好学习java,就是为了改变世界!\n\t\t * replace:将指定范围内的字符串替换为给定内容\n\t\t */\n\t\tbuilder.replace(9, 16, \"就是为了改变世界\");\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t\t\n\t\t/*\n\t\t * 好好学习java,就是为了改变世界!\n\t\t * ,就是为了改变世界!\n\t\t * delete:删除指定范围内的字符串\n\t\t */\n\t\tbuilder.delete(0, 8);\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t\t\n\t\t/*\n\t\t * ,就是为了改变世界!\n\t\t * 活着,就是为了改变世界!\n\t\t * insert:将指定内容插入到指定位置\n\t\t */\n\t\tbuilder.insert(0, \"活着\");\n\t\tstr = builder.toString();\n\t\tSystem.out.println(str);\n\t}\n\n\n```\n\n\n\n\n# StringBuilder效率测试\n\n```java\n\tpublic static void main(String[] args) {\n\t\tStringBuilder builder = new StringBuilder(\"a\");\n\t\tfor(int i=0;i<10000000;i++) {\n\t\t\tbuilder.append(\"a\");\n\t\t}\n\t\tSystem.out.println(\"执行完毕!\");\n\t}\n```\n\n\n\n\n# 包装类\n&emsp;包装类是为了解决基本类型不能直接参与面向对象开发的问题，其中6个数字类型的包装类都继承自java.lang.Number。其余两个直接继承自Object，Number是一个抽象类，定义了数字类型包装类公有的行为，允许在数字类型之间互转。\n\n\n```java\n\t\tpublic static void main(String[] args) {\n\t\tint d = 128;\n//      将基本类型转换为包装类\n//\t\tInteger i1 = new Integer(d);\n//\t\tInteger i2 = new Integer(d);\n\t\t\n\t\t//从基本类型转换为包装类建议使用valueOf方法:\n\t\tInteger i1 = Integer.valueOf(d);\n\t\tInteger i2 = Integer.valueOf(d);\n\t\t\n\t\tSystem.out.println(i1==i2);//false\n\t\tSystem.out.println(i1.equals(i2));//true\n\t\t\n\t\tdouble dou = 1.0;\n\t\tDouble dou1 = Double.valueOf(dou);\n\t\tDouble dou2 = Double.valueOf(dou);\n\t\tSystem.out.println(dou1==dou2);\n\t\tSystem.out.println(dou1.equals(dou2));\n\t\t\n\t\t/*\n\t\t * 将包装类转换为基本类型\n\t\t */\n\t\t int in = i1.intValue();\n\t\t System.out.println(in);\n\t\t\n\t\t double dd = i1.doubleValue();\n\t\t System.out.println(dd);\n\t\t \n\t\t //可能出现溢出问题\n\t\t byte b = i1.byteValue();\n\t\t System.out.println(b);\n\t\t \n\t\t /*\n\t\t  * 数字类型的包装类都支持两个常量:\n\t\t  * MAX_VALUE,MIN_VALUE\n\t\t  * 用于表示其对应的基本类型数据的取值范围\n\t\t  */\n\t\t //int最大值与最小值?\n\t\t int imax = Integer.MAX_VALUE;\n\t\t System.out.println(imax);\n\t\t\n\t\t int imin = Integer.MIN_VALUE;\n\t\t System.out.println(imin);\n\t\t\n\t\t long lmax = Long.MAX_VALUE;\n\t\t System.out.println(lmax);\n        }\n}\n\n```\n  \n# Integer\n&emsp;JDK5发布时，推出了一个特性:自动拆装箱,允许编译器在编译源代码时将基本类型与引用类型之间互相,赋值时补全代码自动进行转换。\n\n```java\n\t\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 触发了编译器自动拆箱特性:\n\t\t * 编译器会将下面的代码改为\n\t\t * int d = new Integer(1).intValue();\n\t\t */\n\t\tint d = new Integer(1);\n\t\t/*\n\t\t * 触发了自动装箱特性:\n\t\t * 编译器会改为:\n\t\t * Integer i = Integer.valueOf(d);\n\t\t */\n\t\tInteger i = d;\n\t}\n\n```\n\n\n    \n# parse\n&emsp;包装类提供了一个静态方法:parseXXX(String str)，可以将给定的字符串转换为对应的基本类型，前提是该字符串，内容要正确的描述基本类型可以保存的值\n\n```java\n\t\tpublic static void main(String[] args) {\n\t\tString str = \"123\";\n\t\tint d = Integer.parseInt(str);\n\t\tSystem.out.println(d);\n\t\t\n\t\tdouble dou = Double.parseDouble(str);\n\t\tSystem.out.println(dou);\n\t}\n\n```\n\n\n    \n# Object常用方法\n&emsp;使用当前类测试Object常用方法:\n\n```java\n\tpublic class Point {\n\tprivate int x;\n\tprivate int y;\n\tpublic Point(int x, int y) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic int getX() {\n\t\treturn x;\n\t}\n\tpublic void setX(int x) {\n\t\tthis.x = x;\n\t}\n\tpublic int getY() {\n\t\treturn y;\n\t}\n\tpublic void setY(int y) {\n\t\tthis.y = y;\n\t}\n\t/**\n\t * 重写toString方法。\n\t * toString方法是一个非常常用的方法，很多API的操作\n\t * 都会间接调用该方法。\n\t * 方法的目的是将当前对象转换为字符串，具体返回的字符串\n\t * 格式没有固定要求，遵循的原则是返回的内容中包含当前\n\t * 对象的属性信息，可以通过该字符串的内容直观反应出当前\n\t * 对象的内容。\n\t */\n\tpublic String toString() {\n\t\t//(1,2)\n\t\treturn \"(\"+x+\",\"+y+\")\";\n\t}\n\t\n\t/**\n\t * Object定义的equals方法的设计意图是比较两个对象的\n\t * 内容是否相同。\n\t * 如果不重写该方法，那么Object内部是用\"==\"比较的，\n\t * 这样就失去了equals比较的意义了。所以当我们需要调用\n\t * 一个类的equals时，该方法就应当重写。\n\t * 注:java提供的类大部分都已经重写过了。只有我们自定义\n\t * 的类需要自行重写。\n\t * \n\t * p.equals(p2)\n\t * this:p\n\t * o:p2\n\t */\n\tpublic boolean equals(Object o) {\n\t\tif(o==null) {\n\t\t\treturn false;\n\t\t}\n\t\tif(this==o) {\n\t\t\treturn true;\n\t\t}\n\t\tif(o instanceof Point) {\n\t\t\tPoint p = (Point)o;\n\t\t\treturn this.x==p.x&&this.y==p.y;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n# 文件复制\n```java\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t//创建一个RAF用于读取原文件\n\t\tRandomAccessFile src\n\t\t\t= new RandomAccessFile(\"mv.mp4\",\"r\");\n\t\t\n\t\t//再创建另一个RAF用于向复制文件中写\n\t\tRandomAccessFile desc\n\t\t\t= new RandomAccessFile(\"mv_cp.mp4\",\"rw\");\n\t\t//用于记录每次读取到的字节\n\t\tint d = -1;\n\t\t/*\n\t\t * 循环从原文件中读取每一个字节，只要没有读取到\n\t\t * 文件末尾，就将读取到的字节写入到复制文件中。\n\t\t */\n\t\tlong start = System.currentTimeMillis();\n\t\twhile( (d = src.read())  != -1  ) {\n\t\t\tdesc.write(d);\n\t\t}\n\t\tlong end = System.currentTimeMillis();\n\t\tSystem.out.println(\"复制完毕!耗时:\"+(end-start)+\"ms\");\n\t\t\n\t\tsrc.close();\n\t\tdesc.close();\n\t}\n```\n\n\n#  java.io.RandomAccessFile类\n&emsp; 用来读写文件数据的类，其基于指针对文件数据进行读写操作\n\n```java\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t/*\n\t\t * RandomAccessFile创建有两种模式:\n\t\t * r:只读模式，只读取文件数据，并不会写入内容\n\t\t * rw:读写模式，对文件既可以读也可以写。\n\t\t * \n\t\t * 常见构造方法:\n\t\t * RandomAccessFile(String path,String mode)\n\t\t * RandomAccessFile(File file,String mode)\n\t\t * mode:创建的模式(r,rw)\n\t\t */\n\t\t/*\n\t\t * 对当前目录下的raf.dat文件进行读写操作\n\t\t * 对于\"rw\"模式创建时，若指定的文件不存在时会自动\n\t\t * 创建出来，若为\"r\"只读模式时，若指定的文件不存在\n\t\t * 则会直接抛出异常:FileNotFoundException\n\t\t */\n\t\tRandomAccessFile raf = new RandomAccessFile(\"raf.dat\",\"rw\");\t\n\t\t/*\n\t\t * void write(int d)\n\t\t * 向文件中写入1个字节，写入的是给定的int值对应的\n\t\t * 2进制的\"低八位\"\n\t\t *                            vvvvvvvv\n\t\t * 00000000 00000000 00000000 00000010\n\t\t * 00000000 00000000 00000000 11111111\n\t\t * 00000000 00000000 00000001 00000000\n\t\t * \n\t\t * 00000001 00000010\n\t\t */\n\t\traf.write(1);\n\t\traf.write(2);\n\t\tSystem.out.println(\"写出完毕!\");\n\t\t\n\t\traf.close();\n\t\t\n\t}\n\n\n```\n\n\n# 创建文件\n&emsp;使用File创建一个新文件\n\n```java\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t/*\n\t\t * 在当前目录下新建一个文件test.txt\n\t\t */\n\t\tFile file = new File(\"./test.txt\");\n\t\t//判断File表示的文件或目录是否已经真实存在了\n\t\tif(!file.exists()) {\n\t\t\t//将File表示的文件创建出来\n\t\t\tfile.createNewFile();\n\t\t\tSystem.out.println(\"文件创建成功!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"文件已存在!\");\n\t\t}\n\t}\n```\n\n\n# 删除文件\n&emsp;删除一个文件\n```java\n\t\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 删除当前目录下的test.txt\n\t\t * \"./\"可以忽略不写，默认就是当前目录\n\t\t */\n\t\tFile file = new File(\"test.txt\");\n\t\tif(file.exists()) {\n\t\t\tfile.delete();\n\t\t\tSystem.out.println(\"文件已删除!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"文件不存在!\");\n\t\t}\n\t}\n\n\n```\n\n# 创建目录\n&emsp;创建一个目录\n```java\n\t\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 在当前目录下新建一个目录:demo\n\t\t */\n\t\tFile dir = new File(\"demo\");\n\t\tif(!dir.exists()) {\n\t\t\t//创建该目录\n\t\t\tdir.mkdir();\n\t\t\tSystem.out.println(\"目录已创建!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"目录已存在!\");\n\t\t}\n\t}\n```\n\n# 创建多级目录\n&emsp;创建一个多级目录\n```java\n\tpublic static void main(String[] args) {\n\t\t/*\n\t\t *\t在当前目录下新建目录:\n\t\t *\t./a/b/c/d/e/f\n\t\t */\n\t\tFile dir = new File(\"./a/b/c/d/e/f\");\n\t\tif(!dir.exists()) {\n\t\t\t/*\n\t\t\t * mkdirs会将所有不存在的父目录一同创建出来\n\t\t\t */\n\t\t\tdir.mkdirs();\n\t\t\tSystem.out.println(\"目录已创建!\");\n\t\t}else {\n\t\t\tSystem.out.println(\"目录已存在!\");\n\t\t}\n    }\n```","tags":["基础知识"],"categories":["Java基础知识"]},{"title":"Http协议基础知识","url":"/2018/02/06/Http协议基础知识/","content":"\n# Http协议  \n\n## 什么是http协议\n当在上网浏览网页的时候，浏览器和服务器之间就会通过Http在Internet上进行数据的发送和接受。\nHTTP协议规定了浏览器和服务器之间通信的方式，也可以说是通信的规则。是应用层协议，是一个基于请求/响应模式的，无状态的协议。\n> 具体说，HTTP协议中主要规定了两个内容：\n    > 1. 规定了浏览器该如何给服务器发送请求信息（即请求信息的格式）\n    > 2. 同时也规定了服务器该如何给浏览器做响应信息（即响应信息的格式）   \n\n---\n\n## Http1.0\n> 当连接建立之后，浏览器发送一个请求，服务器回应一个消息，之后连接就被关闭。当浏览器下一次请求的时候，需要重新建立新的连接，显然这种需要不断建立连接的通信方式开销较大。早期的web页面通常只包含HTML文件，因此即使建立连接的开销比较大，也不会有太大的影响。而现在的web页面通常包含多种资源，（图片，动画，声音），每获取一种资源，就建立一次连接。这样就增加了HTTP服务器的开销，造成了Internet上的信息阻塞。\n---\n\n## Http1.1\n> 因此在Http1.1版本中，给出了一个持续连接的机制，并将其作为1.1中建立连接的缺省行为，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到响应，然后继续发送请求并在此得到回应，而且客户端还可以发送流水线请求，也就是说，客户端可以连续发送多个请求，而不用等待每一个响应的到来。\n---   \n\n## 三次握手\n>1. 客户端与服务器端建立连接前，客户端会向服务器发送第一条消息，询问服务器端是否准备好了。第一次握手\n>2. 服务器端收到客户端发来的询问之后，会给客户端发送一条消息，告诉客户端已经准备好了。第二次握手\n>3. 当客户端在收到服务器端发过来的消息之后，会在此确认，客户端会在向服务器发起响应确认准备好了，第三次握手。之后建立连接\n   \n---   \n\n## Http工作时遵循的基本原则(了解):\n> 1. 基于请求响应模型\n> 2. 一次请求只对应一次响应\n> 3. 只能是浏览器向服务器发送请求, 服务器只能等待浏览器的请求, 再根据请求做出回应\n--- \n\n## GET请求和POST请求方式的区别：\n两者之间的区别主要体现在请求参数发送过程的不相同\n> GET提交: 通过请求行拼接参数将数据发送给服务器\n    > &emsp;1.通过地址栏携带参数, 相对不安全\n    > &emsp;2.通过地址栏发送数据, 数据量不能太大(不能超过1kb或者是4kb);  \n\n> POST提交: 通过请求实体内容携带参数, 数据不会显示在地址栏\n    > &emsp;1.参数不会出现地址栏, 相对更安全\n    > &emsp;2.数据通过请求实体内容发送, 数据量理论上没有限制.\n---\n\n\n## 服务器种类：\n> Tomcat、Resin、Jetty、Weblogic、WebSphere、JBoss\n\n> B/S：Browser Server 浏览器服务器模型  （不需要下载客户端的） 京东、淘宝、网页游戏。\n> 优点：不需要下载客户端程序，使用浏览器可以直接访问，程序的升级操作是在服务器端进行的。\n> 缺点：浏览器具有一定的局限性，页面的展示差，页面的数据需要从服务器实时获取，对网速的依赖很高\n\n> C/S：Client Server客户端服务器模型       （需要下载客户端的） QQ  LOL 梦幻西游 。\n> 优点：客户端可以任意设计，页面的展示能力强。由于大量资源已经保存在了客户端，对服务器的交互仅仅是一些数据的变化，对于网速的依赖很低。\n> 缺点：第一次使用时需要下载客户端程序，一旦程序需要升级操作，所有的客户端程序都需要升级。\n---\n\n## XML解析方式：\n### DOM解析：\n>原理：\n\t> 解析器将整个xml文档加载进内存，保存为一颗Document的对象树，\n\t> 通过Document对象，得到树上的节点对象，对每个对象提供增删改查操作对应的方法\n>优点：\n\t> &emsp;1.可以十分方便对节点进行增删改查操作，\n\t> &emsp;2.解析一次即可重复使用数据由于在内存中保存了文档结构树，\n>缺点：\n\t> &emsp;1.如果文档较大，占用内存空间，甚至内存溢出\n\t> &emsp;2.将整个文档解析完才能操作，相对耗费时间，效率低\n   \n\n### SAX解析：\n> 原理：解析器逐行扫描xml文档，利用处理器接口中的方法进行解析\n> 优点：\n\t> &emsp;1.无需将整个xml文档加载到内存，占用内存小\n\t> &emsp;2.由于逐行解析，遇到需要内容停下来处理，效率高\n> 缺点：\n\t> &emsp;1.每次需要数据，都要重新解析\n    > &emsp;2.只能读取数据，不能做增删改操作。   \n\n---","tags":["基础知识"],"categories":["http基础知识"]},{"title":"Java基础知识总结","url":"/2018/02/01/Java基础知识总结/","content":"Java基础知识整理\n<!--more-->\n# 基础部分\n## Java编译运行过程\n1. 编译期：java源文件，经编译生成.class文件\n2. 运行期：JVM加载.class文件，并运行class\n3. 特点：跨平台，一次编译到处使用\n\n## 名词释义\n1. JVM：java虚拟机，作用就是加载.class文件，运行.class文件\n2. JRE： java开发环境，除了包含JVM外，还包含java程序运行所必须的环境\n3. JDK：java开发工具包，除了包含JRE外，还包含编译，运行等命令工具3. \n\n## 数据类型\n| **byte类型**     | **8位**  | **范围：-128~127**               |\n| ---------------- | -------- | --------------------------------|\n| **short 类型**   | **16位** | **范围：-32768~32767**           |\n| **char  类型**   | **16位** | **范围：\\u0000~\\u65535**         |\n| **int类型**      | **32位** | **范围：-2147483648~2147483647** |\n| **long 类型**    | **64位** | **范围：很大很大 2^63**           |\n| **float 类型**   | **32位** |                                  |\n| **double 类型**  | **64位** |                                  |\n| **boolean 类型** | **8位**  |                                  |\n\n\n## 基本类型自动转换\n1. 从小到大依次为：byte < short < int < long < float < double\n2. 自动类型转换：小类型转大类型 （小杯子往大杯子倒水）\n3. 强制类型转换：大类型转小类型 （大杯子往小杯子倒数）\n\n## 运算符\n1. 算数：    +，-，*，/，%，++，--\n2. 关系：>,<,>=,<=,==,!=,boolean\n3. 逻辑：&&，||，!boolean\n4. 赋值：=，+=，-=，*=，/=，%=\n5. 字符连接运算符：+\n6. 条件/三目运算：boolean?数1:数2;\n\n## 分支结构\n1. If\n2. If…else\n3. If…elss     if\n4. Switch…case\n\n## 循环\n1. while循环\n2. do...while循环\n3. for循环\n\n\n\n## 数组\n1. 数组的定义：int [ ] arr =new int [ 10 ] \n2. 数组的初始化：int [ ] arr = new int [ ] \n3. 数组的访问：通过数组名.length可以获取数组的长度，也就是数组内元素的个数通过索引来访问数组元素，下标从0开始，最大到数组长度-1\n4. 数组遍历\n   ```java\n   int[] arr = new int[10];\n   \n   for (int i = 0; i < arr.length; i++) {\n       arr[3] = (int) (Math.random() * 100);\n   }\n   \n   for (int i = 0; i < arr.length; i++) {\n       System.out.println(arr[i]);    //正序输出\n   }\n   \n   for (int i = arr.length - 1; i >= 0; i--) {\n       System.out.println(arr[i]);    //倒序输出\n   }\n   ```\n\n## 访问修饰符\n| **private**   | **同类可见**               | **可以修饰变量、方法**           | **注意：不能修饰类(外部类)** |\n| ------------- | -------------------------- | -------------------------------- | ---------------------------- |\n| **default**   | **同包同类可见**           | **可以修饰类、接口、变量、方法** |                              |\n| **protected** | **同包同类和所有子类可见** | **可以修饰变量、方法**           | **注意不能修饰类(外部类)**   |\n| **public**    | **所有类可见**             | **可以修饰类、接口、变量、方法** |                              |\n\n\n\n## 非访问修饰符\n&emsp;为了实现某一些功能，java也提供了许多非访问修饰符\n> static修饰符：\n   > 1. static关键字修饰的变量称之为静态变量，无论一个类实例化多少对象，他的静态变量只有唯一的一个。\n   > 2. static关键字修饰的方法称之为静态方法，静态方法只能使用类的静态变量，不可以使用非静态变量。\n\n> final修饰符：\n  > 1. Final关键字可以修饰类，表示不能有子类。\n  > 2. Final关键字可以修饰变量，表示变量不能被修改，只能有唯一一次赋值。\n  > 3. Final关键字可以修饰方法，表示不能被子类覆盖重写。\n  > 4. Final关键字修饰引用类型变量，地址值不能变，但是对象的属性可以通过set方法改变。\n\n> abstract修饰符：<font color=red>被abstract修饰的类和方法叫做抽象类和抽象方法</font>。\n  > 1. 抽象类：抽象类不能用来实例化对象，目的：是为了将来对该类进行扩充。\n  > 2. 抽象方法：继承抽象类的子类必须实现父类的所有抽象方法，除非这个子类也是抽象类，\n  > 3. 注意：如果一个类包含若干个抽象方法，那么该类必须声明为抽象类，抽象类不可以包含抽象方法。  \n\n> 抽象加单总结:\n  > 1. 抽象方法的意义：在于将方法的设计和方法的实现分离。\n  > 2. 抽象类需要被继承，抽象类定义的抽象方法子类必须重写。\n  > 3. 抽象类不能创建对象，但是可以包含构造方法，成员属性，普通方法。\n\n---\n\n# 内部类\n&emsp;一个事物的内部包含另外一个事物，就是一个类内部包含另外一个类，比如身体和心脏的关系，汽车和发动机的关系。\n> ## 成员内部类：\n > 定义在类里面的类，叫做成员内部类。\n > 使用成员内部类的两种方式:\n    > 1. 间接方式：在外部类的方法中，使用内部类，然后main只是调用外部类的方法。\n    > 2. 直接方式：外部类名称.内部类名称   \n    > 对象名 = new 外部类名称() . new 内部类名称(); (外部.内部)  \n\n> ## 局部内部类\n    > &emsp;定在在方法里面的类，叫做局部内部类，局部内部类包含了匿名内部类。  \n\n> ## 匿名内部类\n    > 作用：如果接口的实现类，或者是父类的子类，只需要使用唯一一次，那么这种情况下，就可以省略该类的定义，改用匿名内部类。\n    > 定义格式：接口名称  对象名 = new 接口名称(){ //方法体中重写所有的抽象方法 }； \n```java\npublic class MainDemo {\n    public static void main(String[] args) {\n        Myinterface myinterface = new Myinterface() {\n            @Override\n            public void method() {\n                System.out.println(\"匿名内部类方法执行\");\n            }\n        };\n        myinterface.method();\n    }\n}\n```\n---   \n\n# 面向对象\n## 什么是类？\n> 类是一个模板，包含对象的属性，方法。 \n> 我们把它理解为造汽车的图纸，图纸包含了制造汽车的各个部件的尺寸，参数等。\n\n## 什么是对象？\n> 对象是类的一个实例。\n> 我们可以对象理解为根据图纸制造出来的汽车。  \n\n## 类和对象之间的关系？  \n> 汽车就好比一个对象，图纸就好比是一个类，有了图纸才能设计出汽车，换而言之也就是有了类才能创建对象（也叫实例）。  \n\n## 面向对象的特征?\n> 记住并理解这重要的6个字，<font color=red>*封装、继承、多态*</font>&emsp;称之为面向对象的三大特征 。\n### 1. 封装  \n\n> #### 封装的概念：\n&emsp;面向对象的封装就是把描述一个对象的属性和行为的代码封装到一个类当中，属性用变量定义，行为用方法定义，然后运用访问修饰符，修饰成员变量及方法，就基本上实现了对象的封装。    \n        \n> #### 封装的好处：\n&emsp;封装的目标就是要实现软件内部的“高内聚、低耦合”，防止程序相互依赖而带来的变动的影响。解耦\n\n> #### 封装的总结：\n封装类，封装的就是对象的属性和行为。\n封装方法，封装的就是具体业务逻辑功能的实现。\n访问控制，访问修饰符（private、public....）用来封装具体的访问权限。\n\n### 2. 继承  \n> #### 封装的概念：\n&emsp; 继承也是泛化（抽取共性）的过程，在开发中我们先将子类共有的属性及方法全部抽取到父类，然后通过子类去继承父类的属性及方法实现数据和方法的共享，这是类之间的一种关系，<font color=red>继承的好处就是提高了代码的可重用性和扩展性</font>。\n\n\n### 3. 多态\n\n> #### 多态的概念\n&emsp; 一个对象拥有多种形态，这就是多态，代码体现多态其实就是一句话，<font color=red>父类引用指向子类对象</font>  \n\n> #### 多态的格式和使用\n  > 1. 父类名称  对象名称  =  new 子类名称（）；\n  > 2. 接口名称  对象名称  =  new 实现类名称（）；\n\n> #### 多态中访问成员变量的两种方式及规则\n  > 1. 直接通过对象名称访问成员变量：看等号左边是谁就优先用谁，没有则会往上寻找父类中是否存在该变量。\n  > 2. 间接通过成员方法访问成员变量：看该方法属于谁就优先用谁，没有则会往上寻找父类中是否存在该变量。\n\n> #### 多态中成员方法的访规则\n> 1. 看等号右边new的是谁，就优先用谁的方法。没有则会找到父类的方法。\n\n> #### 对比多态中成员变量和成员方法有何不同\n  > 1. 成员变量：编译看左边，运行还看左边\n  > 2. 成员方法：编译看左边，运行看右边。\n\n> #### 多态的好处\n  > &emsp; 比如Animal类有cat和dog两个子类，Animal有eat（）方法，cat和dog继承Animal也拥有了eat方法，但是狗和猫吃的东西不一样，有自己各自的方法。我们在写代码的时候  Animal  obj = new Dog();  并调用 obj.eat();  这里在编译时调用的时Animal类中的eat()方法，但是在程序运行的时候，会执行dog类中的eat()方法。new Cat();也是同理。这样就保证了等号左边的一致性，你new谁，在程序运行时，就调用谁的方法。一句话，编译看左边，运行看右边。<font color=red>多态的好处就是允许程序在运行的时候动态的创建对象，并调用对象的方法</font>。  \n\n> #### 对象向上转型\n  > &emsp; 父类引用指向子类对象。多态的写法就是向上转型。比如 将一个狗对象，当作父类动物对象来看待。    \n  > &emsp; 注意：向上转型的弊端，对象一旦向上转型为父类，那么就无法调用子类原本特有的方法。因为编译的时候根本无法通过对象点出来子类的方法，而只能调用父类的方法。\n\n> #### 对象的向下转型\n  > &emsp; 进行还原动作，比如你将一个子类对象向上转型为父类对象，你还可以将该对象转换回来，比如将狗的实例转为动物的实例，在将动物实例转换回狗的实例 　\n  > &emsp; Dog dog = (Dog) Animal();\n  > &emsp; 但是如果你在向下转型的过程中，向上转型为动物对象的狗对象还原为一个猫对象，那么就回报错。一定要注意，向下转型的时候对象的原本类型是什么，可以借助 instance of 关键字。\n> #### instance of \n  > &emsp;可以判断一个父类引用的对象，本来是什么子类。可以帮助我们在写代码的过程中，安全的向下转型。\n```java\npublic static void main(String[] args) {    \n        Animal animal = new Dog();\n        if(animal instanceof Dog){\n            Dog dog = (Dog) animal;\n            dog.eat();\n        }\n        if (animal instanceof Cat){\n            Cat cat = (Cat) animal;\n            cat.eat();\n        }     \n    }\n```  \n---  \n\n\n# 接口和抽象\n> ## 抽象类和抽象方法\n> 1. 抽象类不能直接new\n> 2. 必须需要子类实现抽象类\n> 3. 子类需要覆盖父类的抽象方法\n> 4. 创建子类进行使用  \n\n> 注意事项：\n> 1. 抽象类可以有构造函数，是供子类创建对象时，初始化父类成员使用的。\n> 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必须定义为抽象类。\n> 3. 抽象类的子类，必须重写子类中的所有抽象方法。否则编译报错。除非子类也是抽象类。  \n\n> ## 接口的概念\n    >&emsp;就是多个类的公共规范，接口是一种引用数据类型，最重要的内容就是其中的抽象方法（usb接口，插座）  \n\n> ## 接口的使用步骤\n> 1. 接口不能直接使用，必须有一个实现类来实现接口。\n> 2. 接口的实现类必须重写接口中所有的抽象方法\n> 3. 创建实现类对象，进行使用。\n> 注意事项：如果实现类并没有重写接口中的所有方法，那么这个实现类就必须是抽象类。   \n\n> ## 接口可以包含、常量、抽象方法、默认方法、静态方法、私有方法\n    > 1. <font color=red>默认方法：就是定义在接口中的静态方法。包含public default 方法名 { 方法体 }</font>。\n        > * 作用：可以解决接口升级的问题，因为接口中添加新的抽象方法，其实现类必须全部重写，\n        > * 注意：并且可以通过接口实现类对象直接调用，也可以被接口实现类覆盖重写。\n    > 2. <font color=red>静态方法：就是定义在接口中的静态方法。包含public static 方法名 { 方法体 }</font>。\n        > * 作用：不创建对象直接调用接口中的方法。静态方法和对象无关\n        > * 注意：不能通过接口实现类的对象来调用接口中的静态方法。而是直接用接口名称调用（一个类可以实现多个接口，多个接口中静态方法有可能产生冲突）（默认方法和静态方法只有在java 8会以上版本才支持）\n    > 3. <font color=red>私有方法：就是在接口中定义private关键字的方法，默认接口中方法必须是public的。（私有方法只有在java 9 或以上版本才支持）</font>\n        > * 普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名称（参数列表）{ 方法体 }\n        > * 静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名称（参数列表）{ 方法体 }\n        > * 作用：某些场景，我们需要在接口中抽取一个公有的方法，来解决两个或多个方法之间代码重复的问题，并规定只能在接口中调用，就可以通过私有方法来解决。  \n    > 4. <font color=red>常量：接口当中也可以定义“成员变量”</font>。\n        > * 类和类之间是单继承的，直接父类只有一个。\n        > * 类和接口之间是多实现的，一个接口可以实现（implements）多个接口，注意处理抽象方法的冲突问题就行。\n        > * 接口与接口之间是多继承的。就是一个接口可以继承（extends）多个接口，那么该接口就拥有了其他接口的全部抽象方法。  \n    > 5. <font color=red>注意事项（总结）</font>。\n        > *  接口不能有静态代码块或者构造方法。\n        > *  一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。\n        > *  如果实现类所实现的接口中，存在重复的抽象方法，那么只需要重写覆盖一次即可。\n        > *  如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类必须是一个抽象类。\n        > *  如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类必须冲突的默认方法进行重写。\n        > *  如果一个类的直接父类当中的方法，和接口当中的默认方法产生了冲突，会优先用父类的方法。（先继承，后实现的特点）。\n\n---\n\n# 内存管理\n> ## 堆\n    > 1. 堆中存储new出来的对象(包括实例变量)\n    > 2. 垃圾：没有任何引用所指向的对象，垃圾回收器(GC)不定时到内存中清扫垃圾，回收过程是透明的，调用System.gc()可以建议虚拟机尽快调度GC来回收\n    > 3. 内存泄漏:不再使用的内存还没有被及时的回收、建议:对象不再使用时及时将引用设置为null\n    > 4. 实例变量的生命周期：创建对象时存储在堆中，对象被回收时一并被回收  \n\n> ## 栈\n    > 1. 存储正在调用的方法中的局部变量(包括方法的参数)\n    > 2. 调用方法时，会在栈中为该方法分配一块对应的栈帧，栈帧中存储局部变量(包括方法的参数)，当方法执行结束后，栈帧被清除，局部变量一并失效\n    > 3. 局部变量的生命周期:调用方法时存储在栈中，方法结束时与栈帧一并被清除\n  \n> ## 方法区\n    > 1. 存储.class字节码文件(包括静态变量、方法)\n    > 2. 方法只有一份，通过this来区分具体的对象\n\n---\n\n\n# 集合总结  \n\n> ## 集合类的由来\n    >  &emsp;再开发过程中，我们一般用对象来封装特有数据，对象多了就需要存储，如果对象的个数不确定，就是用集合容器进行存储。  \n\n> ## 什么是集合\n\t>  &emsp;可以将集合理解为就是一个容器，因为面向对象编程会产生很多的对象，对了方便对对象的操作，所以把对象装入到集合，集合本身就是一个对象，能储存对象的对象就叫集合，存储对象的容器，就叫做集合，集合是可变长度的，数组不可变的。  \n\n> ## 集合的特点\n    >  &emsp;用于存储对象的容器，集合长度是可变的，集合中不可以存储基本数据类型值\n\n> ## 集合框架示意图\n![avatar](/images/collection.jpg)\n\n> ## Collection框架介绍\n    > &emsp;Collection是集合框架的顶级接口，Collections是是集合框架的工具类（提供集合共有的一些api）\n    > &emsp;Collection接口下有两个子接口，List接口和set接口，如上图  \n\n> ### List接口：有序可重复，存储对象有顺序，可以重复\n    > &emsp; Vector：最早的集合类，现在已经被ArrayList取代。底层也是数组\n    > &emsp; ArrayList：底层是数组，有序、可重复、有索引，异步线程不安全、特点：查找效率高，增删效率低\n    > &emsp; LinkedList：底层是双向链表，异步线程不安全，特点：增删效率高，查询效率低。不支持高效的随机元素访问。\n\n> ### Set接口：无序不可重复。不可存储重复对象，如果有重复，会覆盖。\n    > &emsp; TreeSet：底层是红黑树(自平衡的排序二叉树)，特点：有序，唯一 \n    > &emsp; hashSet：底层采用HashMap保存数据。特点：集合元素必须唯一，并且不可重复，无序的。\n    > &emsp; LinkHashSet：LinkHashSet继承HashSet，内部是通过LinkedHashMap实现。特点：集合元素必须唯一，并且不可重复，但是有序的。\n> ### Map集合：  \n\n> #### &emsp; map集合的特点:\n    > &emsp; map集合是一个双列集合，一个元素包含两个值，一个key，一个value\n    > &emsp; map集合中的元素，key和value的数据类型可以相同，也可以不同\n    > &emsp; map集合中的元素，key不允许重复，value可以重复\n    > &emsp; map集合中的元素，key和value是一一对应的关系。  \n\n> #### Map集合与collection集合的区别： \n    > &emsp; map集合中元素是成对存在的，每个元素由键与值两个部分组成的，通过键可以找到所对应的值，称之为双列集合。\n    > &emsp; collection集合中的元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储，称之为单列集合。  \n\n> #### Map集合常用子类：\n    > &emsp; HashMap：实现了Map接口，底层是哈希表。无序集合（存储元素和取出元素的顺序有可能不一致），异步多线程，查询的速度块，\n    > &emsp; LinkedHashMap：HashMap的子类，底层是哈希表+链表，是一个有序的集合，存取出元素的顺序是一直的，保证迭代的顺序。\n    > &emsp; HashTable：实现了Map接口，底层也是哈希表，不允许存储空key和value，线程安全的集合，速度慢，\n    > &emsp; properties：HashTable的子类，唯一一个和IO流相结合的集合  \n\n> #### HashMap底层原理\n    > &emsp; HashMap中维持了一个数组，数组的每一个位置称之为一个桶，每一个桶维持了一个链表，一个元素根据哈希吗进行运算，根据运算的结果平均的分配到这个桶中，放用到75%的桶的时候，会进行扩容，桶的数量会增加一倍，已有元素会重新计算哈希吗重新分布，这个过程称之为rehash，默认初始容量为16，即一开始有16个桶，当用到13个桶的时候要进行扩容。由16个桶扩容为32个桶，加载因子越大，碰撞概率越大，加载因子越小，扩容和rehash操作越频繁。  \n\n> #### HashMap 为什么速度快？\n    > &emsp; HashMap 之所以速度快，因为他使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）  \n    \n> #### hashcode为什么使用31来做相乘？\n    > &emsp; 之所以使用 31，是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代\t。替乘法，可以得到更好的性能： 31 * i == (i << 5） - i， 现代的 JVM 可以自动完成这种优化。这个公式可以很简单的推导出来  \n\n\n\n\n> ## 集合常见方法\n集合容器因为内部的数据结构不同，有多种具体容器，不断的向上抽取，就形成了集合框架，集合框架的顶层接口是collections，包含集合的共性方法\n> ### 常见方法：\n> 1. 添加 ：添加对象  boolean add（Object obj），boolean addAll\n> 2. 删除： boolean remove（object obj），boolean removeAll（object obj）\n> 3. 判断：boolean contains(Object obj），boolean containsAll(Boject ooll)，boolean ifEmpty\n> 4. 获取：int size()；获取集合元素集合的长度。\n\n> ## Iterator迭代器：\n> &emsp;专门取出集合中元素的方式，迭代器对象该对象必须依赖具体的容器，因为每一个容器的数据结构都不同，所以迭代器实在容器中进行内部实现的，对于适用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象就可以，也就是iterator方法   \n\n> ## 迭代器的实现原理：\n    > 迭代器就是实现了Iterator接口的每一个容器内部的内部对象\n    > 注意：在迭代器过程中，不要视同集合操作元素，容易出现异常，但是可以使用Iterator接口的子接口，ListIterator来完成在接待中对元素进行更多的操作，他可以实现在迭代过程中，完成对元素的增删改查，注意，只有list集合具备该迭代功能。   \n\n---\n\n# 线程总结  \n\n> ## 什么是进程？\n    > 计算机在执行的任务就是进程,比如JVM、QQ、微信、迅雷等服务本质上也是进程\n> ## 什么是线程？\n    > 进程中的小任务，多个小任务一起执行就是多线程 \n> ## 线程定义的三种方式\n    > 1. 继承Thread类，重写run()方法，将要执行的逻辑写入run方法，并调用start()方法\n    > 2. 实现Runable接口，重写run()方法，通过runnable对象来构建一个Thread对象来启动线程\n    > 3. 实现Callable<T>接口，重写call()方法.\n    > 4. 注意：为什么以上1、2两种方式都需要重写run方法？因为Thread类也实现了Runable接口。\n\n> ## api\n    > 1. Thread.currentThread().getName()获取线程的名字\n    > 2. Thread.seelp(毫秒值) 线程休息一会儿\n\n> ## 多线程的并发安全问题\n    > 线程的执行不存在先后，而是相互抢占执行，抢占并不是只发生在线程执行的开始，而是发生在线程执行的每一步过程中。由于多个线程并发导致出现一些不符合常理的数据现象---多线程并发安全问题\n\n> ## 同步代码块\n    > 同步代码块可以解决多线程并发安全问题,可以利用synchronize同步代码块来解决此问题\n    > synchronize需要指定锁对象,锁对象必须要求是这个类的所有线程都认识\n    > 共享资源，类的字节码、this（需要是同一个对象，一个对象启动四个线程）\n    > synchronize去修饰方法 ，同步方法的锁对象是this   \n\n> ## 什么是同步和异步\n    > 一段逻辑同一时间内只能一个线程执行，称之为反之叫做异步。\n    >  线程同步一定是安全的，而线程不安全一定是异步的。\n\n> ## 什么是死锁？如何解决死锁问题\n> 多个线程之间的锁形成了嵌套，导致程序无法继续运行的现象叫做死锁\n>  思考如何避免死锁？\n>  &emsp;1.减少线程数量  （理论上是可以，实际开发中不现实）。\n>  &emsp;2.统一锁对象     \n>  &emsp;3.减少锁嵌套\n\n\n> ## 线程的状态\n> 1. 创建状态\n> 2. 就绪状态\n> 3. 执行状态\n> 4. 阻塞状态 / 挂起状态   （人为阻塞 冻结状态）    \n> 5. 消亡状态\n \n> ## Sleep和wait有什么区别：\n> sleep在使用的时候需要指定休眠时间，到点自然醒。释放执行权，不释放锁。是一个静态方法，设计在了Thread类上。wait在使用的时候可以指定等待时间，也可以不指定，如果不指定等待时间就需要唤醒，释放执行权，释放锁，是一个非静态方法，设计在了Object类上。\n\n> ## 守护线程：\n> 守护别的线程，当被守护的线程结束，守护线程无论执行完成与否都得随之结束。 Daemon\n> 一个线程要么是守护线程要么是被守护的线程\n> 守护线程是随着最后一个被守护线程的结束而结束。   --GC就是一个守护线程。\n\n> ## 线程的优先级\n> 线程的优先级。1-10个等级   没有手动设置的情况下优先级默认是5。\n> 理论上数字越大等级越高，这个线程抢到资源的几率越大，相邻的两个线程的优先级的差异性不明显，至少要相差5个等级才能体现的相对明显\n","tags":["基础知识"],"categories":["Java基础知识"]}]