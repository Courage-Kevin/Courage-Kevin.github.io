[{"title":"Java基础知识总结","url":"/2018/02/05/Java基础知识总结/","content":"Java基础知识整理\n<!--more-->\n# 基础部分\n## Java编译运行过程\n1. 编译期：java源文件，经编译生成.class文件\n2. 运行期：JVM加载.class文件，并运行class\n3. 特点：跨平台，一次编译到处使用\n\n## 名词释义\n1. JVM：java虚拟机，作用就是加载.class文件，运行.class文件\n2. JRE： java开发环境，除了包含JVM外，还包含java程序运行所必须的环境\n3. JDK：java开发工具包，除了包含JRE外，还包含编译，运行等命令工具3. \n\n## 数据类型\n| **byte类型**     | **8位**  | **范围：-128~127**               |\n| ---------------- | -------- | --------------------------------|\n| **short 类型**   | **16位** | **范围：-32768~32767**           |\n| **char  类型**   | **16位** | **范围：\\u0000~\\u65535**         |\n| **int类型**      | **32位** | **范围：-2147483648~2147483647** |\n| **long 类型**    | **64位** | **范围：很大很大 2^63**           |\n| **float 类型**   | **32位** |                                  |\n| **double 类型**  | **64位** |                                  |\n| **boolean 类型** | **8位**  |                                  |\n\n\n## 基本类型自动转换\n1. 从小到大依次为：byte < short < int < long < float < double\n2. 自动类型转换：小类型转大类型 （小杯子往大杯子倒水）\n3. 强制类型转换：大类型转小类型 （大杯子往小杯子倒数）\n\n## 运算符\n1. 算数：    +，-，*，/，%，++，--\n2. 关系：>,<,>=,<=,==,!=,boolean\n3. 逻辑：&&，||，!boolean\n4. 赋值：=，+=，-=，*=，/=，%=\n5. 字符连接运算符：+\n6. 条件/三目运算：boolean?数1:数2;\n\n## 分支结构\n1. If\n2. If…else\n3. If…elss     if\n4. Switch…case\n\n## 循环\n1. while循环\n2. do...while循环\n3. for循环\n\n\n\n## 数组\n1. 数组的定义：int [ ] arr =new int [ 10 ] \n2. 数组的初始化：int [ ] arr = new int [ ] \n3. 数组的访问：通过数组名.length可以获取数组的长度，也就是数组内元素的个数通过索引来访问数组元素，下标从0开始，最大到数组长度-1\n4. 数组遍历\n   ```java\n   int[] arr = new int[10];\n   \n   for (int i = 0; i < arr.length; i++) {\n       arr[3] = (int) (Math.random() * 100);\n   }\n   \n   for (int i = 0; i < arr.length; i++) {\n       System.out.println(arr[i]);    //正序输出\n   }\n   \n   for (int i = arr.length - 1; i >= 0; i--) {\n       System.out.println(arr[i]);    //倒序输出\n   }\n   ```\n\n## 访问修饰符\n| **private**   | **同类可见**               | **可以修饰变量、方法**           | **注意：不能修饰类(外部类)** |\n| ------------- | -------------------------- | -------------------------------- | ---------------------------- |\n| **default**   | **同包同类可见**           | **可以修饰类、接口、变量、方法** |                              |\n| **protected** | **同包同类和所有子类可见** | **可以修饰变量、方法**           | **注意不能修饰类(外部类)**   |\n| **public**    | **所有类可见**             | **可以修饰类、接口、变量、方法** |                              |\n\n\n\n## 非访问修饰符\n&emsp;为了实现某一些功能，java也提供了许多非访问修饰符\n> static修饰符：\n   > 1. static关键字修饰的变量称之为静态变量，无论一个类实例化多少对象，他的静态变量只有唯一的一个。\n   > 2. static关键字修饰的方法称之为静态方法，静态方法只能使用类的静态变量，不可以使用非静态变量。\n\n> final修饰符：\n  > 1. Final关键字可以修饰类，表示不能有子类。\n  > 2. Final关键字可以修饰变量，表示变量不能被修改，只能有唯一一次赋值。\n  > 3. Final关键字可以修饰方法，表示不能被子类覆盖重写。\n  > 4. Final关键字修饰引用类型变量，地址值不能变，但是对象的属性可以通过set方法改变。\n\n> abstract修饰符：<font color=red>被abstract修饰的类和方法叫做抽象类和抽象方法</font>。\n  > 1. 抽象类：抽象类不能用来实例化对象，目的：是为了将来对该类进行扩充。\n  > 2. 抽象方法：继承抽象类的子类必须实现父类的所有抽象方法，除非这个子类也是抽象类，\n  > 3. 注意：如果一个类包含若干个抽象方法，那么该类必须声明为抽象类，抽象类不可以包含抽象方法。  \n\n> 抽象加单总结:\n  > 1. 抽象方法的意义：在于将方法的设计和方法的实现分离。\n  > 2. 抽象类需要被继承，抽象类定义的抽象方法子类必须重写。\n  > 3. 抽象类不能创建对象，但是可以包含构造方法，成员属性，普通方法。\n\n---\n\n# 内部类\n&emsp;一个事物的内部包含另外一个事物，就是一个类内部包含另外一个类，比如身体和心脏的关系，汽车和发动机的关系。\n> ## 成员内部类：\n > 定义在类里面的类，叫做成员内部类。\n > 使用成员内部类的两种方式:\n    > 1. 间接方式：在外部类的方法中，使用内部类，然后main只是调用外部类的方法。\n    > 2. 直接方式：外部类名称.内部类名称   \n    > 对象名 = new 外部类名称() . new 内部类名称(); (外部.内部)  \n\n> ## 局部内部类\n    > &emsp;定在在方法里面的类，叫做局部内部类，局部内部类包含了匿名内部类。  \n\n> ## 匿名内部类\n    > 作用：如果接口的实现类，或者是父类的子类，只需要使用唯一一次，那么这种情况下，就可以省略该类的定义，改用匿名内部类。\n    > 定义格式：接口名称  对象名 = new 接口名称(){ //方法体中重写所有的抽象方法 }； \n```java\npublic class MainDemo {\n    public static void main(String[] args) {\n        Myinterface myinterface = new Myinterface() {\n            @Override\n            public void method() {\n                System.out.println(\"匿名内部类方法执行\");\n            }\n        };\n        myinterface.method();\n    }\n}\n```\n---   \n\n# 面向对象\n## 什么是类？\n> 类是一个模板，包含对象的属性，方法。 \n> 我们把它理解为造汽车的图纸，图纸包含了制造汽车的各个部件的尺寸，参数等。\n\n## 什么是对象？\n> 对象是类的一个实例。\n> 我们可以对象理解为根据图纸制造出来的汽车。  \n\n## 类和对象之间的关系？  \n> 汽车就好比一个对象，图纸就好比是一个类，有了图纸才能设计出汽车，换而言之也就是有了类才能创建对象（也叫实例）。  \n\n\n## 面向对象的特征?\n> 记住并理解这重要的6个字，<font color=red>*封装、继承、多态*</font>&emsp;称之为面向对象的三大特征 。\n### 1. 封装  \n\n> #### 封装的概念：\n&emsp;面向对象的封装就是把描述一个对象的属性和行为的代码封装到一个类当中，属性用变量定义，行为用方法定义，然后运用访问修饰符，修饰成员变量及方法，就基本上实现了对象的封装。    \n        \n> #### 封装的好处：\n&emsp;封装的目标就是要实现软件内部的“高内聚、低耦合”，防止程序相互依赖而带来的变动的影响。解耦\n\n> #### 封装的总结：\n封装类，封装的就是对象的属性和行为。\n封装方法，封装的就是具体业务逻辑功能的实现。\n访问控制，访问修饰符（private、public....）用来封装具体的访问权限。\n\n### 2. 继承  \n> #### 封装的概念：\n&emsp; 继承也是泛化（抽取共性）的过程，在开发中我们先将子类共有的属性及方法全部抽取到父类，然后通过子类去继承父类的属性及方法实现数据和方法的共享，这是类之间的一种关系，<font color=red>继承的好处就是提高了代码的可重用性和扩展性</font>。\n\n\n### 3. 多态\n\n> #### 多态的概念\n&emsp; 一个对象拥有多种形态，这就是多态，代码体现多态其实就是一句话，<font color=red>父类引用指向子类对象</font>  \n\n> #### 多态的格式和使用\n  > 1. 父类名称  对象名称  =  new 子类名称（）；\n  > 2. 接口名称  对象名称  =  new 实现类名称（）；\n\n> #### 多态中访问成员变量的两种方式及规则\n  > 1. 直接通过对象名称访问成员变量：看等号左边是谁就优先用谁，没有则会往上寻找父类中是否存在该变量。\n  > 2. 间接通过成员方法访问成员变量：看该方法属于谁就优先用谁，没有则会往上寻找父类中是否存在该变量。\n\n> #### 多态中成员方法的访规则\n> 1. 看等号右边new的是谁，就优先用谁的方法。没有则会找到父类的方法。\n\n> #### 对比多态中成员变量和成员方法有何不同\n  > 1. 成员变量：编译看左边，运行还看左边\n  > 2. 成员方法：编译看左边，运行看右边。\n\n> #### 多态的好处\n  > &emsp; 比如Animal类有cat和dog两个子类，Animal有eat（）方法，cat和dog继承Animal也拥有了eat方法，但是狗和猫吃的东西不一样，有自己各自的方法。我们在写代码的时候  Animal  obj = new Dog();  并调用 obj.eat();  这里在编译时调用的时Animal类中的eat()方法，但是在程序运行的时候，会执行dog类中的eat()方法。new Cat();也是同理。这样就保证了等号左边的一致性，你new谁，在程序运行时，就调用谁的方法。一句话，编译看左边，运行看右边。<font color=red>多态的好处就是允许程序在运行的时候动态的创建对象，并调用对象的方法</font>。  \n\n> #### 对象向上转型\n  > &emsp; 父类引用指向子类对象。多态的写法就是向上转型。比如 将一个狗对象，当作父类动物对象来看待。    \n  > &emsp; 注意：向上转型的弊端，对象一旦向上转型为父类，那么就无法调用子类原本特有的方法。因为编译的时候根本无法通过对象点出来子类的方法，而只能调用父类的方法。\n\n> #### 对象的向下转型\n  > &emsp; 进行还原动作，比如你将一个子类对象向上转型为父类对象，你还可以将该对象转换回来，比如将狗的实例转为动物的实例，在将动物实例转换回狗的实例 　\n  > &emsp; Dog dog = (Dog) Animal();\n  > &emsp; 但是如果你在向下转型的过程中，向上转型为动物对象的狗对象还原为一个猫对象，那么就回报错。一定要注意，向下转型的时候对象的原本类型是什么，可以借助 instance of 关键字。\n> #### instance of \n  > &emsp;可以判断一个父类引用的对象，本来是什么子类。可以帮助我们在写代码的过程中，安全的向下转型。\n```java\npublic static void main(String[] args) {    \n        Animal animal = new Dog();\n        if(animal instanceof Dog){\n            Dog dog = (Dog) animal;\n            dog.eat();\n        }\n        if (animal instanceof Cat){\n            Cat cat = (Cat) animal;\n            cat.eat();\n        }     \n    }\n```  \n---   \n\n# 接口和抽象\n> ## 抽象类和抽象方法\n> 1. 抽象类不能直接new\n> 2. 必须需要子类实现抽象类\n> 3. 子类需要覆盖父类的抽象方法\n> 4. 创建子类进行使用  \n\n> 注意事项：\n> 1. 抽象类可以有构造函数，是供子类创建对象时，初始化父类成员使用的。\n> 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必须定义为抽象类。\n> 3. 抽象类的子类，必须重写子类中的所有抽象方法。否则编译报错。除非子类也是抽象类。  \n\n> ## 接口的概念\n    >&emsp;就是多个类的公共规范，接口是一种引用数据类型，最重要的内容就是其中的抽象方法（usb接口，插座）  \n\n> ## 接口的使用步骤\n> 1. 接口不能直接使用，必须有一个实现类来实现接口。\n> 2. 接口的实现类必须重写接口中所有的抽象方法\n> 3. 创建实现类对象，进行使用。\n> 注意事项：如果实现类并没有重写接口中的所有方法，那么这个实现类就必须是抽象类。   \n\n> ## 接口可以包含、常量、抽象方法、默认方法、静态方法、私有方法\n    > 1. <font color=red>默认方法：就是定义在接口中的静态方法。包含public default 方法名 { 方法体 }</font>。\n        > * 作用：可以解决接口升级的问题，因为接口中添加新的抽象方法，其实现类必须全部重写，\n        > * 注意：并且可以通过接口实现类对象直接调用，也可以被接口实现类覆盖重写。\n    > 2. <font color=red>静态方法：就是定义在接口中的静态方法。包含public static 方法名 { 方法体 }</font>。\n        > * 作用：不创建对象直接调用接口中的方法。静态方法和对象无关\n        > * 注意：不能通过接口实现类的对象来调用接口中的静态方法。而是直接用接口名称调用（一个类可以实现多个接口，多个接口中静态方法有可能产生冲突）（默认方法和静态方法只有在java 8会以上版本才支持）\n    > 3. <font color=red>私有方法：就是在接口中定义private关键字的方法，默认接口中方法必须是public的。（私有方法只有在java 9 或以上版本才支持）</font>\n        > * 普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名称（参数列表）{ 方法体 }\n        > * 静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名称（参数列表）{ 方法体 }\n        > * 作用：某些场景，我们需要在接口中抽取一个公有的方法，来解决两个或多个方法之间代码重复的问题，并规定只能在接口中调用，就可以通过私有方法来解决。  \n    > 4. <font color=red>常量：接口当中也可以定义“成员变量”</font>。\n        > * 类和类之间是单继承的，直接父类只有一个。\n        > * 类和接口之间是多实现的，一个接口可以实现（implements）多个接口，注意处理抽象方法的冲突问题就行。\n        > * 接口与接口之间是多继承的。就是一个接口可以继承（extends）多个接口，那么该接口就拥有了其他接口的全部抽象方法。  \n    > 5. <font color=red>注意事项（总结）</font>。\n        > *  接口不能有静态代码块或者构造方法。\n        > *  一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。\n        > *  如果实现类所实现的接口中，存在重复的抽象方法，那么只需要重写覆盖一次即可。\n        > *  如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类必须是一个抽象类。\n        > *  如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类必须冲突的默认方法进行重写。\n        > *  如果一个类的直接父类当中的方法，和接口当中的默认方法产生了冲突，会优先用父类的方法。（先继承，后实现的特点）。\n\n---\n\n# 内存管理\n> ## 堆\n    > 1. &emsp;堆中存储new出来的对象(包括实例变量)\n    > 2. &emsp;垃圾：没有任何引用所指向的对象，垃圾回收器(GC)不定时到内存中清扫垃圾，回收过程是透明的，调用System.gc()可以建议虚拟机尽快调度GC来回收\n    > 3. &emsp;内存泄漏:不再使用的内存还没有被及时的回收、建议:对象不再使用时及时将引用设置为null\n    > 4. &emsp;实例变量的生命周期：创建对象时存储在堆中，对象被回收时一并被回收  \n\n> ## 栈\n    > 1. &emsp;存储正在调用的方法中的局部变量(包括方法的参数)\n    > 2. &emsp;调用方法时，会在栈中为该方法分配一块对应的栈帧，栈帧中存储局部变量(包括方法的参数)，当方法执行结束后，栈帧被清除，局部变量一并失效\n    > 3. &emsp;局部变量的生命周期:调用方法时存储在栈中，方法结束时与栈帧一并被清除\n  \n> ## 方法区\n    > 1. &emsp;存储.class字节码文件(包括静态变量、方法)\n    > 2. &emsp;方法只有一份，通过this来区分具体的对象\n\n---\n\n\n# 集合总结  \n\n> ## 集合类的由来\n    >  &emsp;再开发过程中，我们一般用对象来封装特有数据，对象多了就需要存储，如果对象的个数不确定，就是用集合容器进行存储。  \n\n> ## 什么是集合\n\t>  &emsp;可以将集合理解为就是一个容器，因为面向对象编程会产生很多的对象，对了方便对对象的操作，所以把对象装入到集合，集合本身就是一个对象，能储存对象的对象就叫集合，存储对象的容器，就叫做集合，集合是可变长度的，数组不可变的。  \n\n> ## 集合的特点\n    >  &emsp;用于存储对象的容器，集合长度是可变的，集合中不可以存储基本数据类型值\n\n> ## 集合框架示意图\n![avatar](/images/collection.jpg)\n\n> ## Collection框架介绍\n    > &emsp;Collection是集合框架的顶级接口，Collections是是集合框架的工具类（提供集合共有的一些api）\n    > &emsp;Collection接口下有两个子接口，List接口和set接口，如上图  \n\n> ### List接口：有序可重复，存储对象有顺序，可以重复\n    > &emsp; Vector：最早的集合类，现在已经被ArrayList取代。底层也是数组\n    > &emsp; ArrayList：底层是数组，有序、可重复、有索引，异步线程不安全、特点：查找效率高，增删效率低\n    > &emsp; LinkedList：底层是双向链表，异步线程不安全，特点：增删效率高，查询效率低。不支持高效的随机元素访问。\n\n> ### Set接口：无序不可重复。不可存储重复对象，如果有重复，会覆盖。\n    > &emsp; TreeSet：底层是红黑树(自平衡的排序二叉树)，特点：有序，唯一 \n    > &emsp; hashSet：底层采用HashMap保存数据。特点：集合元素必须唯一，并且不可重复，无序的。\n    > &emsp; LinkHashSet：LinkHashSet继承HashSet，内部是通过LinkedHashMap实现。特点：集合元素必须唯一，并且不可重复，但是有序的。\n> ### Map集合：  \n\n> #### &emsp; map集合的特点:\n    > &emsp; map集合是一个双列集合，一个元素包含两个值，一个key，一个value\n    > &emsp; map集合中的元素，key和value的数据类型可以相同，也可以不同\n    > &emsp; map集合中的元素，key不允许重复，value可以重复\n    > &emsp; map集合中的元素，key和value是一一对应的关系。  \n\n> #### Map集合与collection集合的区别： \n    > &emsp; map集合中元素是成对存在的，每个元素由键与值两个部分组成的，通过键可以找到所对应的值，称之为双列集合。\n    > &emsp; collection集合中的元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储，称之为单列集合。  \n\n> #### Map集合常用子类：\n    > &emsp; HashMap：实现了Map接口，底层是哈希表。无序集合（存储元素和取出元素的顺序有可能不一致），异步多线程，查询的速度块，\n    > &emsp; LinkedHashMap：HashMap的子类，底层是哈希表+链表，是一个有序的集合，存取出元素的顺序是一直的，保证迭代的顺序。\n    > &emsp; HashTable：实现了Map接口，底层也是哈希表，不允许存储空key和value，线程安全的集合，速度慢，\n    > &emsp; properties：HashTable的子类，唯一一个和IO流相结合的集合  \n\n> #### HashMap底层原理\n    > &emsp; HashMap中维持了一个数组，数组的每一个位置称之为一个桶，每一个桶维持了一个链表，一个元素根据哈希吗进行运算，根据运算的结果平均的分配到这个桶中，放用到75%的桶的时候，会进行扩容，桶的数量会增加一倍，已有元素会重新计算哈希吗重新分布，这个过程称之为rehash，默认初始容量为16，即一开始有16个桶，当用到13个桶的时候要进行扩容。由16个桶扩容为32个桶，加载因子越大，碰撞概率越大，加载因子越小，扩容和rehash操作越频繁。  \n\n> #### HashMap 为什么速度快？\n    > &emsp;HashMap 之所以速度快，因为他使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）  \n    \n> #### hashcode为什么使用31来做相乘？\n    > &emsp; 之所以使用 31， 是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代\t。替乘法，可以得到更好的性能： 31 * i == (i << 5） - i， 现代的 JVM 可以自动完成这种优化。这个公式可以很简单的推导出来  \n\n\n\n\n> ## 集合常见方法\n集合容器因为内部的数据结构不同，有多种具体容器，不断的向上抽取，就形成了集合框架，集合框架的顶层接口是collections，包含集合的共性方法\n> ### 常见方法：\n>1. 添加 ：添加对象  boolean add（Object obj），boolean addAll\n>2. 删除： boolean remove（object obj），boolean removeAll（object obj）\n>3. 判断：boolean contains(Object obj），boolean containsAll(Boject ooll)，boolean ifEmpty\n>4. 获取：int size()；获取集合元素集合的长度。\n\n> ## Iterator迭代器：\n> &emsp;专门取出集合中元素的方式，迭代器对象该对象必须依赖具体的容器，因为每一个容器的数据结构都不同，所以迭代器实在容器中进行内部实现的，对于适用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象就可以，也就是iterator方法   \n\n> ## 迭代器的实现原理：\n    > 迭代器就是实现了Iterator接口的每一个容器内部的内部对象\n    > 注意：在迭代器过程中，不要视同集合操作元素，容易出现异常，但是可以使用Iterator接口的子接口，ListIterator来完成在接待中对元素进行更多的操作，他可以实现在迭代过程中，完成对元素的增删改查，注意，只有list集合具备该迭代功能。   \n\n---\n\n# 线程总结\n\n### 待更新....睡觉了。","tags":["基础知识"],"categories":["Java基础知识"]}]