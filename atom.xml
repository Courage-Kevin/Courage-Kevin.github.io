<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Courage-Kevin 个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://courage-kevin.github.io/"/>
  <updated>2020-02-24T14:00:07.052Z</updated>
  <id>https://courage-kevin.github.io/</id>
  
  <author>
    <name>Courage-Kevin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序开发</title>
    <link href="https://courage-kevin.github.io/2020/02/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>https://courage-kevin.github.io/2020/02/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</id>
    <published>2020-02-24T13:58:58.000Z</published>
    <updated>2020-02-24T14:00:07.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><h3 id="wxecce373e86f54d1e"><a href="#wxecce373e86f54d1e" class="headerlink" title="wxecce373e86f54d1e"></a>wxecce373e86f54d1e</h3><h3 id="891c8c73ae3e3b6c7992ecc7161d6e38"><a href="#891c8c73ae3e3b6c7992ecc7161d6e38" class="headerlink" title="891c8c73ae3e3b6c7992ecc7161d6e38"></a>891c8c73ae3e3b6c7992ecc7161d6e38</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;微信小程序&quot;&gt;&lt;a href=&quot;#微信小程序&quot; class=&quot;headerlink&quot; title=&quot;微信小程序&quot;&gt;&lt;/a&gt;微信小程序&lt;/h2&gt;&lt;h3 id=&quot;wxecce373e86f54d1e&quot;&gt;&lt;a href=&quot;#wxecce373e86f54d1e&quot; cla
      
    
    </summary>
    
    
    
      <category term="小程序" scheme="https://courage-kevin.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>常用命令大全</title>
    <link href="https://courage-kevin.github.io/2020/02/06/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>https://courage-kevin.github.io/2020/02/06/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2020-02-06T12:49:18.000Z</published>
    <updated>2020-02-06T13:21:14.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx命令"><a href="#Nginx命令" class="headerlink" title="Nginx命令"></a>Nginx命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">说明:Nginx命令需要在nginx.exe文件所在位置运行。</span><br><span class="line"></span><br><span class="line">start nginx  启动</span><br><span class="line">nginx -s reload 重启</span><br><span class="line">nginx -s stop   nginx停止</span><br></pre></td></tr></table></figure><p><font color=red size=2>Nginx命令结束</font></p><hr><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="cd命令集"><a href="#cd命令集" class="headerlink" title="cd命令集"></a>cd命令集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd命令是linux中最基本的命令语句，必须熟练掌握</span><br><span class="line"></span><br><span class="line">cd &#x2F;        返回根目录</span><br><span class="line">cd ~        用户主目录</span><br><span class="line">cd .        当前目录</span><br><span class="line">cd ..       返回到上一级目录</span><br><span class="line">cd &#x2F;usr&#x2F;    进入到usr目录</span><br><span class="line">cd –        返回上一个目录</span><br><span class="line">cd          直接回家</span><br></pre></td></tr></table></figure><h2 id="ls目录和文件"><a href="#ls目录和文件" class="headerlink" title="ls目录和文件"></a>ls目录和文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls –l       详细格式，文件权限，时间</span><br><span class="line">ll          和ls –l作用相同</span><br><span class="line">ls *.txt    查看所有的txt类型文档</span><br></pre></td></tr></table></figure><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir 创建目录</span><br><span class="line">mkdir a 创建 a目录</span><br><span class="line">mkdir -p a&#x2F;b 创建 a目录，并在a目录里创建b目录</span><br><span class="line">mkdir -m 777 c 创建一个权限为777的C目录</span><br><span class="line">rmdir  删除目录（如果目录里有文件，则不能用此命令）</span><br></pre></td></tr></table></figure><h2 id="vi创建-查看-编辑文件"><a href="#vi创建-查看-编辑文件" class="headerlink" title="vi创建/查看/编辑文件"></a>vi创建/查看/编辑文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">命令行：Esc切换到命令行模式。</span><br><span class="line">编辑模式：</span><br><span class="line">按i，在光标前开始编辑</span><br><span class="line">按a，在光标后开始编辑</span><br><span class="line">按o，在当前行的下一行开始编辑</span><br><span class="line">底行模式：按  shift+：冒号。</span><br><span class="line">:q! 不保存退出</span><br><span class="line">:wq 保存退出</span><br><span class="line">:&#x2F;world 从当前光标处，向上查找world关键字</span><br><span class="line">:?world 从当前光标处，向后查找world关键字</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm 删除文件</span><br><span class="line">rm n.txt 提示y删除n放弃</span><br><span class="line">rm –f n.txt 不提示</span><br><span class="line">rm –rf dirname 不提示递归删除目录下所以内容</span><br><span class="line">rm –rf * 删除所有文件</span><br><span class="line">rm –rf &#x2F;* 删除所有子目录所有和文件</span><br></pre></td></tr></table></figure><h2 id="复制和移动文件"><a href="#复制和移动文件" class="headerlink" title="复制和移动文件"></a>复制和移动文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp复制文件</span><br><span class="line"></span><br><span class="line">cp nginx.conf n.txt</span><br><span class="line">cp –R tomcat1 tomcat2      #复制整个目录</span><br><span class="line">mv  修改文件名，移动文件</span><br><span class="line">mv  n.txt m.txt</span><br></pre></td></tr></table></figure><h2 id="浏览文件"><a href="#浏览文件" class="headerlink" title="浏览文件"></a>浏览文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat                 输出文件所有的内容</span><br><span class="line">more                输出文档所有的内容，分页输出，空格浏览下一屏，q退出</span><br><span class="line">less                用法和more相同，只是通过PgUp、PgOn键来控制</span><br><span class="line">tail                用于显示文件后几号，使用频繁</span><br><span class="line">tail -10 nginx.conf 查看nginx.conf的最后10行</span><br><span class="line">tail –f nginx.conf  动态查看日志，方便查看日志新增的信息</span><br><span class="line">ctrl+c              结束查看</span><br></pre></td></tr></table></figure><h2 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tar命令位于&#x2F;bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成name.tar.gz的文件。</span><br><span class="line">-c 创建一个新的tar文件</span><br><span class="line">-v 显示运行过程的信息</span><br><span class="line">-f 指定文件名</span><br><span class="line">-z 调用gzip压缩命令进行压缩</span><br><span class="line">-t 查看压缩文件的内容</span><br><span class="line">-x 解开tar文件</span><br><span class="line">tar –cvf n.tar .&#x2F;*      压缩当前目录下的所有文件和目录，文件名为n.tar</span><br><span class="line">tar –xvf n.tar          解压压缩包中的文件到当前目录（如果长时间未解压成功 Ctrl+C推出）</span><br><span class="line">tar –cvzf m.tar .&#x2F;*     解压m.tar文件到当前目录</span><br></pre></td></tr></table></figure><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep root  &#x2F;etc&#x2F;passwd                  在文件中查找关键字root</span><br><span class="line">grep root  &#x2F;etc&#x2F;passwd  –-color         高亮显示</span><br><span class="line">grep root  &#x2F;etc&#x2F;passwd  –A5 –B5         高亮显示，A后5行，B前5行</span><br><span class="line">grep -n root &#x2F;etc&#x2F;passwd                查找并显示行数</span><br><span class="line">grep -v root &#x2F;etc&#x2F;passwd                 取反，查出不含root的数据</span><br></pre></td></tr></table></figure><h2 id="Linux防火墙"><a href="#Linux防火墙" class="headerlink" title="Linux防火墙"></a>Linux防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop       临时关闭</span><br><span class="line">service iptables start      临时开启</span><br><span class="line">chkconfig iptables on       永久开启</span><br><span class="line">chkconfig iptables off      永久关闭</span><br></pre></td></tr></table></figure><h2 id="查看安装版本及卸载mysql"><a href="#查看安装版本及卸载mysql" class="headerlink" title="查看安装版本及卸载mysql"></a>查看安装版本及卸载mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep -i mysql</span><br></pre></td></tr></table></figure><h2 id="linux下查看mysql安装版本及卸载mysql"><a href="#linux下查看mysql安装版本及卸载mysql" class="headerlink" title="linux下查看mysql安装版本及卸载mysql"></a>linux下查看mysql安装版本及卸载mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep -i mysql</span><br></pre></td></tr></table></figure><p><font color=red size=2>linux命令结束</font></p><hr><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><h2 id="Redis解压安装指令"><a href="#Redis解压安装指令" class="headerlink" title="Redis解压安装指令"></a>Redis解压安装指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make            解压完之后需要mke编译redis</span><br><span class="line">Make install    编译完之后需要Make install 安装redis</span><br></pre></td></tr></table></figure><h2 id="Redis基本命令"><a href="#Redis基本命令" class="headerlink" title="Redis基本命令"></a>Redis基本命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf   启动命令:  </span><br><span class="line">redis-cli -p 端口         进入客户端: </span><br><span class="line">exit                      退出客户端</span><br></pre></td></tr></table></figure><h2 id="编辑redis-conf"><a href="#编辑redis-conf" class="headerlink" title="编辑redis.conf"></a>编辑redis.conf</h2><blockquote><ol><li>注释IP绑定   61行附近</li><li>关闭保护模式  80行附近</li><li>开启后台启动 128行附近</li></ol></blockquote><p><font color=red size=2>Redis命令结束</font></p><hr><h1 id="Mysql命令"><a href="#Mysql命令" class="headerlink" title="Mysql命令"></a>Mysql命令</h1><h2 id="启动Mysql"><a href="#启动Mysql" class="headerlink" title="启动Mysql"></a>启动Mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service mysql start   启动命令</span><br><span class="line">service mysql stop    停止命令</span><br><span class="line">service mysql restart 重启命令</span><br></pre></td></tr></table></figure><h2 id="开放Mysql对外权限"><a href="#开放Mysql对外权限" class="headerlink" title="开放Mysql对外权限"></a>开放Mysql对外权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grant [权限] on [数据库名].[表名] to [&#39;用户名&#39;]@[&#39;web服务器的ip地址&#39;] identified by [&#39;密码&#39;];</span><br><span class="line"></span><br><span class="line">grant all on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39;;</span><br><span class="line"></span><br><span class="line">或者指定IP地址</span><br><span class="line">grant all on *.* to &#39;root&#39;@&#39;192.168.1.103&#39; identified by &#39;root&#39;;</span><br></pre></td></tr></table></figure><h2 id="配置主库配置文件"><a href="#配置主库配置文件" class="headerlink" title="配置主库配置文件"></a>配置主库配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编辑文件:</span><br><span class="line">vim &#x2F;etc&#x2F;my.cnf</span><br></pre></td></tr></table></figure><h2 id="搭建数据库主从的命令及步骤"><a href="#搭建数据库主从的命令及步骤" class="headerlink" title="搭建数据库主从的命令及步骤"></a>搭建数据库主从的命令及步骤</h2><h3 id="查看主库状态-操作的是主库"><a href="#查看主库状态-操作的是主库" class="headerlink" title="查看主库状态(操作的是主库)"></a>查看主库状态(操作的是主库)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure><h3 id="设置从库连接主库IP地址-端口-二进制文件-操作的是从库"><a href="#设置从库连接主库IP地址-端口-二进制文件-操作的是从库" class="headerlink" title="设置从库连接主库IP地址/端口/二进制文件 (操作的是从库)"></a>设置从库连接主库IP地址/端口/二进制文件 (操作的是从库)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&quot;192.168.186.132&quot;,</span><br><span class="line">MASTER_PORT&#x3D;3306,</span><br><span class="line">MASTER_USER&#x3D;&quot;root&quot;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&quot;root&quot;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&quot;mysql-bin.000001&quot;,</span><br><span class="line">MASTER_LOG_POS&#x3D;120</span><br></pre></td></tr></table></figure><h3 id="开启主从服务-操作的是从库"><a href="#开启主从服务-操作的是从库" class="headerlink" title="开启主从服务(操作的是从库)"></a>开启主从服务(操作的是从库)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure><h3 id="查看主从同步状态-操作的是从库"><a href="#查看主从同步状态-操作的是从库" class="headerlink" title="查看主从同步状态(操作的是从库)"></a>查看主从同步状态(操作的是从库)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW SLAVE STATUS;成功数据表中会显示两个yes</span><br></pre></td></tr></table></figure><h3 id="如果报错了可以断开-重新执行上面的操作"><a href="#如果报错了可以断开-重新执行上面的操作" class="headerlink" title="如果报错了可以断开,重新执行上面的操作"></a>如果报错了可以断开,重新执行上面的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave  关闭主从服务</span><br></pre></td></tr></table></figure><h2 id="amoeba"><a href="#amoeba" class="headerlink" title="amoeba"></a>amoeba</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;launcher  启动命令   </span><br><span class="line"></span><br><span class="line">如果搭建一主多从需要直接克隆 需要进入&#x2F;var&#x2F;lib&#x2F;mysql&#x2F; 更改auto的server-uuid  序列号。</span><br></pre></td></tr></table></figure><p><font color=red size=2>mysql命令结束</font></p><hr><h1 id="Mycat命令"><a href="#Mycat命令" class="headerlink" title="Mycat命令"></a>Mycat命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;mycat start       启动</span><br><span class="line">.&#x2F;mycat stop        停止</span><br><span class="line">.&#x2F;mycat restart     重启</span><br><span class="line">.&#x2F;mycat status      检测状态</span><br><span class="line">.&#x2F;mycat dump        临时存储</span><br></pre></td></tr></table></figure><p><font color=red size=2 >mycat命令结束</font></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx命令&quot;&gt;&lt;a href=&quot;#Nginx命令&quot; class=&quot;headerlink&quot; title=&quot;Nginx命令&quot;&gt;&lt;/a&gt;Nginx命令&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="常用命令" scheme="https://courage-kevin.github.io/categories/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="常用命令" scheme="https://courage-kevin.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>SSO单点登录</title>
    <link href="https://courage-kevin.github.io/2020/02/06/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://courage-kevin.github.io/2020/02/06/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2020-02-06T12:21:00.000Z</published>
    <updated>2020-02-06T12:32:52.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><h2 id="没有单点登录存在的问题"><a href="#没有单点登录存在的问题" class="headerlink" title="没有单点登录存在的问题"></a>没有单点登录存在的问题</h2><blockquote><p>在分布式项目中，我们通常会使用Nginx来分发客户请求，从而更好缓解请求对服务器的压力。通过Nginx做负载均衡后，用户的每次请求都会发往不同的服务器。如果采用Session保存用户信息，则可能导致用户登陆多次，这样友好性差。  </p></blockquote><blockquote><p>如何解决这个问题呢？ 我们可以使用单点登录这个技术。实现单点登录的方式有很多，这里只说下利用redis实现单点登录。</p></blockquote><h2 id="实现SSO方式-Redis"><a href="#实现SSO方式-Redis" class="headerlink" title="实现SSO方式-Redis"></a>实现SSO方式-Redis</h2><blockquote><ol><li>用户进行登录操作时，输入用户名和密码.</li><li>JT-WEB服务器接收用户请求时.利用httpClient技术，将用户信息发送给JT-SSO单点登录系统.</li><li>JT-SSO单点登录系统接收前台数据之后进行校验.如果用户名和密码不正确，直接提示返回。如果用户名和密码正确，首先生成加密的秘钥token，之后将user转化为JSON数据，保存到Redis中，之后将token数据返回给JT-WEB服务器.</li><li>JT-WEB接收JT-SSO单点登录系统的返回值数据.如果用户名密码不正确则友好提示给用户.</li><li>如果用户名和密码正确，将token数据保存到用户浏览器的Cookie中。</li></ol></blockquote><p><img src="/images/sso.png" alt="avatar"></p><h1 id="单点登录流程"><a href="#单点登录流程" class="headerlink" title="单点登录流程:"></a>单点登录流程:</h1><blockquote><ol><li>发送用户请求， 用户将用户名及密码发送至前台服务器 </li><li>前台服务器利用httpClent向后台SSO服务器发起请求，后台SSO服务器会对用户信息进行校验， </li><li>SSO服务器接收前台数据后进行校验，如果用户名密码不正确，直接提示返回， </li><li>如果正确生成秘钥并将user转化为JSON数据，保存到token中，将token返回给前台服务器. </li><li>前台服务器接收SSO的返回值数据没如果用户名密码不正确则友好提示用户 </li><li>如果用户名密码正确，将token数据保存到用户浏览器的Cookie中</li><li>任何一台服务器都能访问Redis，通过redis通过token， 缓存有数据，放行， 缓存没有重新登录</li></ol></blockquote><blockquote><p>为什么存在Cookie中 ， 如果客户第二次发起请求，首先前台会判断用户是否登录，因为Cookie中，任何一个前台服务器都能接受用户请求，并且能获取到Cookie信息，拿到Cookie就能拿到最重要的Token数据。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单点登录&quot;&gt;&lt;a href=&quot;#单点登录&quot; class=&quot;headerlink&quot; title=&quot;单点登录&quot;&gt;&lt;/a&gt;单点登录&lt;/h1&gt;&lt;h2 id=&quot;没有单点登录存在的问题&quot;&gt;&lt;a href=&quot;#没有单点登录存在的问题&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://courage-kevin.github.io/categories/JavaWeb/"/>
    
    
      <category term="SSO单点登录" scheme="https://courage-kevin.github.io/tags/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础知识</title>
    <link href="https://courage-kevin.github.io/2020/02/06/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://courage-kevin.github.io/2020/02/06/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-06T11:32:12.000Z</published>
    <updated>2020-02-06T12:10:53.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis官方简介"><a href="#Redis官方简介" class="headerlink" title="Redis官方简介"></a>Redis官方简介</h2><blockquote><p>Redis是一个开源（BSD许可），采用key-value结构进行数据存储，用作数据库，缓存和消息队列。它支持数据结构，如字符串，散列，列表，集合，带有范围查询的排序集，位图，超级日志，具有半径查询和流的地理空间索引。Redis具有内置复制，Lua脚本，LRU算法，事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用性并使用Redis Cluster自动分区。</p></blockquote><h2 id="人话版什么是Redis"><a href="#人话版什么是Redis" class="headerlink" title="人话版什么是Redis"></a>人话版什么是Redis</h2><blockquote><ol><li>Redis就是一个数据库软件，作用是存储数据的。</li><li>Redis是一个开源的，基于K-V进行存储的内存型数据库，可以用作数据库，缓存，和消息队列。</li><li>Redis是一个Nosql（没有sql）非关系型数据库。</li><li>Redis读写效率高，平均每秒10万读写。</li><li>Redis支持丰富的数据类型String、Hash 、LIST 、Set 、SortedSet 有序集合。</li><li>Redis中操作可以添加事务的支持。</li></ol></blockquote><h2 id="应用的一些场景"><a href="#应用的一些场景" class="headerlink" title="应用的一些场景"></a>应用的一些场景</h2><blockquote><p>比如京东前端页面，基本上都是查询的操作，涉及到删除，更新，添加的操作，用户一般涉及不到后端管理这一块的操作，所以我们只需要吧这些常用的查询数据存储到NoSQL数据库中，客户端可以直接请求NoSQL数据库，如果NoSQL数据库中没有用户需要的数据，就会到关系型数据库中去查找，如果查询到，就会将关系型数据库中的数据，在添加到NoSQL数据库，从而提升性能。</p></blockquote><h2 id="Redis-持久化策略-RDB模式和AOF模式"><a href="#Redis-持久化策略-RDB模式和AOF模式" class="headerlink" title="Redis 持久化策略 RDB模式和AOF模式"></a>Redis 持久化策略 RDB模式和AOF模式</h2><h3 id="什么是RDB模式"><a href="#什么是RDB模式" class="headerlink" title="什么是RDB模式"></a>什么是RDB模式</h3><p>RDB模式是通过保存数据库中的键值对来记录数据库的状态 ，每隔一段时间就会将数据写入(Snapshot)快照， 恢复时在将快照文件直接读到内存里。</p><blockquote><p>优点:</p><ol><li>RDB备份效率是最高的.  </li><li>RDB是一个非常紧凑(compact)的文件，它保存了redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。</li><li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li><li>持久化文件大小可以控制.  </li></ol></blockquote><blockquote><p>缺点:</p><ol><li>RDB方式数据没办法做到实时持久化/秒级持久化。如果需要持久化 ， 我们可以手动执行save或者BGsave命令 ， 频繁执行成本过高.</li><li>RDB文件使用特定二进制格式保存，Redis版本迭代过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题</li><li>数据过于集中，所有数据都存储到一个文件中 ，一定时间内做一次备份，如果redis意外挂掉的话，就会丢失最后一次快照后的所有修改(数据有丢失)</li><li>Redis作为数据库或者或者队列时不要使用RDB模式.  </li></ol></blockquote><h3 id="什么是AOF模式"><a href="#什么是AOF模式" class="headerlink" title="什么是AOF模式"></a>什么是AOF模式</h3><p> AOF 是通过保存Redis服务器所执行的写命令来记录数据库状态， (set，sadd，lpush 三个命令保存到 AOF 文件中)。</p><blockquote><p>优点:</p><ol><li>监听Redis的日志文件，监听如果发现执行了修改，删除，新增命令，立即根据这条命令把数据持久化，</li><li>AOF持久化方法提供多种的同步频率，默认是每秒同步一次 ， 可以保证数据的准确性. </li></ol></blockquote><blockquote><p>缺点:</p><ol><li>对于具有相同数据的的 Redis，AOF 文件通常会比 RDF 文件体积更大。</li><li>虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。</li><li>AOF只是每次将执行命令追加到AOF文件中，RDB是用快照的形式来持久化整个Redis数据，理论上来讲，RDB模式比AOF模式更加健壮，并且AOF好像有一些BUG  </li></ol></blockquote><blockquote><p>AOF如何恢复数据:   重启 Redis 之后就会进行 AOF 文件的载入。异常修复命令：redis-check-aof –fix 进行修复</p></blockquote><h3 id="AOF-和-RDB-两种持久化方式，我们应该如何选择呢？"><a href="#AOF-和-RDB-两种持久化方式，我们应该如何选择呢？" class="headerlink" title="AOF 和 RDB 两种持久化方式，我们应该如何选择呢？"></a>AOF 和 RDB 两种持久化方式，我们应该如何选择呢？</h3><blockquote><p>如果可以接受小时间内的数据丢失，使用RDB肯定是最好的选择，定时生成快照，便于数据库备份.并且RDB模式恢复数据集的速度比AOF模式恢复的速度要快，RDB还可以避免AOF一些隐藏的BUG.否则就用AOF重写.一般情况下不建议单独使用某一种持久化机制，应该两者结合使用.</p></blockquote><h2 id="Redis的回收策略（淘汰策略）"><a href="#Redis的回收策略（淘汰策略）" class="headerlink" title="Redis的回收策略（淘汰策略）"></a>Redis的回收策略（淘汰策略）</h2><blockquote><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰  </li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰  </li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰  </li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰  </li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 </li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol></blockquote><h2 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis-主从复制"></a>Redis-主从复制</h2><blockquote><p>在不设置主从复制的情况下，我们对数据的操作都是在一台Redis服务器上进行操作的，也就是说读和写以及备份操作都是在一台Redis服务器上进行的，那么随着项目访问量的增加，对Redis服务器的操作也越加频繁，虽然Redis读写速度都很快，但是一定程度上也会造成一定的延时，那么为了解决访问量大的问题，通常会采取的一种方式是主从架构Master/Slave，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机Slave 节点。</p></blockquote><h2 id="Redis分片技术-主要实现扩容"><a href="#Redis分片技术-主要实现扩容" class="headerlink" title="Redis分片技术(主要实现扩容)"></a>Redis分片技术(主要实现扩容)</h2><blockquote><ul><li>思考：单台redis中使用的内存大小有限，默认的内存的大小为10M，如果使用时内存不足，如何处理?</li><li>解决：采用分片方式 ， 准备多台redis.实现内存扩容.</li><li>Redis分片的缺点:</li></ul><ol><li>安全性不好，用户可以利用客户端直接set操作，修改数据。</li><li>由于单调性的要求，节点只能增，不能减，如果redis节点宕机，整合服务不能运行. 分片没有实现高可用。</li></ol></blockquote><h3 id="Hash一致性"><a href="#Hash一致性" class="headerlink" title="Hash一致性"></a>Hash一致性</h3><blockquote><p>   角色: node(节点)   key<br>   内存:  node*n 实现内存扩容.<br><img src="/images/redishash.png" alt="avatar"></p></blockquote><h3 id="均衡性"><a href="#均衡性" class="headerlink" title="均衡性"></a>均衡性</h3><blockquote><p>说明:尽可能的让节点均匀的保存数据.<br>问题:如果没有均衡性算法，则会导致数据负载不均.<br>解决方法:引入虚拟节点的概念.通过虚拟节点动态的平衡数据.<br><img src="/images/%E5%9D%87%E8%A1%A1%E6%80%A7.png" alt="avatar"></p></blockquote><h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><blockquote><p>说明:当节点新增时，节点信息会动态的划分，实现数据的挂载.<br>原则:如果节点新增时，尽肯能的保证原有的数据保持不变!只平衡部分数据.<br>单调性中描述节点只能新增，不能减少，如果节点个数少了.则内存缺失.分片不能使用.</p></blockquote><h2 id="Redis-哨兵机制总结-主要实现高可用"><a href="#Redis-哨兵机制总结-主要实现高可用" class="headerlink" title="Redis-哨兵机制总结(主要实现高可用)"></a>Redis-哨兵机制总结(主要实现高可用)</h2><blockquote><ol><li>前提:数据必须同步，搭建redis主从.</li><li>哨兵只会监听主机的状态，通过心跳机制进行检测 ping-pong。</li><li>当哨兵发现主机3次都没有响应时，这时认为主机宕机.内部进行推选。</li><li>当哨兵通过读取主机的配置文件，发现当前的主机中有2个从机.所以哨兵推选一台从机当做现在的主节点。</li><li>当哨兵成功推选了从机当主节点时.哨兵会修改另外节点的配置文件.重新定义主从结构。</li></ol></blockquote><blockquote><p>基于Redis主从复制这一机制，存在一个问题，因为主节点Master只有一个，一旦主节点挂掉之后，从节点没法担起主节点的任务，那么整个也无法运行。如果主节点挂掉之后，从节点能够自动变成主节点，那么问题就解决了，于是哨兵模式诞生了。哨兵模式就是不定时的用过心跳检测机制，对redis进行监控，若一台主机出现问题时，哨兵会自动将该主机下的某一个从机设置为新的主，、，并让其他从机和新主机建立主从关系。(内部是用的投票机制)</p></blockquote><blockquote><p>PS：哨兵模式也存在单点故障问题，如果哨兵机器挂了，那么就无法进行监控了，解决办法是哨兵也建立集群，Redis哨兵模式是支持集群的。</p></blockquote><h2 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h2><blockquote><h3 id="为什么要搭建Redis集群"><a href="#为什么要搭建Redis集群" class="headerlink" title="为什么要搭建Redis集群?"></a>为什么要搭建Redis集群?</h3><p>分析: Redis分片主要的功能实现redis内存扩容，哨兵主要实现了redis的高可用，而使用redis集群实现分片和哨兵的全部的功能。</p></blockquote><blockquote><h3 id="脑裂现象"><a href="#脑裂现象" class="headerlink" title="脑裂现象 :"></a>脑裂现象 :</h3><p>由于在集群/推选机制中，长时间出现平票的结果.则容易出现脑裂的现象.从而导致整个推选机制出现问题(脑袋炸裂)<br>如何降低此现象的发生 : 增加主节点的数量!!  主节点的数量一般大于等于7</p></blockquote><blockquote><h3 id="Redis集群高可用推选原理"><a href="#Redis集群高可用推选原理" class="headerlink" title="Redis集群高可用推选原理"></a>Redis集群高可用推选原理</h3><ol><li>redis所有的节点都会保存redis集群中的全部主从状态信息，</li><li>子节点之间可以互相通信，如果某个节点宕机，则其他节点会通过ping-pang检测机制检查该节点是否宕机。</li><li>如果有一半的节点认为宕机，则认为主节点宕机，剩余的节点会进行推选，投票推选出链接主节点的从机，实现故障的迁移。</li></ol></blockquote><h2 id="缓存三大问题"><a href="#缓存三大问题" class="headerlink" title="缓存三大问题"></a>缓存三大问题</h2><h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><blockquote><ul><li>条件:访问一个不存在的数据</li><li>说明:当访问一个不存在的数据时，因为缓存中没有这个key，导致缓存形同虚设.最终访问后台数据库.但是数据库中没有该数据所以返回null.</li><li>隐患:如果有人恶意频繁查询一个不存在的数据，可能会导致数据库负载高导致宕机。</li><li>总结:业务系统访问一个不存在的数据，称之为缓存穿透。</li></ul></blockquote><h3 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h3><blockquote><ul><li>条件:当缓存key失效/过期/未命中时，高并发访问该key。</li><li>说明:如果给一个key设定了失效时间，当key失效时有一万的并发请求访问这个key，这时缓存失效，所有的请求都会访问后台数据库.称之为缓击穿。</li><li>场景:微博热点消息访问量很大，如果该缓存失效则会直接访问后台数据库，导致数据库负载过高。  </li></ul></blockquote><h3 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h3><blockquote><ul><li>前提:高并发访问，缓存命中较低或者失效时。</li><li>说明:假设缓存都设定了失效时间，在同一时间内缓存大量失效，如果这时用户高并发访问，缓存命中率过低，导致全部的用户访问都会访问后台真实的数据库.</li><li>场景:在高并发条件下，缓存动态更新时。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;Redis官方简介&quot;&gt;&lt;a href=&quot;#Redis官方简介&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Redis基础知识" scheme="https://courage-kevin.github.io/categories/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://courage-kevin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="redis" scheme="https://courage-kevin.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库高可用</title>
    <link href="https://courage-kevin.github.io/2020/02/06/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>https://courage-kevin.github.io/2020/02/06/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%8F%AF%E7%94%A8/</id>
    <published>2020-02-06T10:43:25.458Z</published>
    <updated>2020-02-06T11:31:01.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库备份策略"><a href="#数据库备份策略" class="headerlink" title="数据库备份策略"></a>数据库备份策略</h1><h2 id="冷备份策略"><a href="#冷备份策略" class="headerlink" title="冷备份策略"></a>冷备份策略</h2><blockquote><p>说明：定期将数据库文件进行转储.<br>缺点：<br>&emsp;1.数据库冷备份，则需要手动的人工完成.效率低<br>&emsp;2.定期数据备份，不能保证数据的安全的.仅仅能够恢复部分数据<br>&emsp;3.如果数据量比较庞大，导入导出时耗费的时间较多<br>&emsp;4.由于网络传输问题.可能会导致备份多次<br>优点：数据库冷备份是恢复数据最后有效的手段.</p></blockquote><h2 id="热备份策略"><a href="#热备份策略" class="headerlink" title="热备份策略"></a>热备份策略</h2><blockquote><p>说明： 当主数据库数据进行”更新”操作时，数据会自动的同步到slave(从数据库中)该操作可以实现数据实时备份。<br><img src="/images/databasecopy.jpg" alt="avatar"></p></blockquote><h2 id="数据备份原理"><a href="#数据备份原理" class="headerlink" title="数据备份原理"></a>数据备份原理</h2><blockquote><ol><li>当数据库主库发生数据改变时，会将改变的数据写入二进制日志文件中(主库)。</li><li>从库中会启动IO线程会实时的监控主库的二进制文件是否发生改变.如果主库的二进制改变了，则将改变的数据进行读取.读取之后，将二进制内容写入中继日志中。</li><li>从库会启动Sql线程.会读取中继日志中的消息，将它写入数据库中，最终实现数据同步。</li></ol></blockquote><h2 id="数据库双机热备"><a href="#数据库双机热备" class="headerlink" title="数据库双机热备"></a>数据库双机热备</h2><blockquote><p>  根据数据库主从的配置.当主数据库做更新操作时，从库复制备份数据.当主库宕机时，通过某些技术手段可以数据库的高可用，实现故障迁移.当用户再有写入操作时，应该将数据写入从库中.如果主库修复完成重启数据库时，主库发现从库的数据较多.则数据库备份将失效.最终导致数据不一致的问题.</p></blockquote><h3 id="双机热备意义"><a href="#双机热备意义" class="headerlink" title="双机热备意义"></a>双机热备意义</h3><blockquote><p>说明：实现数据库双机热备是实现高可用的前提，如果数据不同步则无法实现数据库高可用.一般公司都有自己的运维团队.所以负责java开发的程序员不需要手动的配置数据库主从.但是需要了解mysql数据备份策略.为以后转岗做准备。</p></blockquote><h2 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h2><h3 id="Amoeba"><a href="#Amoeba" class="headerlink" title="Amoeba"></a>Amoeba</h3><blockquote><h4 id="什么是amoeba"><a href="#什么是amoeba" class="headerlink" title="什么是amoeba?"></a>什么是amoeba?</h4><p>Amoeba是一个以MySQL为底层数据存储，并对应用提供MySQL协议接口的proxy。它集中地响应应用的请求，依据用户事先设置的规则，将SQL请求发送到特定的数据库上执行。基于此可以实现负载均衡、读写分离、高可用性等需求。与MySQL官方的MySQL Proxy相比，作者强调的是amoeba配置的方便（基于XML的配置文件，用SQLJEP语法书写规则，比基于lua脚本的MySQL Proxy简单）。</p></blockquote><blockquote><p>Amoeba相当于一个SQL请求的路由器，目的是为负载均衡、读写分离、高可用性提供机制，而不是完全实现它们。用户需要结合使用MySQL的 Replication等机制来实现副本同步等功能。amoeba对底层数据库连接管理和路由实现也采用了可插拨的机制，第三方可以开发更高级的策略类来替代作者的实现。这个程序总体上比较符合KISS原则的思想。</p></blockquote><blockquote><p>amoeba作用：<font color=red>可以实现数据库的读写操作分离，高可用。 (数据库分库分表中间件)</font><br>&nbsp; 需求分析： 如果所有的访问压力都访问一台mysql服务器.如果遇到高并发问题可能导致数据库服务器宕机影响整个服务.<br>&nbsp; 解决方案： 使用读写分离策略.提高数据库的执行效率，当用户有更新操作时，访问主数据库.当用户有读操作时访问从数据库.同时从数据库可以有多台.并且主从实现数据同步.实现读和写分离.高升数据库性能.<br><img src="/images/amoeba.png" alt="avatar"></p></blockquote><h3 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h3><blockquote><h4 id="什么是Mycat"><a href="#什么是Mycat" class="headerlink" title="什么是Mycat"></a>什么是Mycat</h4><p>官网copy了一份：</p><ol><li>一个彻底开源的，面向企业应用开发的大数据库集群</li><li>支持事务、ACID、可以替代MySQL的加强版数据库</li><li>一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群</li><li>一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server</li><li>结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品</li><li>一个新颖的数据库中间件产品  </li></ol></blockquote><blockquote><p>Mycat作用：<font color=red>能满足数据库数据大量存储， 提高了查询性能 (数据库分库分表中间件)</font>  </p></blockquote><p><img src="/images/mycat.png" alt="avatar"></p><blockquote><p>Mycat工作原理说明：</p><ol><li>后台服务器需要将数据入库时通过mycat代理服务器操作数据库.</li><li>如果是更新操作.则将数据发往主数据库，如果是读操作则将数据发送给从数据库或者空闲的主数据库.</li><li>当主数据库发生宕机后，Mycat内部有心跳检测机制.判断主库宕机后，实现故障迁移.将所有的写库操作发往第二台主库.也就是从机.</li><li>当运维人员修复主库后.Mycat还会将写操作发往主库.从而实现数据库高可用.</li></ol></blockquote><h4 id="垂直拆分和水平拆分"><a href="#垂直拆分和水平拆分" class="headerlink" title="垂直拆分和水平拆分"></a>垂直拆分和水平拆分</h4><blockquote><p>业务需求： 当公司的业务积累到一定量，数据库和数据表都有大量的数据，无论从运维/查询角度而言效率都很慢，这就是通常所说的数据库瓶颈问题。<br><font color=red>那么如何解决这一问题呢？ 核心思想：将大量的数据分别保存到不同的数据库和数据表中</font>。</p></blockquote><h4 id="数据拆分概念引入"><a href="#数据拆分概念引入" class="headerlink" title="数据拆分概念引入"></a>数据拆分概念引入</h4><blockquote><h5 id="垂直拆分："><a href="#垂直拆分：" class="headerlink" title="垂直拆分："></a>垂直拆分：</h5><p>特点：根据不同的业务，将数据表拆分到不同的数据库中.<br>规定：如果有业务关联，则尽可能拆分到一个数据库中.  </p><h5 id="水平拆分："><a href="#水平拆分：" class="headerlink" title="水平拆分："></a>水平拆分：</h5><p>特点：  按照数据量进行拆分，将一个表中的数据分别保存到不同的数据表中，分散存储  </p></blockquote><h4 id="使用Mycat实现数据库-1-高可用性-2-读写分离-3-负载均衡"><a href="#使用Mycat实现数据库-1-高可用性-2-读写分离-3-负载均衡" class="headerlink" title="使用Mycat实现数据库 1.高可用性 2.读写分离 3.负载均衡"></a>使用Mycat实现数据库 1.高可用性 2.读写分离 3.负载均衡</h4><blockquote><h5 id="数据库垂直拆分"><a href="#数据库垂直拆分" class="headerlink" title="数据库垂直拆分"></a>数据库垂直拆分</h5></blockquote><blockquote><p>&nbsp;根据功能模块(业务)将一个数据库中的表，拆分为多个数据库.降低了数据库中的数据量.提高数据库效率</p><ul><li>优点：将数据表根据功能存放到不同的数据库中，可以提高数据库的性能。</li><li>拆分策略：将具有关联意义的数据表尽可能保存到同一个数据库中.否则关联查询时不能正确关联.因为在不同的数据库中。  </li></ul></blockquote><blockquote><h5 id="数据表水平拆分"><a href="#数据表水平拆分" class="headerlink" title="数据表水平拆分"></a>数据表水平拆分</h5></blockquote><blockquote><p>&nbsp;由于单表数据表的量很大，造成了数据库查询的瓶颈.所以需要将数据表中的数据拆分到多个数据库中.降低单表的数据量。</p><ul><li>数据存取问题：由于使用数据库水平拆分，那么数据库中的数据应该按照什么规则存取呢?</li><li>问题解决：Mycat对于数据水平拆分，指定了很多策略.课上介绍一种根据Id取模运算.</li><li>原理说明：当信息入库时根据Id%分库数量=值.这个值就是数据存储的位置.同样当用户读取数据库时，也会取模快速定位数据库中的表.快速获取数据，如下图。<br><img src="/images/%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5.png" alt="avatar"></li></ul></blockquote><h1 id="数据库优化策略-重点知识"><a href="#数据库优化策略-重点知识" class="headerlink" title="数据库优化策略(重点知识)"></a>数据库优化策略(重点知识)</h1><blockquote><ol><li>优化sql语句(多表操作)  where 左连接 右连接 内连接 原则:尽可能根据主键查询,尽可能少用关联查询.</li><li>创建索引(对经常查询的数据创建索引)</li><li>添加缓存(Redis/MemCache)</li><li>定期进行数据转储(将一些查询较少的数据保存到历史表,让当前表维护可控的数据量)</li><li>分库分表(需要大量的数据库服务器)</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库备份策略&quot;&gt;&lt;a href=&quot;#数据库备份策略&quot; class=&quot;headerlink&quot; title=&quot;数据库备份策略&quot;&gt;&lt;/a&gt;数据库备份策略&lt;/h1&gt;&lt;h2 id=&quot;冷备份策略&quot;&gt;&lt;a href=&quot;#冷备份策略&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="数据库基础知识" scheme="https://courage-kevin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://courage-kevin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="mysql" scheme="https://courage-kevin.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库Mysql基础知识</title>
    <link href="https://courage-kevin.github.io/2020/02/06/%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://courage-kevin.github.io/2020/02/06/%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-06T09:54:11.000Z</published>
    <updated>2020-02-06T11:30:30.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><blockquote><p>数据库：英文为Database，简称DB，数据库是按照数据结构来组织、存储和管理数据的仓库，简而言之，数据库就是存储数据的仓库。</p></blockquote><h2 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h2><blockquote><p>数据库根据存储采用的数据结构的不同可以分为许多种，其中包含早期的层次式数据库、网络式数据库。<br>目前占市场主流的是关系型数据库。当然还有非关系(NoSQL)型数据库（键值对数据库，例如：MongoDB、Redis）等其他类型的数据库</p></blockquote><h2 id="什么是关系型数据库？"><a href="#什么是关系型数据库？" class="headerlink" title="什么是关系型数据库？"></a>什么是关系型数据库？</h2><blockquote><p>底层是以二维表的及其之间的关系所组成的数据库，即是关系型数据库。例如：</p></blockquote><h2 id="常见的关系型数据库"><a href="#常见的关系型数据库" class="headerlink" title="常见的关系型数据库"></a>常见的关系型数据库</h2><blockquote><p>SQL Server      微软提供（收费、Java中使用不多）<br>Oracle            甲骨文公司（收费、功能强大、性能优异，Java中使用者很多）<br>DB2                IBM（收费、中型/大型、银行/电信等企业）<br>MySQL           瑞典MySQL AB（免费开源、小型、性能也不差、适用于中小型项目、可集群）<br>SQLite            迷你数据库，嵌入式设备中<br>…</p></blockquote><h2 id="MySQL建库、建表"><a href="#MySQL建库、建表" class="headerlink" title="MySQL建库、建表"></a>MySQL建库、建表</h2><blockquote><p>查看数据库、查看数据表：show databases；</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><blockquote><p>进入数据库：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名；</span><br></pre></td></tr></table></figure><blockquote><p>查看当前库中的所有表：show tables；</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>；</span><br></pre></td></tr></table></figure><blockquote><p>创建数据库、创建数据表<br>创建数据库： </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> 数据库名;</span><br></pre></td></tr></table></figure><blockquote><p>设置数据库编码：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> mydb1 <span class="keyword">charset</span> utf8；</span><br></pre></td></tr></table></figure><blockquote><p>创建数据表：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,                <span class="comment">-- 学生编号</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),    <span class="comment">-- 学生姓名</span></span><br><span class="line">    gender <span class="built_in">char</span>(<span class="number">1</span>),    <span class="comment">-- 学生性别</span></span><br><span class="line">    birthday <span class="built_in">date</span>,        <span class="comment">-- 出生年月</span></span><br><span class="line">    score <span class="keyword">double</span>        <span class="comment">-- 考试成绩</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><h2 id="MySQL数据类型及"><a href="#MySQL数据类型及" class="headerlink" title="MySQL数据类型及"></a>MySQL数据类型及</h2><h3 id="数值类型："><a href="#数值类型：" class="headerlink" title="数值类型："></a>数值类型：</h3><blockquote><p>MySQL中支持多种整型，其实很大程度上是相同的，只是存储值的大小范围不同而已。</p><ol><li>tinyint：   占用1个字节，相对于java中的byte</li><li>smallint： 占用2个字节，相对于java中的short</li><li>int：          占用4个字节，相对于java中的int</li><li>bigint：    占用8个字节，相对于java中的long ，其次是浮点类型即：float和double类型</li><li>float：      占用4个字节，单精度浮点类型，相对于java中的float</li><li>double：    占用8个字节，双精度浮点类型，相对于java中的double</li></ol></blockquote><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><blockquote><ol><li>char(n)  定长字符串，最长255个字符。n表示字符数，所谓的定长，是当插入的值长度小于指定的长度10（上面指定的）时, 剩余的空间会用空格填充。（这样会浪费空间）</li><li>varchar(n)变长字符串，最长不超过 65535个字节，n表示字符数，一般超过255个字节，会使用text类型。所谓的不定长，是当插入的值长度小于指定的长度10（上面指定的）时, 剩余的空间可以留给别的数据使用。（节省空间）</li><li>大文本（长文本）类型，最长65535个字节，一般超过255个字符列的会使用text。text也分多种，其中bigtext存储数据的长度约为4GB。</li></ol></blockquote><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>&emsp; char、varchar、text都可以表示字符串类型，其区别在于：</p><ol><li>char在保存数 据时, 如果存入的字符串长度小于指定的长度n,后面会用空格补全。 </li><li>varchar和text保存数据时, 按数据的真实长度存储, 剩余的空间可以留给别的数据用.</li><li>char会造成空间浪费(不足指定长度的会用空格补全), 但是由于不需要计算数据的长度, 因此速度更快。（即以空间换时间）</li><li>varchar和text是节省了空间，但是存储的速度不如char快，因为要计算数据的实际长度。（即以时间换空间）</li></ol></blockquote><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><blockquote><ol><li>date：年月日    time：时分秒     datetime：年月日 时分秒    </li><li>timestamp：时间戳(实际存储的是一个时间毫秒值)，与datetime存储日期格式相同。</li><li>timestamp最大表示2038年，而datetime范围是1000~9999</li><li>timestamp在插入数、修改数据时，可以自动更新成系统当前时间(后面用到时再做讲解)</li></ol></blockquote><h2 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h2><blockquote><p>&emsp; 创建表时, 除了要给每个列指定对应的数据类型, 有时也需要给列添加约束。常见的约束有：主键约束、唯一约束、非空约束、外键约束。</p><ol><li>主键(primary key)：主键是数据表中，一行记录的唯一标识。比如学生的编号，人的身份证号, 主键的特点：唯一且不能为空，当主键为数值时，为了方便维护，可以设置主键为自增 auto_increment              </li><li>唯一(unique)：保证所约束的列必须是唯一的，即不能重复出现，例如：用户注册时，保存的用户名不可以重复。唯一约束特点是不能重复(允许为空)</li><li>非空(not null) ：保证所约束的列必须是不为空的，即在插入记录时，该列必须要赋值，例如：用户注册时，保存的密码不能为空。非空约束的特点是：不能为空值，即插入数据时该列必须得有值。</li><li>外键约束：外键是用于表和表之间关系的列</li></ol></blockquote><h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><h3 id="什么是SQL语言"><a href="#什么是SQL语言" class="headerlink" title="什么是SQL语言?"></a>什么是SQL语言?</h3><blockquote><p>Structured Query Language：结构化的查询语言，SQL是操作所有关系型数据库的通用的语言</p></blockquote><h3 id="SQL语言的分类："><a href="#SQL语言的分类：" class="headerlink" title="SQL语言的分类："></a>SQL语言的分类：</h3><blockquote><ol><li>DDL – 数据库定义语言，指CREATE、ALTER、DROP等操作（ 即创建、删除、修改数据库和数据表 ）</li><li>DML – 数据操作语言，指INSERT、UPDATE、DROP等操作（ 即数据表中数据的增、删、改操作 ）</li><li>DQL  – 数据查询语言（指SELECT操作，即数据表中数据的查询操作）</li></ol></blockquote><h3 id="更新表记录（insert-update-delete）"><a href="#更新表记录（insert-update-delete）" class="headerlink" title="更新表记录（insert/update/delete）"></a>更新表记录（insert/update/delete）</h3><h4 id="insert–插入表记录"><a href="#insert–插入表记录" class="headerlink" title="insert–插入表记录"></a>insert–插入表记录</h4><blockquote><p>格式: <font color=red>insert into 表名称 values (值1, 值2,….)</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp  (字段<span class="number">1</span>，字段<span class="number">2</span>，)  <span class="keyword">values</span>(值<span class="number">1</span>, 值<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><h4 id="update修改表记录"><a href="#update修改表记录" class="headerlink" title="update修改表记录"></a>update修改表记录</h4><blockquote><p>格式: <font color=red>update 表名称 set 列名称 = 新值 where 列名称 = 某值</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- </span></span><br><span class="line">    <span class="keyword">update</span> stu <span class="keyword">set</span> score=score+<span class="number">10</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'xxx'</span>;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> stu <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'xxx'</span>;</span><br><span class="line">    <span class="keyword">update</span> stu <span class="keyword">set</span> score=<span class="keyword">ifnull</span>(score, <span class="number">0</span>)+<span class="number">10</span>;</span><br><span class="line">    注意: null值和任何值计算结果还是null, 因此, 可以通过ifnull函数将null置为零对待.</span><br></pre></td></tr></table></figure><h4 id="delete删除表记录"><a href="#delete删除表记录" class="headerlink" title="delete删除表记录"></a>delete删除表记录</h4><blockquote><p>格式: <font color=red>delete from 表名称 where 列名称 = 值</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> stu <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'xxx'</span>; </span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> stu;    </span><br><span class="line"><span class="comment">--若没有where子句, 则默认删除所有记录</span></span><br></pre></td></tr></table></figure><h4 id="select查询表记录"><a href="#select查询表记录" class="headerlink" title="select查询表记录"></a>select查询表记录</h4><blockquote><p>格式: <font color=red>select 列名称 from 表名称</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询emp表中的所有员工，显示员工姓名、薪资、奖金</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">name</span>,sal,bonus <span class="keyword">from</span> emp;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> dept <span class="keyword">from</span> emp;           </span><br><span class="line">    distinct  <span class="comment">--关键字，用于剔除指定列中的重复值</span></span><br></pre></td></tr></table></figure><h4 id="where子句查询"><a href="#where子句查询" class="headerlink" title="where子句查询"></a>where子句查询</h4><blockquote><p>格式: <font color=red>select 列名称 from 表名称</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询薪资大于300的姓名及工资大于3000的所有员工，显示员工姓名、薪资</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>,sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal&gt;<span class="number">3000</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询emp表中总薪资(薪资+奖金)大于3500的所有员工，显示员工姓名、总薪资</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>, sal+bonus <span class="keyword">from</span> emp <span class="keyword">where</span> (sal+bonus)&gt;<span class="number">3000</span>; </span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>, sal+bonus <span class="keyword">as</span> 总薪资 <span class="keyword">from</span> emp <span class="keyword">where</span> (sal+bonus)&gt;<span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--as用于定义别名(仅在查询的结果中作为列的表头显示)，也可以省略as</span></span><br><span class="line"><span class="comment">-- where子句中不能使用列别名（但是可以使用表别名）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询emp表中薪资在3000和4500之间的员工，显示员工姓名和薪资</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>,sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">between</span> <span class="number">3000</span> <span class="keyword">and</span> <span class="number">4500</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询emp表中姓名中以"刘"开头的员工，显示员工姓名。</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>,sal <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'刘%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询emp表中姓名以"刘"开头，字数为两个字的员工，显示员工姓名。</span></span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'刘_'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询emp表中姓名中包含"涛"字的员工，显示员工姓名。</span></span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%涛%'</span>;</span><br><span class="line">        <span class="comment">--提示："%" 表示任意0或多个字符。"_" 表示任意一个字符</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询emp表中薪资为1400、1600、1800的员工，显示员工姓名和薪资</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>,sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">in</span>(<span class="number">1400</span>,<span class="number">1600</span>,<span class="number">1800</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询emp表中薪资小于2000和薪资大于4000的员工，显示员工姓名、薪资。</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>,sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal&lt;<span class="number">2000</span> <span class="keyword">or</span> sal &gt;<span class="number">4000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询emp表中薪资大于3000并且奖金小于600的员工，显示姓名、薪资、奖金。</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>,sal,bonus <span class="keyword">from</span> emp <span class="keyword">where</span> sal&gt;<span class="number">3000</span> <span class="keyword">and</span> bonus&lt;<span class="number">600</span>;</span><br></pre></td></tr></table></figure><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><blockquote><p>对查询的结果进行排序使用 order by关键字。</p><ol><li>order by 排序的列 asc    升序 ↑    </li><li>order by 排序的列 dasc   降序 ↓</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对emp表中所有员工的薪资进行升序(从低到高)排序，显示姓名、薪资。</span></span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">name</span>,sal <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">asc</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">-- 对emp表中所有员工的总薪资进行降序(从高到低)排序，显示姓名、总薪资。</span></span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">name</span>, sal+bonus <span class="keyword">as</span> 总薪资 <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> (sal+bonus) <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">--分组查询：对所查询的记录可以根据某一列进行分组, 分组使用group by。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 将员工按照部门进行分组</span></span><br><span class="line">            <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> dept;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">-- 对emp表按照部门进行分组, 并统计每个部门的人数, 显示部门和对应人数</span></span><br><span class="line">            <span class="keyword">select</span> dept 部门名称, <span class="keyword">count</span>(*) 部门人数 <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> dept;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">-- 对emp表按照部门进行分组, 求每个部门的最高薪资(不包含奖金)</span></span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">max</span>(sal) 总薪资 <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> dept;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">--注意：分组之前使用聚合函数表示对查询的所有记录进行统计计算,分组之后使用聚合函数表示对每一个组中的所有记录进行统计计算。</span></span><br></pre></td></tr></table></figure><h4 id="聚合函数查询："><a href="#聚合函数查询：" class="headerlink" title="聚合函数查询："></a>聚合函数查询：</h4><blockquote><ol><li>max()或min() – 某列的最大值或最小值，</li><li>count() 某列的行数，</li><li>sum() 某列值之和，</li><li>avg() 某列的平均值</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询emp表中最高薪资</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">max</span>(sal) <span class="keyword">as</span> 最高薪资 <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- 查询emp表中最高总薪资(薪资加奖金)</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">max</span>(sal+bonus) <span class="keyword">as</span> 最高薪资 <span class="keyword">from</span> emp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 统计emp表中薪资大于3000的员工人数</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">where</span> sal&gt;<span class="number">3000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 统计emp表中所有员工的总薪资(不包含奖金)</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">sum</span>(sal) <span class="keyword">as</span> 员工总薪资 <span class="keyword">from</span> emp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 统计emp表员工的平均薪资(不包含奖金)</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">avg</span>(sal) <span class="keyword">as</span> 员工总薪资 <span class="keyword">from</span> emp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 重要提示：可以使用count(*)统计记录行数，多个聚合函数可以一起查询。</span></span><br><span class="line"><span class="comment">-- 例如:根据部门进行分组，统计每个部门员工人数和平均薪资</span></span><br><span class="line">        <span class="keyword">select</span> dept, <span class="keyword">count</span>(*) 员工人数, <span class="keyword">avg</span>(sal) 平均薪资 <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> dept; </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 聚合函数不能用在where子句中，在没有分组的情况下，聚合函数不能和其他普通字段一起查询</span></span><br><span class="line"><span class="comment">-- 错误的例如: 查询emp表中薪资最高的员工姓名。</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">max</span>(sal) <span class="keyword">from</span> emp;<span class="comment">--结果是错的</span></span><br><span class="line"><span class="comment">-- 正确的查询：</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>, sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal=(<span class="keyword">select</span> <span class="keyword">max</span>(sal) <span class="keyword">from</span> emp);<span class="comment">--</span></span><br></pre></td></tr></table></figure><h4 id="数值函数："><a href="#数值函数：" class="headerlink" title="数值函数："></a>数值函数：</h4><blockquote><ol><li>ceil(数值) – 向上取整、</li><li>floor(数值) – 向下取整、</li><li>round(数值) – 向下取整</li><li>rand(数值) – 随机数</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  查询emp表中所有员工薪资上涨15.47%, 向上取整。</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">name</span>,sal, <span class="keyword">ceil</span>(sal*<span class="number">1.1547</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><blockquote><ol><li>curdate() – 返回当前日期(年月日)</li><li>curtime() – 返回当前时间(时分秒)</li><li>now() – 返回当前日期+时间(年月日 时分秒)</li><li>date_add()、date_sub() – 增加/减少日期</li><li>year()、month()、day()、hour()、minute()、second()，分别用来获取日期中的年、月、日、时、分、秒</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询系统当前时间。</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">now</span>();</span><br><span class="line"><span class="comment">-- 查询emp表中所有员工的年龄，显示姓名、年龄。</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">year</span>(<span class="keyword">curdate</span>()) - <span class="keyword">year</span>(birthday) 年龄 <span class="keyword">from</span> emp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询emp表中所有在1993和1995年出生的，显示姓名、出生日期。</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">name</span>,birthday <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">year</span>(birthday) <span class="keyword">between</span> <span class="number">1993</span> <span class="keyword">and</span> <span class="number">1995</span>;</span><br></pre></td></tr></table></figure><h3 id="外键和表关系"><a href="#外键和表关系" class="headerlink" title="外键和表关系"></a>外键和表关系</h3><h4 id="外键："><a href="#外键：" class="headerlink" title="外键："></a>外键：</h4><blockquote><p>唯一标识其他表中的一条记录，用来通知数据库两张表列与列之间的对应关系, 并让数据库帮我们维护这样关系的键就叫做外键。<br>外键作用: 确保数据库数据的完整性和一致性，添加外键: 例如:foreign key(dept_id) references dept(id)<br>例如：员工表的部门id列（dept_id）和部门表的id列具有一 一对应的关系, 其中dept_id就是外键。</p></blockquote><h4 id="表关系："><a href="#表关系：" class="headerlink" title="表关系："></a>表关系：</h4><blockquote><ol><li>一对多：一对多，反过来就是多对一，对于一对多的两张表，可以在多的一方添加列，保存一的一方的主键，从而保存两张表之间的关系</li><li>一对一：对于一对一关系的两张表，可以在任意一张表中添加列，保存另一张表的主键，从而保存两张表之间的关系</li><li>多对多：对于多对多的关系，可以拆分成两张一对多的关系，无法在两张表中添加列保存关系，但我们可以添加一张第三方的表,保存两张表的主键，从而保存两张表的关系。</li></ol></blockquote><h3 id="连接查询：将两张或者两张以上的表，按照指定条件查询，将结果显示在一张表中。"><a href="#连接查询：将两张或者两张以上的表，按照指定条件查询，将结果显示在一张表中。" class="headerlink" title="连接查询：将两张或者两张以上的表，按照指定条件查询，将结果显示在一张表中。"></a>连接查询：将两张或者两张以上的表，按照指定条件查询，将结果显示在一张表中。</h3><blockquote><p>多张表查询的语法：  <font color=red>Select 字段 from 表1,表2… where…</font><br>如果表名过长，可以为表添加别名以方便书写<font color=red>select… from A a, B b… where…</font>    </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询部门和员工两张表</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> dept,emp;   </span><br><span class="line">    <span class="comment">---上面查询的结果中存在大量错误的数据, 如果想正确显示部门及部门对应的员工，可以通过where子句从中筛选正确的数据.</span></span><br><span class="line"><span class="comment">-- 查询部门和部门下的员工。</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> dept d,emp e <span class="keyword">where</span> d.id=e.dept_id;</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> dept d <span class="keyword">inner</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> d.id=e.dept_id;          </span><br><span class="line">    <span class="comment">--- (inner join...on...)方式也叫做内连接查询</span></span><br></pre></td></tr></table></figure><h3 id="外连接查询："><a href="#外连接查询：" class="headerlink" title="外连接查询："></a>外连接查询：</h3><blockquote><p>左外连接查询，显示左侧表中的所有记录，如果在右侧表中没有对应的记录，则显示为null<br>语法：<font color=red>select …from a left join b on (a.id=b.xid)</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有部门和部门下的员工，如果部门下没有员工，显示null</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept d <span class="keyword">left</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> d.id=e.dept_id;</span><br><span class="line">以上结果会显示（左侧表）所有部门，如果某部门下没有员工，（右侧表）则显示为null</span><br></pre></td></tr></table></figure><h3 id="右外连接查询："><a href="#右外连接查询：" class="headerlink" title="右外连接查询："></a>右外连接查询：</h3><blockquote><p>显示右侧表中的所有记录，如果在左侧表中没有对应的记录，则显示为null<br>语法：<font color=red>select 字段 from a right join b on (a.id=b.xid)</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询部门和所有员工，如果员工没有所属部门，显示null</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept d <span class="keyword">right</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> d.id=e.dept_id;</span><br><span class="line">以上结果会显示（右侧表）所有员工，如果员工没有所属部门，（左侧表）则显示为null</span><br></pre></td></tr></table></figure><h3 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h3><blockquote><p>其实就是将一个查询得出的结果，作为另外一个查询的条件。<br>格式：<font color=red>select…from…where…(select…from…)</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---列出薪资比'xxx'高的所有员工，显示姓名、薪资      -- 先查询出'王海涛'的薪资</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, sal <span class="keyword">from</span> emp <span class="keyword">where</span> sal&gt;( <span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'xxx'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">---列出与'刘沛霞'从事相同职位的所有员工，显示姓名、职位、部门。</span></span><br><span class="line"><span class="keyword">select</span> e.name, e.job, d.name <span class="keyword">from</span> emp e, dept d <span class="keyword">where</span> e.dept_id=d.id <span class="keyword">and</span> job=(<span class="keyword">select</span> job <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'xxx'</span>);</span><br></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">（左外连接）列出所有部门和部门下的员工，如果部门下没有员工, 显示为null。</span><br><span class="line"><span class="keyword">select</span> d.id, d.name, e.name, e.dept_id <span class="keyword">from</span> dept d <span class="keyword">left</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> e.dept_id=d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">--（关联查询）列出在'培优部'任职的员工，假定不知道'培优部'的部门编号。</span></span><br><span class="line"><span class="keyword">select</span> e.name, e.dept_id, d.id, d.name <span class="keyword">from</span> emp e, dept d <span class="keyword">where</span> e.dept_id=d.id;</span><br><span class="line"><span class="comment">-- 再筛选过滤，查询部门名称为'培优部'的员工</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.id, d.name <span class="keyword">from</span> emp e, dept d <span class="keyword">where</span> e.dept_id=d.id <span class="keyword">and</span> d.name=<span class="string">'培优部'</span>;</span><br><span class="line"> </span><br><span class="line">（自连接查询）列出所有员工及其直接上级，显示员工姓名、上级编号，上级姓名</span><br><span class="line"><span class="comment">-- 先查询员工表（emp e1）</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, topid <span class="keyword">from</span> emp e1;</span><br><span class="line"><span class="comment">-- 再查询上级表（还是员工表，emp e2）</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> emp e2;</span><br><span class="line"><span class="comment">-- 最后查询员工及其员工的直接上级</span></span><br><span class="line"><span class="keyword">select</span> e1.name,e1.topid, e2.id, e2.name <span class="keyword">from</span> emp e1, emp e2 <span class="keyword">where</span> e1.topid = e2.id;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（分组、聚合函数）列出最低薪资大于1500的各种职位，显示职位和该职位最低薪资</span><br><span class="line"><span class="comment">--先查询出各种职位的最低薪资</span></span><br><span class="line"><span class="keyword">select</span> job, <span class="keyword">min</span>(sal) 最低薪资 <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> job;</span><br><span class="line"><span class="comment">--提示：对分组后的记录筛选过滤请使用having替换where，并且having书写在最后</span></span><br><span class="line"><span class="comment">--再查询出最低薪资&gt;1500的职位</span></span><br><span class="line"><span class="keyword">select</span> job, <span class="keyword">min</span>(sal) 最低薪资 <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> job <span class="keyword">having</span> <span class="keyword">min</span>(sal)&gt;<span class="number">1500</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（分组、聚合函数查询）列出在每个部门就职的员工数量、平均工资。显示部门编号、员工数量，平均薪资。</span><br><span class="line"><span class="keyword">select</span> dept_id, <span class="keyword">count</span>(*) 员工数量, <span class="keyword">avg</span>(sal) 平均薪资 <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> dept_id;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">（分组、关联、聚合函数查询）查出至少有一个员工的部门。显示部门编号、部门名称、部门位置、部门人数。</span><br><span class="line"><span class="comment">--先关联查询, 查询出员工和员工对应的部门</span></span><br><span class="line"><span class="keyword">select</span> d.id, d.name, d.loc, e.name <span class="keyword">from</span> emp e, dept d <span class="keyword">where</span> e.dept_id=d.id;</span><br><span class="line"><span class="comment">--再根据部门进行分组, 统计每个部门的员工数量</span></span><br><span class="line"><span class="keyword">select</span> d.id, d.name, d.loc, <span class="keyword">count</span>(*) 员工数量 <span class="keyword">from</span> emp e, dept d <span class="keyword">where</span> e.dept_id=d.id <span class="keyword">group</span> <span class="keyword">by</span> e.dept_id;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">（自连接查询）列出受雇日期早于直接上级的所有员工的编号、姓名、部门名称。</span><br><span class="line"><span class="comment">-- 关联查询</span></span><br><span class="line"><span class="keyword">select</span> e1.id, e1.name, d.name <span class="keyword">from</span> emp e1, emp e2, dept d <span class="keyword">where</span> e1.dept_id=d.id <span class="keyword">and</span> e1.topid=e2.id <span class="keyword">and</span> e1.hdate &lt; e2.hdate;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库概述&quot;&gt;&lt;a href=&quot;#数据库概述&quot; class=&quot;headerlink&quot; title=&quot;数据库概述&quot;&gt;&lt;/a&gt;数据库概述&lt;/h1&gt;&lt;h2 id=&quot;什么是数据库&quot;&gt;&lt;a href=&quot;#什么是数据库&quot; class=&quot;headerlink&quot; title=&quot;什
      
    
    </summary>
    
    
      <category term="数据库基础知识" scheme="https://courage-kevin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://courage-kevin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="mysql" scheme="https://courage-kevin.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架基础知识</title>
    <link href="https://courage-kevin.github.io/2018/03/12/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://courage-kevin.github.io/2018/03/12/Spring%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2018-03-12T12:05:41.000Z</published>
    <updated>2020-02-07T12:23:33.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h2 id="Spring框架简述"><a href="#Spring框架简述" class="headerlink" title="Spring框架简述"></a>Spring框架简述</h2><blockquote><p>是企业级应用中的一个软件开发框架，是一个半成品。最大优势是更好的实现了资源的整合(整合mybatis，整合springmvc，整合Redis…)。Spring框架中最核心是:IOC控制反转、DI依赖注入、Bean工厂、SpringAOP面向切面、事物控制例如整合JDBC，MyBatis，Hibernate等框架资源以更好的简化应用软件开发，降低软件开发周期。  </p></blockquote><blockquote><p>Spring的目的：就是让对象与对象之间的关系没有通过代码来关联，都是通过配置类说明管理的。<br>Spring就是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。<br>Spring里用的最经典的一个设计模式就是模板方法模式。</p></blockquote><h2 id="Spring核心架构："><a href="#Spring核心架构：" class="headerlink" title="Spring核心架构："></a>Spring核心架构：</h2><blockquote><ul><li>Spring Core：spring的核心容器，提供Spring框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC）模式，将应用程序的配置和依赖性规范与实际的应用程序代码分开  </li></ul></blockquote><blockquote><ul><li>Spring Context：Spring上下文，是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。  </li></ul></blockquote><blockquote><ul><li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。可以很容易地使 Spring框架管理的任何对象支持AOP。Spring AOP模块为基于Spring 的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，就可以将声明性事务管理集成到应用程序中。  </li></ul></blockquote><blockquote><ul><li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。  </li></ul></blockquote><blockquote><ul><li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括JDO、Hibernate和iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。  </li></ul></blockquote><blockquote><ul><li>Spring Web：Web上下文模块建立在应用程序上下文模块之上，为基于Web 的应用程序提供了上下文。所以Spring 框架支持与Jakarta Struts的集成。Web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。  </li></ul></blockquote><blockquote><ul><li>Spring MVC：    MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li></ul></blockquote><h2 id="Spring-核心组件："><a href="#Spring-核心组件：" class="headerlink" title="Spring 核心组件："></a>Spring 核心组件：</h2><blockquote><ul><li>BeanFactory：Spring内部使用，创建bean的工厂。</li><li>ApplicationContext：外部应用程序调用，也成为spring容器的上下文。</li><li>IoC控制反转：开发者在无需自己new对象，无需关心对象的创建过程。</li><li>DI依赖注入：松耦合方式实现对象之间的依赖</li><li>AOP：面向切面编程,补充java面向对象的不足</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring框架&quot;&gt;&lt;a href=&quot;#Spring框架&quot; class=&quot;headerlink&quot; title=&quot;Spring框架&quot;&gt;&lt;/a&gt;Spring框架&lt;/h1&gt;&lt;h2 id=&quot;Spring框架简述&quot;&gt;&lt;a href=&quot;#Spring框架简述&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Spring框架" scheme="https://courage-kevin.github.io/categories/Spring%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="https://courage-kevin.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Nginx扩展知识总结</title>
    <link href="https://courage-kevin.github.io/2018/03/09/Nginx%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://courage-kevin.github.io/2018/03/09/Nginx%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2018-03-09T12:37:05.000Z</published>
    <updated>2020-02-06T14:26:50.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><blockquote><p> Nginx同Apache一样都是一种WEB服务器。基于REST架构风格，以统一资源描述符URI或者统一资源定位符URL作为沟通依据，通过HTTP协议提供各种网络服务。当然每一种web服务器在设计之初手当时的环境局限,比如用户规模、网络宽带、产品特点等,并且各自的定位和发展都不尽相同。这也使得各个WEB服务器有着各自鲜明的特点</p></blockquote><blockquote><p> Apache发展时间长，优点是稳定、开源、跨平台，但是缺点就是因为出现的时间太久了，他兴起的年代、互联网产业远远比不是现在，所以他被设计为重量级，并不支持高并发，在Apache上运行数以万计的访问，会导致服务器小号大量内存，操作系统对其进行进程或线程间的切换也会消耗大量的cpu资源，导致http请求的平均响应水平变低，Apache是以进程为基础的结构，进程要比线程消耗更多的系统开支，不太适合于多处理器环境，这些都决定Apache不可能成为高性能的WEB服务器，所以轻量级高并发服务器Nginx就应运而生了。</p></blockquote><h2 id="什么是正向代理"><a href="#什么是正向代理" class="headerlink" title="什么是正向代理"></a>什么是正向代理</h2><blockquote><p> 正向代理也是大家最常接触的到的代理模式，像我们平时需要访问外国的某些网站，可能会用一个操作FQ进行访问，FQ的方式主要就是找到一个可以访问外国网站的代理服务器，我们讲请求发送给代理服务器去访问国外的网站，然后将访问到的数据传递给我们，这种模式成为正向代理，正向代理最大的特点及时客户端非常明确要访问的服务器地址，服务器只清楚请求来自哪个代理服务，而不清楚来自哪个具体的客户端，正向代理模式屏蔽或隐藏了真是客户端信息。</p></blockquote><blockquote><p>总结来讲，正向代理，它代理的是客户端，是一个位于客户源和原始服务器之间的服务器，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p></blockquote><h2 id="Nginx反向代理服务器"><a href="#Nginx反向代理服务器" class="headerlink" title="Nginx反向代理服务器"></a>Nginx反向代理服务器</h2><blockquote><p>反向代理：”它代理的是服务端”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。也就是说在多个客户端给服务器发送请求，在Nginx服务器接收到之后，会按照一定的规则分发给后端的阢处理服务器进行处理，此时客户端发起的请求的来源是明确的，但是请求具体由哪台服务器处理的并不明确，Nginx扮演的就是一个反向代理的角色，客户端是感知不到代理存在的，反向代理对外都是透明的。访问者可能根本都不知道访问的是代理，因为客户端不需要任何配置就可以访问。</p></blockquote><h2 id="Nginx负载均衡调度算法："><a href="#Nginx负载均衡调度算法：" class="headerlink" title="Nginx负载均衡调度算法："></a>Nginx负载均衡调度算法：</h2><blockquote><ol><li>weight轮询(默认)：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</li><li>ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</li><li>fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。</li><li>url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</li></ol></blockquote><h2 id="几种web服务器比较："><a href="#几种web服务器比较：" class="headerlink" title="几种web服务器比较："></a>几种web服务器比较：</h2><p><img src="/images/webservice.png" alt="avatar"></p><p>Tengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。</p><blockquote><ol><li>继承Nginx-1.15.9的所有特性，兼容Nginx的配置；</li><li>支持HTTP的CONNECT方法，可用于正向代理场景；</li><li>支持异步OpenSSL，可使用硬件如:QAT进行HTTPS的加速与卸载；</li><li>更加强大的负载均衡能力，包括一致性hash模块、会话保持模块，还可以对后端的服务器进行主动健康检查，根据服务器状态自动上线下线，以及动态解析upstream中出现的域名；</li><li>输入过滤器机制支持。通过使用这种机制Web应用防火墙的编写更为方便；</li><li>支持设置proxy、memcached、fastcgi、scgi、uwsgi在后端失败时的重试次数</li><li>动态脚本语言Lua支持。扩展功能非常高效简单；</li><li>支持按指定关键字(域名，url等)收集Tengine运行状态；</li><li>组合多个CSS、JavaScript文件的访问请求变成一个请求；</li><li>自动去除空白字符和注释从而减小页面的体积</li><li>自动根据CPU数目设置进程个数和绑定CPU亲缘性；</li><li>监控系统的负载和资源占用从而对系统进行保护；</li><li>显示对运维人员更友好的出错信息，便于定位出错机器；</li><li>更强大的防攻击（访问速度限制）模块；</li><li>更方便的命令行参数，如列出编译的模块列表、支持的指令等；</li><li>可以根据访问文件类型设置过期时间；</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; Nginx同Apache一样都是一种WEB服务器。基于REST架构风格，以统一资源描述符
      
    
    </summary>
    
    
      <category term="Nginx" scheme="https://courage-kevin.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://courage-kevin.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC基础知识</title>
    <link href="https://courage-kevin.github.io/2018/03/09/SpringMVC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://courage-kevin.github.io/2018/03/09/SpringMVC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2018-03-09T11:13:46.000Z</published>
    <updated>2020-02-07T12:08:57.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet:"></a>Servlet:</h2><blockquote><p>在认识SpringMVC前先回顾Servlet<br>Servlet本质上一段java程序<br>Servlet程序无法独立运行，必须放在服务器中，由服务器调用才可以执行！<br>Servlet的作用是：接受请求、处理请求、将结果响应给浏览器。  </p></blockquote><h2 id="Servlet的缺点"><a href="#Servlet的缺点" class="headerlink" title="Servlet的缺点"></a>Servlet的缺点</h2><p>每个Servlet声明时需要在web.xml中配置8行代码，配置繁琐，内容多，web.xml结构不清晰，不易维护。团队开发冲突不断。一般来说，每个Servlet只处理一个请求，如果要实现数据库表的CRUD操作，需要写4个Servlet。获取参数繁琐只能强制转类型，复杂的还需特殊处理。如日期类型转换，代码繁多重复手工劳动，非业务代码。  </p><h2 id="Web-MVC架构及分析"><a href="#Web-MVC架构及分析" class="headerlink" title="Web MVC架构及分析"></a>Web MVC架构及分析</h2><p>基于servlet，jsp，javabean技术实现的MVC架构,具体架构图如下：<br><img src="/images/mvc.png" alt="avatar">  </p><h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式:"></a>MVC设计模式:</h2><blockquote><p>用来进行分层的结构，这样代码分离结构清晰，各层代码，各司其职，易于开发大型项目。MVC(Model模型层、View视图层、Control控制层(servlet层))，将软件进行分层达到松耦合的效果。<br>优势：提高代码的可读性，实现程序间的松耦合、提高代码复用性。<br><img src="/images/mvc2.png" alt="avatar">  </p></blockquote><h2 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a>什么是SpringMVC</h2><blockquote><p>SpringMVC他不是一个框架，而是Spring框架中的WEB应用模块<br>SpringMVC属于SpringFrameWork的后续产品。<br>SpringMVC就是基于MVC设计模式来实现的。<br>我们的POJO就是Model层，我们的JSP就是视图层，我们的Controller就是控制层。  </p></blockquote><h2 id="SpringMVC的工作原理："><a href="#SpringMVC的工作原理：" class="headerlink" title="SpringMVC的工作原理："></a>SpringMVC的工作原理：</h2><blockquote><p>SpringMVC底层就是一个servlet<br><img src="/images/springmvc.png" alt="avatar"></p><ol><li>当浏览器发起一个请求，访问我们的程序，就会被前端控制器拦截，（DispatcherServlet，SpringMVC的第一个组件）。</li><li>DispatcherServlet只负责接受请求和响应请求，它会解析URL调用处理器映射器（HandlerMapping）找到对应能处理这段业务的Controller，把Controller的名字返回给前端控制器，这时候DispatcherServlet就知道那个类可以处理业务。</li><li>拿到能处理业务的类名后，会调用（处理器适配器）HandlerAdaptor开始处理业务，一层一层的调用，从controller到service到dao层操作数据库，操作完数据库之后把所有的数据封装给ModelAndView对象，返回给DispatcherServlet，前段控制器就有了可以展示的视图和数据。</li><li>拿到ModelAndView对象之后，因为既有页面信息又有数据，所以会找到视图解析器（ViewReslover）解析完后会将View页面先发给前端控制器，前端控制器就可以准备页面演示了。</li><li>页面有了之后前端控制器就会将model也给到view。之后将model和view的内容一整合，就可以做最后响应的这一步了。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC&quot;&gt;&lt;a href=&quot;#SpringMVC&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC&quot;&gt;&lt;/a&gt;SpringMVC&lt;/h1&gt;&lt;h2 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Spring框架" scheme="https://courage-kevin.github.io/categories/Spring%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="https://courage-kevin.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis基础知识</title>
    <link href="https://courage-kevin.github.io/2018/03/02/Mybatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://courage-kevin.github.io/2018/03/02/Mybatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2018-03-02T11:13:46.000Z</published>
    <updated>2020-02-07T11:42:34.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="JDBC回顾"><a href="#JDBC回顾" class="headerlink" title="JDBC回顾"></a>JDBC回顾</h2><blockquote><p>再讲Mybatis之前，先回顾一下JDBC开发步骤：</p><ol><li>注册驱动Class.forName(“  “);</li><li>获取数据库连接DriverManager.getConnection();</li><li>获取传输器conn.preparedStatement();</li><li>执行SQL   ps.executeQuery(), 返回结果集对象ResultSet</li><li>遍历结果集</li><li>释放资源</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载数据库驱动</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="comment">//通过驱动管理类获取数据库链接</span></span><br><span class="line">            connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">            <span class="comment">//定义 sql 语句 ?表示占位符</span></span><br><span class="line">            String sql = <span class="string">"select * from user where username = ?"</span>;</span><br><span class="line">            <span class="comment">//获取预处理 statement</span></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为设置的参数值</span></span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, <span class="string">"王五"</span>);</span><br><span class="line">            <span class="comment">//向数据库发出 sql 执行查询，查询出结果集</span></span><br><span class="line">            resultSet = preparedStatement.executeQuery();</span><br><span class="line">            <span class="comment">//遍历查询结果集</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                System.out.println(resultSet.getString(<span class="string">"id"</span>) + resultSet.getString(<span class="string">" username"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (preparedStatement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    preparedStatement.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  上边使用 jdbc 的原始方法（未经封装）实现了查询数据库表记录的操作。</span></span><br></pre></td></tr></table></figure><h3 id="使用JDBC的劣势"><a href="#使用JDBC的劣势" class="headerlink" title="使用JDBC的劣势"></a>使用JDBC的劣势</h3><blockquote><ol><li>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</li><li>Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java代码。</li><li>使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能多也可能少，修改 sql 还要修改代码，系统不易维护。</li><li>对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成 pojo 对象解析比较方便。</li></ol></blockquote><h2 id="MyBatis框架概述"><a href="#MyBatis框架概述" class="headerlink" title="MyBatis框架概述"></a>MyBatis框架概述</h2><blockquote><p>mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</p></blockquote><h3 id="简单记重点"><a href="#简单记重点" class="headerlink" title="简单记重点"></a>简单记重点</h3><blockquote><p>Mybatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架,也是用来操作是数据库的。<br>优点：底层封装JDBC，可以简化JDBC的开发，并且可以更好的完成ORM（对象关系映射）</p></blockquote><h3 id="Mybatis开发环境搭建"><a href="#Mybatis开发环境搭建" class="headerlink" title="Mybatis开发环境搭建"></a>Mybatis开发环境搭建</h3><blockquote><ol><li>创建 maven 工程</li><li>添加 Mybatis的坐标</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>编写 User 实体类</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> username; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123; <span class="keyword">this</span>.username = username; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> birthday; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123; <span class="keyword">this</span>.birthday = birthday; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sex; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123; <span class="keyword">this</span>.sex = sex; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> address; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123; <span class="keyword">this</span>.address = address; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", username="</span> + username + <span class="string">", birthday="</span> + birthday</span><br><span class="line">        + <span class="string">", sex="</span> + sex + <span class="string">", address="</span></span><br><span class="line">        + address + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>编写持久层接口 Dao</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询所有用户</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>编写持久层接口的映射文件</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta"> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.itheima.dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置查询所有操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.itheima.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ol start="5"><li>编写 SqlMapConfig.xml 配置文件</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta"> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置 mybatis 的环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置 mysql 的环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务的类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/数据库名"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"1234"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 告知 mybatis 映射配置的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/itheima/dao/UserDao.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ol start="6"><li>编写测试类</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.读取配置文件</span></span><br><span class="line">    InputStream in = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">    <span class="comment">//2.创建 SqlSessionFactory 的构建者对象</span></span><br><span class="line">    SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    <span class="comment">//3.使用构建者创建工厂对象 SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory factory = builder.build(in);</span><br><span class="line">    <span class="comment">//4.使用 SqlSessionFactory 生产 SqlSession 对象</span></span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    <span class="comment">//5.使用 SqlSession 创建 dao 接口的代理对象</span></span><br><span class="line">    IUserDao userDao = session.getMapper(IUserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//6.使用代理对象执行查询所有方法</span></span><br><span class="line">    List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">    <span class="keyword">for</span>(User user : users) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">    in.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这简单的几行代码中，使用了三种设计模式，</span></span><br><span class="line"><span class="comment">// 1. 创建工厂的时候，mybatis使用了构建者模式。     优势：吧对象的创建细节隐藏起来，使用者直接调用build即可拿到对象。</span></span><br><span class="line"><span class="comment">// 2. 生产sqlSession使用了工厂模式。               优势：解耦（降低类之间的依赖关系）。</span></span><br><span class="line">    <span class="comment">// 3. 创建Dao接口实现类使用了代理模式。             优势：不修改源码的基础上对已有的方法增强。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>通过快速入门示例，我们发现使用 mybatis 是非常容易的一件事情，因为只需要编写 Dao 接口并且按照mybatis 要求编写两个配置文件，就可以实现功能。远比我们之前的 jdbc 方便多了。（我们使用注解之后，将变得更为简单，只需要编写一个 mybatis 配置文件就够了。）但是，这里面包含了许多细节，比如为什么会有工厂对象（SqlSessionFactory）,为什么有了工厂之后还要有构建者对象（SqlSessionFactoryBuilder），为什么 IUserDao.xml 在创建时有位置和文件名的要求等等。这些问题我们在自定义 mybatis 框架的章节，通过层层剥离的方式，给大家讲解。请注意：我们讲解自定义 Mybatis 框架，不是让大家回去自己去写个 mybatis，而是让我们能更好了了解mybatis 内部是怎么执行的，在以后的开发中能更好的使用 mybatis 框架，同时对它的设计理念（设计模式）有一个认识。</p></blockquote><h2 id="Mybatis图解"><a href="#Mybatis图解" class="headerlink" title="Mybatis图解"></a>Mybatis图解</h2><p><img src="/images/mybatis.PNG" alt="avatar"></p><blockquote><ol><li>SqlMapConfig.xml：此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。</li><li>xxxMapper.xml：sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。</li><li>SqlSessionFactory：通过mybatis环境等配置信息构造会话工厂对象。</li><li>SqlSession：由会话工厂对象创建会话对象，操作数据库需要通过Session进行。</li><li>User：Executor把执行sql后的内容输出映射到java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程  </li></ol></blockquote><h2 id="Mybatis工作原理解析简述"><a href="#Mybatis工作原理解析简述" class="headerlink" title="Mybatis工作原理解析简述"></a>Mybatis工作原理解析简述</h2><blockquote><ol><li>mybatis应用程序通过SqlSessionFactoryBuilder核心配置文件中构建出会话工厂对象，</li><li>通过会话工厂的实例开启一个会话，</li><li>通过会话对象获得一个mapper对象并运行mapper映射的SQL语句，</li><li>完成对数据库的增删改查（CRUD）和事物提交，之后关闭sqlSession</li></ol></blockquote><h2 id="MyBatis中的重要对象"><a href="#MyBatis中的重要对象" class="headerlink" title="MyBatis中的重要对象"></a>MyBatis中的重要对象</h2><blockquote><p>分别是SqlSessionFactory和SqlSession。  </p></blockquote><blockquote><ul><li>SqlSessionFactory：可以理解为会话工厂，在整个项目中共享，是线程安全的。通过openSession方法创建SqlSession对象，该方法存在很多重载方式可以有参数可以无参数。</li><li>SqlSession：可以通过会话工厂产生，线程不安全。用来执行SQL，提供了丰富的方法来完成数据库的操作。返回结果集. 框架底层直接将查询到的数据封装为实体对象  </li></ul></blockquote><blockquote><p>Mybatis不会自动提交事物，需要手动提交。提交方式有两种：openSession（true）或者session.commit（）；</p></blockquote><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="取值和-取值的区别"><a href="#取值和-取值的区别" class="headerlink" title="#{}取值和${}取值的区别"></a>#{}取值和${}取值的区别</h3><blockquote><ol><li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li><li>Mybatis在处理${}时，就是把${}替换成变量的值。</li><li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li></ol></blockquote><h3 id="resultType-和-resultMap的区别？"><a href="#resultType-和-resultMap的区别？" class="headerlink" title="#resultType 和 resultMap的区别？"></a>#resultType 和 resultMap的区别？</h3><blockquote><ol><li>resultType：类的名字和数据库相同时，可以直接设置resultType参数为Pojo类。</li><li>resultMap：类的名若不同，需要设置resultMap将结果名字和Pojo名字进行转换。</li><li>ResultMap用于映射不规范字段自动匹配规范驼峰规则，数据库字段与pojo对象的属性名不符合的时候可以使用此规则，属性名首字母小写，第二个单词首字母大写</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MyBatis&quot;&gt;&lt;a href=&quot;#MyBatis&quot; class=&quot;headerlink&quot; title=&quot;MyBatis&quot;&gt;&lt;/a&gt;MyBatis&lt;/h1&gt;&lt;h2 id=&quot;JDBC回顾&quot;&gt;&lt;a href=&quot;#JDBC回顾&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Mybatis框架" scheme="https://courage-kevin.github.io/categories/Mybatis%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Mybatis" scheme="https://courage-kevin.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mycat配置文件</title>
    <link href="https://courage-kevin.github.io/2018/03/01/Mycat%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://courage-kevin.github.io/2018/03/01/Mycat%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2018-03-01T12:11:26.000Z</published>
    <updated>2020-02-06T12:20:28.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mycat配置文件介绍"><a href="#Mycat配置文件介绍" class="headerlink" title="Mycat配置文件介绍"></a>Mycat配置文件介绍</h1><h2 id="schema-xml文件配置"><a href="#schema-xml文件配置" class="headerlink" title="schema.xml文件配置"></a>schema.xml文件配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"schema.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--name属性是自定义的  dataNode表示数据库的节点信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"jtdb"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"jtdb"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--定义节点名称/节点主机/数据名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"jtdb"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"jtdb"</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参数介绍--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--balance 0表示所有的读操作都会发往writeHost主机 --&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!--1表示所有的读操作发往readHost和闲置的主节点中--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--writeType=0 所有的写操作都发往第一个writeHost主机--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--writeType=1 所有的写操作随机发往writeHost中--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--dbType 表示数据库类型 mysql/oracle--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--dbDriver="native"  固定参数 不变--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--switchType=-1 表示不自动切换, 主机宕机后不会自动切换从节点--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--switchType=1  表示会自动切换(默认值)如果第一个主节点宕机后,Mycat会进行3次心跳检测,如果3次都没有响应,则会自动切换到第二个主节点--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--并且会更新/conf/dnindex.properties文件的主节点信息 localhost1=0 表示第一个节点.该文件不要随意修改否则会出现大问题--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"localhost1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select 1<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置第一台主机主要进行写库操作,在默认的条件下Mycat主要操作第一台主机在第一台主机中已经实现了读写分离.因为默认写操作会发往137的数据库.读的操作默认发往141.如果从节点比较忙,则主节点分担部分压力.</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.65.128:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--读数据库--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.65.130:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--定义第二台主机 由于数据库内部已经实现了双机热备.--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Mycat实现高可用.当第一个主机137宕机后.mycat会自动发出心跳检测.检测3次.--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果主机137没有给Mycat响应则判断主机死亡.则回启东第二台主机继续为用户提供服务.--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果137主机恢复之后则处于等待状态.如果141宕机则137再次持续为用户提供服务.--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--前提:实现双机热备.--&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM2"</span> <span class="attr">url</span>=<span class="string">"192.168.65.128:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.65.130:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="server-xml文件配置"><a href="#server-xml文件配置" class="headerlink" title="server.xml文件配置"></a>server.xml文件配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- - - Licensed under the Apache License, Version 2.0 (the "License"); </span></span><br><span class="line"><span class="comment">        - you may not use this file except in compliance with the License. - You </span></span><br><span class="line"><span class="comment">        may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 </span></span><br><span class="line"><span class="comment">        - - Unless required by applicable law or agreed to in writing, software - </span></span><br><span class="line"><span class="comment">        distributed under the License is distributed on an "AS IS" BASIS, - WITHOUT </span></span><br><span class="line"><span class="comment">        WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the </span></span><br><span class="line"><span class="comment">        License for the specific language governing permissions and - limitations </span></span><br><span class="line"><span class="comment">        under the License. --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:server <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"server.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nonePasswordLogin"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="comment">&lt;!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useHandshakeV10"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useSqlStat"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="comment">&lt;!-- 1为开启实时统计、0为关闭 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useGlobleTableCheck"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="comment">&lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--  &lt;property name="useCompression"&gt;1&lt;/property&gt;--&gt;</span> <span class="comment">&lt;!--1为开启mysql压缩协议--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  &lt;property name="fakeMySQLVersion"&gt;5.6.20&lt;/property&gt;--&gt;</span> <span class="comment">&lt;!--设置模拟的MySQL版本号--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="processorBufferChunk"&gt;40960&lt;/property&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="processors"&gt;1&lt;/property&gt; </span></span><br><span class="line"><span class="comment">        &lt;property name="processorExecutor"&gt;32&lt;/property&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认为type 0: DirectByteBufferPool | type 1 ByteBufferArena | type 2 NettyBufferPool --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"processorBufferPoolType"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认是65535 64K 用于sql解析时最大文本长度 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="maxStringLiteralLength"&gt;65535&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="sequnceHandlerType"&gt;0&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="backSocketNoDelay"&gt;1&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="frontSocketNoDelay"&gt;1&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="processorExecutor"&gt;16&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                &lt;property name="serverPort"&gt;8066&lt;/property&gt; &lt;property name="managerPort"&gt;9066&lt;/property&gt; </span></span><br><span class="line"><span class="comment">                &lt;property name="idleTimeout"&gt;300000&lt;/property&gt; &lt;property name="bindIp"&gt;0.0.0.0&lt;/property&gt; </span></span><br><span class="line"><span class="comment">                &lt;property name="frontWriteQueueSize"&gt;4096&lt;/property&gt; &lt;property name="processors"&gt;32&lt;/property&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--分布式事务开关，0为不过滤分布式事务，1为过滤分布式事务（如果分布式事务内只涉及全局表，则不过滤），2为不过滤分布式事务,但是记录分布式事务日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"handleDistributedTransactions"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--off heap for merge/order/group/limit      1开启   0关闭--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useOffHeapForMerge"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单位为m--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"memoryPageSize"</span>&gt;</span>64k<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单位为k--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"spillsFileBufferSize"</span>&gt;</span>1k<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useStreamOutput"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单位为m--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"systemReserveMemorySize"</span>&gt;</span>384m<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--是否采用zookeeper协调切换  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useZKSwitch"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- XA Recovery Log日志路径 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="XARecoveryLogBaseDir"&gt;./&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- XA Recovery Log日志名称 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="XARecoveryLogBaseName"&gt;tmlog&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 全局SQL防火墙设置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--白名单可以使用通配符%或着*--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--例如&lt;host host="127.0.0.*" user="root"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--例如&lt;host host="127.0.*" user="root"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--例如&lt;host host="127.*" user="root"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--例如&lt;host host="1*7.*" user="root"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这些配置情况下对于127.0.0.1都能以root账户登录--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;firewall&gt;</span></span><br><span class="line"><span class="comment">           &lt;whitehost&gt;</span></span><br><span class="line"><span class="comment">              &lt;host host="1*7.0.0.*" user="root"/&gt;</span></span><br><span class="line"><span class="comment">           &lt;/whitehost&gt;</span></span><br><span class="line"><span class="comment">       &lt;blacklist check="false"&gt;</span></span><br><span class="line"><span class="comment">       &lt;/blacklist&gt;</span></span><br><span class="line"><span class="comment">        &lt;/firewall&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户标签--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--与schema.xml中的配置相同 注意数据库的大小写--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>jtdb<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>user<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>jtdb<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readOnly"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mycat配置文件介绍&quot;&gt;&lt;a href=&quot;#Mycat配置文件介绍&quot; class=&quot;headerlink&quot; title=&quot;Mycat配置文件介绍&quot;&gt;&lt;/a&gt;Mycat配置文件介绍&lt;/h1&gt;&lt;h2 id=&quot;schema-xml文件配置&quot;&gt;&lt;a href=&quot;#sch
      
    
    </summary>
    
    
      <category term="mycat配置" scheme="https://courage-kevin.github.io/categories/mycat%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="常用配置文件" scheme="https://courage-kevin.github.io/tags/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Servlet基础知识</title>
    <link href="https://courage-kevin.github.io/2018/02/15/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://courage-kevin.github.io/2018/02/15/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2018-02-15T12:55:43.000Z</published>
    <updated>2020-02-06T09:15:57.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="Servlet概述"><a href="#Servlet概述" class="headerlink" title="Servlet概述"></a>Servlet概述</h2><blockquote><ol><li>Servlet本质上一段java程序</li><li>Servlet程序无法独立运行，必须放在服务器中，由服务器调用才可以执行！</li><li>Servlet的作用是：接受请求、处理请求、将结果响应给浏览器。</li></ol></blockquote><h2 id="Servlet的作用"><a href="#Servlet的作用" class="headerlink" title="Servlet的作用"></a>Servlet的作用</h2><blockquote><p>Servlet的作用就是处理请求，服务器会将接受到的请求交给Servlet处理。这个过程为：</p><ol><li>客户端发送请求至服务器端；</li><li>服务器将请求信息交给 Servlet 处理；</li><li>最终处理的结果交给服务器；</li><li>服务器将结果响应给客户端。</li></ol></blockquote><h2 id="Servlet调用过程"><a href="#Servlet调用过程" class="headerlink" title="Servlet调用过程"></a>Servlet调用过程</h2><blockquote><p><img src="/images/servlet%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="avatar"></p><ol><li>浏览器向服务器发起请求</li><li>首先会根据请求头信息获知浏览器访问的是那个虚拟主机</li><li>然后根据请求行中的路径资源获知浏览器访问的是哪一个web应用</li><li>根据请求行中的资源路径获知访问的是哪一个资源</li><li>根据获取到的资源路径到web.项目文件中去匹配真实路径，创建servlet实例并调用service方法</li><li>调用service方法前，底层会创建两个对象，Requset、response，通过request获取请求相关信息</li><li>通过response想浏览器发送响应数据，然后按照Http协议规定的格式，组织成相应消息，最后发送给浏览器</li></ol></blockquote><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><blockquote><p>&emsp;Servlet在第一次被访问时创建Servlet实例, 创建之后服务器会立即调用init方法进行初始化的操作, 创建之后, Servlet实例会一直驻留在服务器的内存中, 为后续的请求服务. 只要有请求来访问这个Servlet, 服务器就会调用service方法来处理请求, 直到服务器关闭, 或者WEB应用被移出容器, 随着WEB应用的销毁, Servlet实例也会跟着销毁, 在销毁之前服务器会调用destroy方法进行善后的处理。</p></blockquote><h2 id="请求、转发、域对象"><a href="#请求、转发、域对象" class="headerlink" title="请求、转发、域对象"></a>请求、转发、域对象</h2><blockquote><ol><li>域对象：<br>&emsp;能够在指定的范围内, 利用自身的map实现数据的共享  </li></ol></blockquote><blockquote><ol start="2"><li>请求转发：<br>&emsp;是指定服务器中的某一个资源（Servlet或JSP）在处理请求的过程中，将请求转发给一个其他的资源，让其他资源来处理请求转发只能在同一个Web应用内部的两个资源之间进行跳转, 不可以是不同的Web应用或者不同的服务器中进行跳转,请求转发是一次请求，一次响应，转发前后地址栏地址不会发生变化  </li></ol></blockquote><blockquote><ol start="3"><li>重定向：<br>&emsp;是指当用户浏览某个网址时，将其导向到另一个网址的技术。重定向和定时刷新都是两次请求两次响应，重定向和定时刷新前后，地址栏地址都会发生变化</li></ol></blockquote><blockquote><ol start="4"><li>总结:<br>定时刷新和重定向都是两次请求, 两次响应<br>定时刷新和重定向跳转前后, 地址栏地址都会发生变化。<br>定时刷新和重定向在跳转时没有限制, 既可以在同一个Web应用内部的资源之间进行跳转, 也可以在不同的Web应用或者不同的主机之间进行跳转<br>定时刷新和重定向不同的是, 重定向是立即跳转, 中间没有时间间隔, 而定时刷新可以指定多少秒之后再进行跳转, 在跳转之前, 可以输出内容到浏览器, 提示用户。</li></ol></blockquote><h3 id="EL表达式的作用"><a href="#EL表达式的作用" class="headerlink" title="EL表达式的作用:"></a>EL表达式的作用:</h3><blockquote><p>&emsp;在Web开发中, 实现很多功能的时候, 都是由Servlet接收请求、处理请求，但是处理的结果应该交给JSP显示，此时我们可以在Servlet中将请求处理的结果存入request域中，再通过转发将Request域带到JSP中，再通过EL表达式将request域中的数据取出来, 显示在网页上.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h1&gt;&lt;h2 id=&quot;Servlet概述&quot;&gt;&lt;a href=&quot;#Servlet概述&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Servlet基础知识" scheme="https://courage-kevin.github.io/categories/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://courage-kevin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>会话技术基础知识</title>
    <link href="https://courage-kevin.github.io/2018/02/10/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://courage-kevin.github.io/2018/02/10/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2018-02-10T14:13:57.000Z</published>
    <updated>2020-02-06T11:34:46.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><h2 id="什么是会话"><a href="#什么是会话" class="headerlink" title="什么是会话?"></a>什么是会话?</h2><blockquote><p>&emsp;为了实现某一个功能(比如购物), 浏览器和服务器之间可能会产生多次的请求和响应。从浏览器访问服务器开始，到访问服务器结束，浏览器关闭为止，这期间产生的多次请求和响应加在一起就称之为浏览器和服务器之间的一次会话！  </p></blockquote><blockquote><p>&emsp;会话中往往会产生一些数据，而这些数据往往是需要我们保存起来的，如何保存会话中产生的数据呢？这里可以使用会话技术(也就是Cookie和session)来保存会话中产生的数据</p></blockquote><h2 id="Cookie-和-Session-保存数据的原理"><a href="#Cookie-和-Session-保存数据的原理" class="headerlink" title="Cookie 和 Session 保存数据的原理"></a>Cookie 和 Session 保存数据的原理</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote><p>&emsp;通过 Set-Cookie响应头 和 Cookie请求头 将会话中产生的数据保存在客户端( 浏览器 ) , 当浏览器在此访问服务器时,服务器会获取上一次会话发送给浏览器的Cookie信息,通过这种方式来保存会话中的数据。由于Cookie技术是将会话中产生的数据保存在客户端，每个客户端各自持有自己的数据，当需要时再带给服务器，因此不会发生混乱！  </p></blockquote><blockquote><p> Cookie的API</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建Cookie对象</span></span><br><span class="line">    Cookie c = <span class="keyword">new</span> Cookie(String name, String value);</span><br><span class="line"><span class="comment">// 2.将Cookie添加到response响应中</span></span><br><span class="line">    response.addCookie(Cookie c);<span class="comment">//可以调用多次, 表示将多个cookie添加到响应中</span></span><br><span class="line"><span class="comment">// 3.获取请求中的所有cookie对象组成的数组</span></span><br><span class="line">    Cookie[] cs = request.getCookies();</span><br><span class="line"><span class="comment">//注意：该方法会返回请求中的所有cookie组成的数组, 若请求中没有cookie, 该方法会返回null.</span></span><br></pre></td></tr></table></figure><blockquote><p> 删除Cookie<br> &emsp;没有直接删除cookie的方法，我们可以向浏览器再发送一个同名的cookie(比如名称为prod的cookie), 并设置cookie的存活时间为零, 最后将cookie发送给浏览器。由于浏览器是根据cookie的名字来区分cookie的，如果前后发送了两个名称一样的cookie，后发送cookie会覆盖之前发送的cookie。又由于后发送的cookie生存时间为零，浏览器收到后也会立即删除！！</p></blockquote><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote><p>&emsp;浏览器第一次发送请求需要保存数据时，服务端获取到需要保存的数据，去服务器内部检查一下有没有为当前浏览器服务的session，如果有就直接拿过来用，如果没有session就创建一个新的session拿过来用。接着将数据保存在Session中，做出响应。当浏览器再去访问服务器时，服务器可以从session中获取到之前为当前浏览器保存的数据，通过这种方式，也可以来保存会话中产生的数据。</p></blockquote><h3 id="Cookie-和-Session的异同"><a href="#Cookie-和-Session的异同" class="headerlink" title="Cookie 和 Session的异同"></a>Cookie 和 Session的异同</h3><blockquote><p>相同点：Cookie和Session都是用于保存会话中产生的数据，都是会话技术<br>不同点:<br>Cookie：</p><blockquote><ol><li>Cookie是将会话产生的数据保存在客户端，是客户端技术</li><li>Cookie将数据保存在客户端，不占服务器内存，可以提高服务器性能</li><li>Cookie适合存储安全性要求不高，但是需要长时间保存的数据  <pre><code>（因为保存在浏览器客户端，数据容易丢失，或被窃取）</code></pre></li></ol></blockquote></blockquote><blockquote><p>Session：</p><blockquote><ol><li>Session是将会话产生的数据保存在服务器，是服务器端技术</li><li>Session将数据保存在服务器端，占用服务器内存，影响服务器性能</li><li>Session适合存储对安全性要求较高，但是不需要长时间保存的数据  <pre><code>（不会随着用户操作，导致数据丢失或被窃取，安全性高）</code></pre></li></ol></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;会话技术&quot;&gt;&lt;a href=&quot;#会话技术&quot; class=&quot;headerlink&quot; title=&quot;会话技术&quot;&gt;&lt;/a&gt;会话技术&lt;/h1&gt;&lt;h2 id=&quot;什么是会话&quot;&gt;&lt;a href=&quot;#什么是会话&quot; class=&quot;headerlink&quot; title=&quot;什么是会话?&quot;
      
    
    </summary>
    
    
      <category term="会话基础知识" scheme="https://courage-kevin.github.io/categories/%E4%BC%9A%E8%AF%9D%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://courage-kevin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JDBC知识总结</title>
    <link href="https://courage-kevin.github.io/2018/02/09/Jdbc%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://courage-kevin.github.io/2018/02/09/Jdbc%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2018-02-09T14:10:05.000Z</published>
    <updated>2020-02-06T09:52:24.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h1><h2 id="概念：Java-DataBase-Connectivity"><a href="#概念：Java-DataBase-Connectivity" class="headerlink" title="概念：Java DataBase Connectivity"></a>概念：Java DataBase Connectivity</h2><blockquote><p>JDBC( Java DataBase Connectivity ) 翻译过来就是Java数据库连接，其实就是通过Java语言操作数据库的一门技术。</p></blockquote><h3 id="JDBC由来"><a href="#JDBC由来" class="headerlink" title="JDBC由来"></a>JDBC由来</h3><blockquote><p>由于数据库厂商提供的数据库驱动（操作数据库的jar包）各不相同，导致开发人员的学习成本十分的高。因此SUN公司提出了JDBC这套规范，用来统一访问数据的标准。JDBC本质上是一套接口，SUN要求所有的数据库厂商在设计驱动时，都要实现JDBC这套标准。因此开发人员只要学会JDBC这套接口，所有的数据库驱动就都会使用了。</p></blockquote><h3 id="JDBC包的介绍"><a href="#JDBC包的介绍" class="headerlink" title="JDBC包的介绍"></a>JDBC包的介绍</h3><blockquote><p>JDBC主要是由java.sql 和javax.sql包组成的，并且这两个包已经被集成到J2SE的规范中了，这意味着，只要一个普通的java程序就可以使用JDBC。需要注意的是，JDBC包中大部分都是接口，因此在开发数据库程序时，除了如上的两个包，还需要手动的导入具体的数据库驱动。</p></blockquote><h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><blockquote><p>开发步骤：</p><ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql</li><li>获取执行sql语句的对象 Statement</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol></blockquote><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入驱动jar包</span></span><br><span class="line"><span class="comment">//2.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//3.获取数据库连接对象</span></span><br><span class="line">Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db3"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line"><span class="comment">//4.定义sql语句</span></span><br><span class="line">String sql = <span class="string">"update account set balance = 500 where id = 1"</span>;</span><br><span class="line"><span class="comment">//5.获取执行sql的对象 Statement</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">//6.执行sql</span></span><br><span class="line"><span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line"><span class="comment">//7.处理结果</span></span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="comment">//8.释放资源</span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h2 id="详解各个对象："><a href="#详解各个对象：" class="headerlink" title="详解各个对象："></a>详解各个对象：</h2><blockquote><ol><li>DriverManager：驱动管理对象,用于注册驱动，告诉程序该使用哪一个数据库驱动jar,获取数据库连接。</li><li>Connection：数据库连接对象:获取执行sql的对象,管理事务</li><li>Statement：执行sql的对象            </li><li>ResultSet：结果集对象,封装查询结果</li><li>PreparedStatement：执行sql的对象<ol><li>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</li><li>解决sql注入问题：使用PreparedStatement对象来解决</li><li>预编译的SQL：参数使用?作为占位符</li></ol></li></ol></blockquote><h2 id="SQL注入攻击："><a href="#SQL注入攻击：" class="headerlink" title="SQL注入攻击："></a>SQL注入攻击：</h2><blockquote><p>&emsp; 由于后台的SQL语句是拼接而来的。其中的参数是由用户提交的，如果用户在提交参数时，在其中掺杂了一些SQL关键字或者特殊符号，就可能会导致SQL语句的语意发生变化。从而执行一些意外的操作。</p></blockquote><h2 id="防止SQL注入攻击"><a href="#防止SQL注入攻击" class="headerlink" title="防止SQL注入攻击"></a>防止SQL注入攻击</h2><blockquote><p>&emsp; 使用PreparedStatement对象来替代Statement对象。PreparedStatement对象比Statement对象更安全，效率更高。</p></blockquote><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><blockquote><p>&emsp; 在开发中，所谓的池就是一个容器，来存储程序的中的数据.而数据库连接池就是用来存储数据库连接的池子，用于在整个程序中共享连接，减少连接开关的次数，实现连接的复用，从而提高程序执行的效率.</p></blockquote><h3 id="为什么要使用数据库连接池"><a href="#为什么要使用数据库连接池" class="headerlink" title="为什么要使用数据库连接池?"></a>为什么要使用数据库连接池?</h3><blockquote><p>&emsp; 对于数据库来说，频繁的开关连接会非常的耗费资源，也会导致程序执行效率的低下。我们可以在程序中创建一个池子，在程序启动时就初始化一批连接放在连接池中，当用户需要连接时，就直接从池子中拿一个连接使用，当用完连接后，也不要将连接关闭，而是将连接还回池中，下一个用户需要连接时也是如此。这样可以减少链接开关的次数，从而提供程序执行的效率.</p></blockquote><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//读取资源文件，获取值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建Properties集合类。</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span></span><br><span class="line">        ClassLoader classLoader = JDBCUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        URL res  = classLoader.getResource(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">        String path = res.getPath();</span><br><span class="line">        System.out.println(path);<span class="comment">///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span></span><br><span class="line">        <span class="comment">//2. 加载文件</span></span><br><span class="line">        <span class="comment">// pro.load(new FileReader("D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties"));</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 获取数据，赋值</span></span><br><span class="line">        url = pro.getProperty(<span class="string">"url"</span>);</span><br><span class="line">        user = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">        password = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">        driver = pro.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">        <span class="comment">//4. 注册驱动</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><pre><code class="java">    <span class="comment">/**</span><span class="comment">     * 释放资源</span><span class="comment">     * <span class="doctag">@param</span> stmt</span><span class="comment">     * <span class="doctag">@param</span> conn</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs,Statement stmt, Connection conn)</span></span>{        <span class="keyword">if</span>( rs != <span class="keyword">null</span>){            <span class="keyword">try</span> {                rs.close();            } <span class="keyword">catch</span> (SQLException e) {                e.printStackTrace();            }        }        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>){            <span class="keyword">try</span> {                stmt.close();            } <span class="keyword">catch</span> (SQLException e) {                e.printStackTrace();            }        }        <span class="keyword">if</span>( conn != <span class="keyword">null</span>){            <span class="keyword">try</span> {                conn.close();            } <span class="keyword">catch</span> (SQLException e) {                e.printStackTrace();            }        }    }}</code></pre><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><blockquote><p>   就是讲一堆sql绑定在一起执行，要么全部执行成功，要么全部都执行失败。   </p></blockquote><h3 id="事物的四大特性："><a href="#事物的四大特性：" class="headerlink" title="事物的四大特性："></a>事物的四大特性：</h3><blockquote><ol><li>原子性：事务中的所有操作是一个整体，不能在分割，要么全部执行成功，要么全部都执行失败！</li><li>一致性：事务前后的业务数据保持不变。</li><li>隔离性：事务之间是具有隔离的，一个事务不能访问另外一个事务正在执行的操作。</li><li>持久性：事务一旦提交成功，数据的改变将会是永久的。  </li></ol></blockquote><h3 id="事务的并发读问题："><a href="#事务的并发读问题：" class="headerlink" title="事务的并发读问题："></a>事务的并发读问题：</h3><blockquote><ol><li>脏读：在一个事务中读取到了另外一个事务未提交的数据。</li><li>不可重复读：在一个事务中读取到了另一个事物已提交的数据，两次查询的结果不一致，（修改）操作。</li><li>幻读：对同一张表的两次查询结果不一致（插入/删除）操作。  </li></ol></blockquote><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><blockquote><ol><li>读未提交：安全性最低，不能防止任何读并发问题，但是效率高。</li><li>读已提交：安全性比<font color=red>读未提交</font>高，可以防止脏读，但是不能防止不可重复读，效率比<font color=red>读未提交</font>低。</li><li>可重复读：安全性比<font color=red>读已提交</font>高，可以防止脏读和不可重复读，但是不能防止幻读，效率比<font color=red>读未提交</font>低。</li><li>串行化：安全性高，可以防止一切并发读问题，效率最低，不使用这种隔离级别，因为效率太低。  </li></ol></blockquote><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><blockquote><p>事务隔离级别分四个等级，在相同数据环境下，对数据执行相同的操作，设置不同的隔离级别，可能导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力也是不同的。</p><ol><li>READ UNCOMMITTED（读未提交数据）：安全级别最低, 可能出现任何事务并发问题(比如脏读、不可以重复读、幻读等) 性能最好。</li><li>READ COMMITTED（读已提交数据）（Oracle默认）防止脏读，没有处理不可重复读，也没有处理幻读；性能比REPEATABLE READ好。     </li><li>REPEATABLE READ（可重复读）（MySQL默认）防止脏读和不可重复读，不能处理幻读问题；性能比SERIALIZABLE好。 </li><li>SERIALIZABLE（串行化）不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的；性能最差。  </li></ol></blockquote><blockquote><p>MySQL的默认隔离级别为REPEATABLE READ，即可以防止脏读和不可重复读</p></blockquote><p>​            </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDBC：&quot;&gt;&lt;a href=&quot;#JDBC：&quot; class=&quot;headerlink&quot; title=&quot;JDBC：&quot;&gt;&lt;/a&gt;JDBC：&lt;/h1&gt;&lt;h2 id=&quot;概念：Java-DataBase-Connectivity&quot;&gt;&lt;a href=&quot;#概念：Java-Data
      
    
    </summary>
    
    
      <category term="Jdbc基础知识" scheme="https://courage-kevin.github.io/categories/Jdbc%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://courage-kevin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java常用API小Demo</title>
    <link href="https://courage-kevin.github.io/2018/02/06/Java%E5%B8%B8%E7%94%A8API%E5%B0%8FDemo/"/>
    <id>https://courage-kevin.github.io/2018/02/06/Java%E5%B8%B8%E7%94%A8API%E5%B0%8FDemo/</id>
    <published>2018-02-06T08:28:18.000Z</published>
    <updated>2020-02-06T09:47:09.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h1><p>&emsp;获取给定位置对应的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            0123456789012345</span></span><br><span class="line">String str = <span class="string">"thinking in java"</span>;</span><br><span class="line"><span class="keyword">char</span> c = str.charAt(<span class="number">10</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断回文            0 1 2 3  5 6 7 8</span></span><br><span class="line">String line = <span class="string">"上海自来水自来海上"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;line.length()/<span class="number">2</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(line.charAt(i) !=</span><br><span class="line">   line.charAt(line.length()-<span class="number">1</span>-i)</span><br><span class="line">) &#123;</span><br><span class="line">System.out.print(<span class="string">"不"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"是回文!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h1><p>&emsp;获取给定字符串在当前字符串中的位置，若当前字符串中不含有给定内容则返回值为-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexOfDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            0123456789012345</span></span><br><span class="line">String str = <span class="string">"thinking in java"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = str.indexOf(<span class="string">"in"</span>);</span><br><span class="line">System.out.println(index);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定位置开始检索第一次出现指定内容的位置</span></span><br><span class="line">index = str.indexOf(<span class="string">"in"</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(index);<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检索最后一次出现指定内容的位置</span></span><br><span class="line">index = str.lastIndexOf(<span class="string">"in"</span>);</span><br><span class="line">System.out.println(index);<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lenght"><a href="#lenght" class="headerlink" title="lenght"></a>lenght</h1><p>&emsp;获取当前字符串的长度(字符个数)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"我爱java"</span>;</span><br><span class="line"><span class="keyword">int</span> len = str.length();</span><br><span class="line">System.out.println(<span class="string">"len:"</span>+len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="startsWith-endsWith"><a href="#startsWith-endsWith" class="headerlink" title="startsWith,endsWith"></a>startsWith,endsWith</h1><p>&emsp;判断字符串是否是以给定的字符串开始或结尾的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartsWithDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"thinking in java"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> starts = str.startsWith(<span class="string">"thin"</span>);</span><br><span class="line">System.out.println(starts);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> ends= str.endsWith(<span class="string">"ava"</span>);</span><br><span class="line">System.out.println(ends);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>&emsp;String是不变对象。JVM对String有一个优化，即:常量池,当使用字面量形式创建字符串对象时，JVM会将其缓存在常量池中，当再次使用该字面量创建字符串对象时即重用对象，避免内存中堆积大量内容一样的字符串对象，减少内存开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//字面量  直接量</span></span><br><span class="line">String s1 = <span class="string">"123abc"</span>;</span><br><span class="line">String s2 = <span class="string">"123abc"</span>;</span><br><span class="line">String s3 = <span class="string">"123abc"</span>;</span><br><span class="line"><span class="comment">//s2,s3重用了s1创建的对象</span></span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line">System.out.println(s1==s3);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符串为不变对象</span></span><br><span class="line"><span class="comment"> * 即:字符串一旦创建，内容是不可以改变的，若想</span></span><br><span class="line"><span class="comment"> * 改变内容一定会创建新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(s1);<span class="comment">//123abc!</span></span><br><span class="line">System.out.println(s2);<span class="comment">//123abc</span></span><br><span class="line">System.out.println(s1==s2);<span class="comment">//不再相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里发挥了编译器的一个特性:</span></span><br><span class="line"><span class="comment"> * 编译器在编译源代码时，若发现一个计算表达式</span></span><br><span class="line"><span class="comment"> * 参与运算的内容是确定值时，会在编译期间直接</span></span><br><span class="line"><span class="comment"> * 进行计算，并将计算结果编译到class文件中。避免</span></span><br><span class="line"><span class="comment"> * JVM每次执行程序时再做运算，从而提高性能。</span></span><br><span class="line"><span class="comment"> * 如下代码，编译器编译后改为了:</span></span><br><span class="line"><span class="comment"> * String s4 = "123abc";</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String s4 = <span class="string">"123"</span>+<span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s4);<span class="comment">//123abc</span></span><br><span class="line">System.out.println(s2==s4);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String s5 = <span class="string">"123"</span>;</span><br><span class="line">String s6 = s5 + <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s6);<span class="comment">//123abc</span></span><br><span class="line">System.out.println(s2==s6);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h1><p>&emsp;截取指定范围内的字符串 String substring(int start,int end)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubStringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            01234567890</span></span><br><span class="line">String str = <span class="string">"www.tedu.cn"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java api中有一个特点，通常使用两个数字表示</span></span><br><span class="line"><span class="comment"> * 范围时，都是"含头不含尾"的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String sub = str.substring(<span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line">System.out.println(sub);<span class="comment">//tedu</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个参数的为从指定位置截取到字符串末尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sub = str.substring(<span class="number">4</span>);</span><br><span class="line">System.out.println(sub);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ToUpperCase"><a href="#ToUpperCase" class="headerlink" title="ToUpperCase"></a>ToUpperCase</h1><p>&emsp;将当前字符串中的英文部分转换为全大写或全小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToUpperCaseDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"我爱Java"</span>;</span><br><span class="line"></span><br><span class="line">String upper = str.toUpperCase();</span><br><span class="line">System.out.println(upper);</span><br><span class="line"></span><br><span class="line">String lower = str.toLowerCase();</span><br><span class="line">System.out.println(lower);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h1><p>&emsp;去除当前字符串两边的空白字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrimDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"  hello"</span>;</span><br><span class="line">String trim = str.trim();</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(trim);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h1><p>&emsp;字符串提供了一组重载的valueOf方法。可以将其他类型转换为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">123</span>;</span><br><span class="line">String str = String.valueOf(d);</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="comment">//任何内容和字符串连接结果也能转换为字符串</span></span><br><span class="line">str = d + <span class="string">""</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dou = <span class="number">123.123</span>;</span><br><span class="line">String str2 = String.valueOf(dou);</span><br><span class="line">System.out.println(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="trim-1"><a href="#trim-1" class="headerlink" title="trim"></a>trim</h1><p>&emsp;去除当前字符串两边的空白字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrimDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"  hello"</span>;</span><br><span class="line">String trim = str.trim();</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(trim);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Matches"><a href="#Matches" class="headerlink" title="Matches"></a>Matches</h1><p>&emsp;字符串支持正则表达式方法一: 使用给定的正则表达式验证当前字符串是否符合格式要求,符合则返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String email = <span class="string">"fancq@tedu.cn"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 邮箱的正则表达式</span></span><br><span class="line"><span class="comment"> * \w+@[a-zA-Z0-9]+(\.[a-zA-Z]+)+</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String regex = <span class="string">"\\w+@[a-zA-Z0-9]+(\\.[a-zA-Z]+)+"</span>;</span><br><span class="line"><span class="keyword">boolean</span> match = email.matches(regex);</span><br><span class="line"><span class="keyword">if</span>(match) &#123;</span><br><span class="line">System.out.println(<span class="string">"是邮箱!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"不是邮箱!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll"></a>replaceAll</h1><p>&emsp;字符串支持正则表达式方法三:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"abc123def456ghi"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将当前字符串中的数字部分替换为"#NUMBER#"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">str = str.replaceAll(<span class="string">"\\d+"</span>, <span class="string">"#NUMBER#"</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h1><p>&emsp; 字符串支持正则表达式方法二: 将当前字符串中按照满足正则表达式的部分进行拆分，并将拆分出的每部分以一个字符串数组形式返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"abc123def456ghi"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 按照数字部分拆分，得到所有的字母部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] arr = str.split(<span class="string">"[0-9]+"</span>);</span><br><span class="line">System.out.println(arr.length);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果连续匹配了两次要拆分的内容时，中间会拆分</span></span><br><span class="line"><span class="comment"> * 出一个空字符串，但是若在字符串末尾连续匹配则</span></span><br><span class="line"><span class="comment"> * 所有拆分出的空字符串都会被忽略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">str = <span class="string">"abc,,,def,ghi,,,,,,,,,,,,,,,,,,,"</span>;</span><br><span class="line">arr = str.split(<span class="string">","</span>);</span><br><span class="line">System.out.println(arr.length);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><ol><li>StringBuilder是专门设计用来编辑字符串内容的API。由于String不适合频繁修改，所以在实际开发中如果有经常，修改字符串的操作时，可以使用StringBuilder来完成。</li><li>StringBuilder内部维护一个可变的字符数组，所以修改的过程中资源开销小。并且提供了对应的操作:增，删，改，插</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"好好学习java"</span>;</span><br><span class="line"><span class="comment">//默认方式创建内部表示一个空字符串:""</span></span><br><span class="line"><span class="comment">//StringBuilder builder = new StringBuilder();</span></span><br><span class="line"><span class="comment">//创建时表示给定字符串内容</span></span><br><span class="line">StringBuffer builder = <span class="keyword">new</span> StringBuffer(str);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 好好学习java</span></span><br><span class="line"><span class="comment"> * 好好学习java,为了找个好工作!</span></span><br><span class="line"><span class="comment"> * append:将指定内容追加到当前字符串末尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">builder.append(<span class="string">",为了找个好工作!"</span>);</span><br><span class="line">str = builder.toString();</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 好好学习java,为了找个好工作!</span></span><br><span class="line"><span class="comment"> * 好好学习java,就是为了改变世界!</span></span><br><span class="line"><span class="comment"> * replace:将指定范围内的字符串替换为给定内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">builder.replace(<span class="number">9</span>, <span class="number">16</span>, <span class="string">"就是为了改变世界"</span>);</span><br><span class="line">str = builder.toString();</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 好好学习java,就是为了改变世界!</span></span><br><span class="line"><span class="comment"> * ,就是为了改变世界!</span></span><br><span class="line"><span class="comment"> * delete:删除指定范围内的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">builder.delete(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">str = builder.toString();</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ,就是为了改变世界!</span></span><br><span class="line"><span class="comment"> * 活着,就是为了改变世界!</span></span><br><span class="line"><span class="comment"> * insert:将指定内容插入到指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">builder.insert(<span class="number">0</span>, <span class="string">"活着"</span>);</span><br><span class="line">str = builder.toString();</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="StringBuilder效率测试"><a href="#StringBuilder效率测试" class="headerlink" title="StringBuilder效率测试"></a>StringBuilder效率测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++) &#123;</span><br><span class="line">builder.append(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"执行完毕!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>&emsp;包装类是为了解决基本类型不能直接参与面向对象开发的问题，其中6个数字类型的包装类都继承自java.lang.Number。其余两个直接继承自Object，Number是一个抽象类，定义了数字类型包装类公有的行为，允许在数字类型之间互转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">128</span>;</span><br><span class="line"><span class="comment">//      将基本类型转换为包装类</span></span><br><span class="line"><span class="comment">//Integer i1 = new Integer(d);</span></span><br><span class="line"><span class="comment">//Integer i2 = new Integer(d);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从基本类型转换为包装类建议使用valueOf方法:</span></span><br><span class="line">Integer i1 = Integer.valueOf(d);</span><br><span class="line">Integer i2 = Integer.valueOf(d);</span><br><span class="line"></span><br><span class="line">System.out.println(i1==i2);<span class="comment">//false</span></span><br><span class="line">System.out.println(i1.equals(i2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dou = <span class="number">1.0</span>;</span><br><span class="line">Double dou1 = Double.valueOf(dou);</span><br><span class="line">Double dou2 = Double.valueOf(dou);</span><br><span class="line">System.out.println(dou1==dou2);</span><br><span class="line">System.out.println(dou1.equals(dou2));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将包装类转换为基本类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> in = i1.intValue();</span><br><span class="line"> System.out.println(in);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">double</span> dd = i1.doubleValue();</span><br><span class="line"> System.out.println(dd);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//可能出现溢出问题</span></span><br><span class="line"> <span class="keyword">byte</span> b = i1.byteValue();</span><br><span class="line"> System.out.println(b);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 数字类型的包装类都支持两个常量:</span></span><br><span class="line"><span class="comment">  * MAX_VALUE,MIN_VALUE</span></span><br><span class="line"><span class="comment">  * 用于表示其对应的基本类型数据的取值范围</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="comment">//int最大值与最小值?</span></span><br><span class="line"> <span class="keyword">int</span> imax = Integer.MAX_VALUE;</span><br><span class="line"> System.out.println(imax);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> imin = Integer.MIN_VALUE;</span><br><span class="line"> System.out.println(imin);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">long</span> lmax = Long.MAX_VALUE;</span><br><span class="line"> System.out.println(lmax);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h1><p>&emsp;JDK5发布时，推出了一个特性:自动拆装箱,允许编译器在编译源代码时将基本类型与引用类型之间互相,赋值时补全代码自动进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 触发了编译器自动拆箱特性:</span></span><br><span class="line"><span class="comment"> * 编译器会将下面的代码改为</span></span><br><span class="line"><span class="comment"> * int d = new Integer(1).intValue();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 触发了自动装箱特性:</span></span><br><span class="line"><span class="comment"> * 编译器会改为:</span></span><br><span class="line"><span class="comment"> * Integer i = Integer.valueOf(d);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Integer i = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h1><p>&emsp;包装类提供了一个静态方法:parseXXX(String str)，可以将给定的字符串转换为对应的基本类型，前提是该字符串，内容要正确的描述基本类型可以保存的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> d = Integer.parseInt(str);</span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dou = Double.parseDouble(str);</span><br><span class="line">System.out.println(dou);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Object常用方法"><a href="#Object常用方法" class="headerlink" title="Object常用方法"></a>Object常用方法</h1><p>&emsp;使用当前类测试Object常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写toString方法。</span></span><br><span class="line"><span class="comment"> * toString方法是一个非常常用的方法，很多API的操作</span></span><br><span class="line"><span class="comment"> * 都会间接调用该方法。</span></span><br><span class="line"><span class="comment"> * 方法的目的是将当前对象转换为字符串，具体返回的字符串</span></span><br><span class="line"><span class="comment"> * 格式没有固定要求，遵循的原则是返回的内容中包含当前</span></span><br><span class="line"><span class="comment"> * 对象的属性信息，可以通过该字符串的内容直观反应出当前</span></span><br><span class="line"><span class="comment"> * 对象的内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//(1,2)</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"("</span>+x+<span class="string">","</span>+y+<span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object定义的equals方法的设计意图是比较两个对象的</span></span><br><span class="line"><span class="comment"> * 内容是否相同。</span></span><br><span class="line"><span class="comment"> * 如果不重写该方法，那么Object内部是用"=="比较的，</span></span><br><span class="line"><span class="comment"> * 这样就失去了equals比较的意义了。所以当我们需要调用</span></span><br><span class="line"><span class="comment"> * 一个类的equals时，该方法就应当重写。</span></span><br><span class="line"><span class="comment"> * 注:java提供的类大部分都已经重写过了。只有我们自定义</span></span><br><span class="line"><span class="comment"> * 的类需要自行重写。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * p.equals(p2)</span></span><br><span class="line"><span class="comment"> * this:p</span></span><br><span class="line"><span class="comment"> * o:p2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(o==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>==o) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> Point) &#123;</span><br><span class="line">Point p = (Point)o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.x==p.x&amp;&amp;<span class="keyword">this</span>.y==p.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//创建一个RAF用于读取原文件</span></span><br><span class="line">RandomAccessFile src</span><br><span class="line">= <span class="keyword">new</span> RandomAccessFile(<span class="string">"mv.mp4"</span>,<span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再创建另一个RAF用于向复制文件中写</span></span><br><span class="line">RandomAccessFile desc</span><br><span class="line">= <span class="keyword">new</span> RandomAccessFile(<span class="string">"mv_cp.mp4"</span>,<span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">//用于记录每次读取到的字节</span></span><br><span class="line"><span class="keyword">int</span> d = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 循环从原文件中读取每一个字节，只要没有读取到</span></span><br><span class="line"><span class="comment"> * 文件末尾，就将读取到的字节写入到复制文件中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">while</span>( (d = src.read())  != -<span class="number">1</span>  ) &#123;</span><br><span class="line">desc.write(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"复制完毕!耗时:"</span>+(end-start)+<span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">src.close();</span><br><span class="line">desc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java-io-RandomAccessFile类"><a href="#java-io-RandomAccessFile类" class="headerlink" title="java.io.RandomAccessFile类"></a>java.io.RandomAccessFile类</h1><p>&emsp; 用来读写文件数据的类，其基于指针对文件数据进行读写操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RandomAccessFile创建有两种模式:</span></span><br><span class="line"><span class="comment"> * r:只读模式，只读取文件数据，并不会写入内容</span></span><br><span class="line"><span class="comment"> * rw:读写模式，对文件既可以读也可以写。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 常见构造方法:</span></span><br><span class="line"><span class="comment"> * RandomAccessFile(String path,String mode)</span></span><br><span class="line"><span class="comment"> * RandomAccessFile(File file,String mode)</span></span><br><span class="line"><span class="comment"> * mode:创建的模式(r,rw)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对当前目录下的raf.dat文件进行读写操作</span></span><br><span class="line"><span class="comment"> * 对于"rw"模式创建时，若指定的文件不存在时会自动</span></span><br><span class="line"><span class="comment"> * 创建出来，若为"r"只读模式时，若指定的文件不存在</span></span><br><span class="line"><span class="comment"> * 则会直接抛出异常:FileNotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"raf.dat"</span>,<span class="string">"rw"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * void write(int d)</span></span><br><span class="line"><span class="comment"> * 向文件中写入1个字节，写入的是给定的int值对应的</span></span><br><span class="line"><span class="comment"> * 2进制的"低八位"</span></span><br><span class="line"><span class="comment"> *                            vvvvvvvv</span></span><br><span class="line"><span class="comment"> * 00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment"> * 00000000 00000000 00000000 11111111</span></span><br><span class="line"><span class="comment"> * 00000000 00000000 00000001 00000000</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 00000001 00000010</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">raf.write(<span class="number">1</span>);</span><br><span class="line">raf.write(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"写出完毕!"</span>);</span><br><span class="line"></span><br><span class="line">raf.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h1><p>&emsp;使用File创建一个新文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在当前目录下新建一个文件test.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"./test.txt"</span>);</span><br><span class="line"><span class="comment">//判断File表示的文件或目录是否已经真实存在了</span></span><br><span class="line"><span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line"><span class="comment">//将File表示的文件创建出来</span></span><br><span class="line">file.createNewFile();</span><br><span class="line">System.out.println(<span class="string">"文件创建成功!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"文件已存在!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>&emsp;删除一个文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除当前目录下的test.txt</span></span><br><span class="line"><span class="comment"> * "./"可以忽略不写，默认就是当前目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="keyword">if</span>(file.exists()) &#123;</span><br><span class="line">file.delete();</span><br><span class="line">System.out.println(<span class="string">"文件已删除!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"文件不存在!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h1><p>&emsp;创建一个目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在当前目录下新建一个目录:demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"demo"</span>);</span><br><span class="line"><span class="keyword">if</span>(!dir.exists()) &#123;</span><br><span class="line"><span class="comment">//创建该目录</span></span><br><span class="line">dir.mkdir();</span><br><span class="line">System.out.println(<span class="string">"目录已创建!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"目录已存在!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建多级目录"><a href="#创建多级目录" class="headerlink" title="创建多级目录"></a>创建多级目录</h1><p>&emsp;创建一个多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *在当前目录下新建目录:</span></span><br><span class="line"><span class="comment"> *./a/b/c/d/e/f</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"./a/b/c/d/e/f"</span>);</span><br><span class="line"><span class="keyword">if</span>(!dir.exists()) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mkdirs会将所有不存在的父目录一同创建出来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dir.mkdirs();</span><br><span class="line">System.out.println(<span class="string">"目录已创建!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"目录已存在!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;charAt&quot;&gt;&lt;a href=&quot;#charAt&quot; class=&quot;headerlink&quot; title=&quot;charAt&quot;&gt;&lt;/a&gt;charAt&lt;/h1&gt;&lt;p&gt;&amp;emsp;获取给定位置对应的字符&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Java基础知识" scheme="https://courage-kevin.github.io/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://courage-kevin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Http协议基础知识</title>
    <link href="https://courage-kevin.github.io/2018/02/06/Http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://courage-kevin.github.io/2018/02/06/Http%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2018-02-06T07:59:51.000Z</published>
    <updated>2020-02-06T11:34:31.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h1><h2 id="什么是http协议"><a href="#什么是http协议" class="headerlink" title="什么是http协议"></a>什么是http协议</h2><p>当在上网浏览网页的时候，浏览器和服务器之间就会通过Http在Internet上进行数据的发送和接受。<br>HTTP协议规定了浏览器和服务器之间通信的方式，也可以说是通信的规则。是应用层协议，是一个基于请求/响应模式的，无状态的协议。</p><blockquote><p>具体说，HTTP协议中主要规定了两个内容：</p><ol><li>规定了浏览器该如何给服务器发送请求信息（即请求信息的格式）</li><li>同时也规定了服务器该如何给浏览器做响应信息（即响应信息的格式）   </li></ol></blockquote><hr><h2 id="Http1-0"><a href="#Http1-0" class="headerlink" title="Http1.0"></a>Http1.0</h2><blockquote><p>当连接建立之后，浏览器发送一个请求，服务器回应一个消息，之后连接就被关闭。当浏览器下一次请求的时候，需要重新建立新的连接，显然这种需要不断建立连接的通信方式开销较大。早期的web页面通常只包含HTML文件，因此即使建立连接的开销比较大，也不会有太大的影响。而现在的web页面通常包含多种资源，（图片，动画，声音），每获取一种资源，就建立一次连接。这样就增加了HTTP服务器的开销，造成了Internet上的信息阻塞。</p></blockquote><hr><h2 id="Http1-1"><a href="#Http1-1" class="headerlink" title="Http1.1"></a>Http1.1</h2><blockquote><p>因此在Http1.1版本中，给出了一个持续连接的机制，并将其作为1.1中建立连接的缺省行为，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到响应，然后继续发送请求并在此得到回应，而且客户端还可以发送流水线请求，也就是说，客户端可以连续发送多个请求，而不用等待每一个响应的到来。</p></blockquote><hr><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><blockquote><ol><li>客户端与服务器端建立连接前，客户端会向服务器发送第一条消息，询问服务器端是否准备好了。第一次握手</li><li>服务器端收到客户端发来的询问之后，会给客户端发送一条消息，告诉客户端已经准备好了。第二次握手</li><li>当客户端在收到服务器端发过来的消息之后，会在此确认，客户端会在向服务器发起响应确认准备好了，第三次握手。之后建立连接</li></ol></blockquote><hr><h2 id="Http工作时遵循的基本原则-了解"><a href="#Http工作时遵循的基本原则-了解" class="headerlink" title="Http工作时遵循的基本原则(了解):"></a>Http工作时遵循的基本原则(了解):</h2><blockquote><ol><li>基于请求响应模型</li><li>一次请求只对应一次响应</li><li>只能是浏览器向服务器发送请求, 服务器只能等待浏览器的请求, 再根据请求做出回应</li></ol></blockquote><hr><h2 id="GET请求和POST请求方式的区别："><a href="#GET请求和POST请求方式的区别：" class="headerlink" title="GET请求和POST请求方式的区别："></a>GET请求和POST请求方式的区别：</h2><p>两者之间的区别主要体现在请求参数发送过程的不相同</p><blockquote><p>GET提交: 通过请求行拼接参数将数据发送给服务器<br>&emsp;1.通过地址栏携带参数, 相对不安全<br>&emsp;2.通过地址栏发送数据, 数据量不能太大(不能超过1kb或者是4kb);  </p></blockquote><blockquote><p>POST提交: 通过请求实体内容携带参数, 数据不会显示在地址栏<br>&emsp;1.参数不会出现地址栏, 相对更安全<br>&emsp;2.数据通过请求实体内容发送, 数据量理论上没有限制.</p></blockquote><hr><h2 id="服务器种类："><a href="#服务器种类：" class="headerlink" title="服务器种类："></a>服务器种类：</h2><blockquote><p>Tomcat、Resin、Jetty、Weblogic、WebSphere、JBoss</p></blockquote><blockquote><p>B/S：Browser Server 浏览器服务器模型  （不需要下载客户端的） 京东、淘宝、网页游戏。<br>优点：不需要下载客户端程序，使用浏览器可以直接访问，程序的升级操作是在服务器端进行的。<br>缺点：浏览器具有一定的局限性，页面的展示差，页面的数据需要从服务器实时获取，对网速的依赖很高</p></blockquote><blockquote><p>C/S：Client Server客户端服务器模型       （需要下载客户端的） QQ  LOL 梦幻西游 。<br>优点：客户端可以任意设计，页面的展示能力强。由于大量资源已经保存在了客户端，对服务器的交互仅仅是一些数据的变化，对于网速的依赖很低。<br>缺点：第一次使用时需要下载客户端程序，一旦程序需要升级操作，所有的客户端程序都需要升级。</p></blockquote><hr><h2 id="XML解析方式："><a href="#XML解析方式：" class="headerlink" title="XML解析方式："></a>XML解析方式：</h2><h3 id="DOM解析："><a href="#DOM解析：" class="headerlink" title="DOM解析："></a>DOM解析：</h3><blockquote><p>原理：<br>解析器将整个xml文档加载进内存，保存为一颗Document的对象树，<br>通过Document对象，得到树上的节点对象，对每个对象提供增删改查操作对应的方法<br>优点：<br>&emsp;1.可以十分方便对节点进行增删改查操作，<br>&emsp;2.解析一次即可重复使用数据由于在内存中保存了文档结构树，<br>缺点：<br>&emsp;1.如果文档较大，占用内存空间，甚至内存溢出<br>&emsp;2.将整个文档解析完才能操作，相对耗费时间，效率低</p></blockquote><h3 id="SAX解析："><a href="#SAX解析：" class="headerlink" title="SAX解析："></a>SAX解析：</h3><blockquote><p>原理：解析器逐行扫描xml文档，利用处理器接口中的方法进行解析<br>优点：<br>&emsp;1.无需将整个xml文档加载到内存，占用内存小<br>&emsp;2.由于逐行解析，遇到需要内容停下来处理，效率高<br>缺点：<br>&emsp;1.每次需要数据，都要重新解析<br>&emsp;2.只能读取数据，不能做增删改操作。   </p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Http协议&quot;&gt;&lt;a href=&quot;#Http协议&quot; class=&quot;headerlink&quot; title=&quot;Http协议&quot;&gt;&lt;/a&gt;Http协议&lt;/h1&gt;&lt;h2 id=&quot;什么是http协议&quot;&gt;&lt;a href=&quot;#什么是http协议&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="http基础知识" scheme="https://courage-kevin.github.io/categories/http%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://courage-kevin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识总结</title>
    <link href="https://courage-kevin.github.io/2018/02/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://courage-kevin.github.io/2018/02/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2018-02-01T15:04:33.000Z</published>
    <updated>2020-02-06T09:47:11.654Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础知识整理</p><a id="more"></a><h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="Java编译运行过程"><a href="#Java编译运行过程" class="headerlink" title="Java编译运行过程"></a>Java编译运行过程</h2><ol><li>编译期：java源文件，经编译生成.class文件</li><li>运行期：JVM加载.class文件，并运行class</li><li>特点：跨平台，一次编译到处使用</li></ol><h2 id="名词释义"><a href="#名词释义" class="headerlink" title="名词释义"></a>名词释义</h2><ol><li>JVM：java虚拟机，作用就是加载.class文件，运行.class文件</li><li>JRE： java开发环境，除了包含JVM外，还包含java程序运行所必须的环境</li><li>JDK：java开发工具包，除了包含JRE外，还包含编译，运行等命令工具3. </li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th><strong>byte类型</strong></th><th><strong>8位</strong></th><th><strong>范围：-128~127</strong></th></tr></thead><tbody><tr><td><strong>short 类型</strong></td><td><strong>16位</strong></td><td><strong>范围：-32768~32767</strong></td></tr><tr><td><strong>char  类型</strong></td><td><strong>16位</strong></td><td><strong>范围：\u0000~\u65535</strong></td></tr><tr><td><strong>int类型</strong></td><td><strong>32位</strong></td><td><strong>范围：-2147483648~2147483647</strong></td></tr><tr><td><strong>long 类型</strong></td><td><strong>64位</strong></td><td><strong>范围：很大很大 2^63</strong></td></tr><tr><td><strong>float 类型</strong></td><td><strong>32位</strong></td><td></td></tr><tr><td><strong>double 类型</strong></td><td><strong>64位</strong></td><td></td></tr><tr><td><strong>boolean 类型</strong></td><td><strong>8位</strong></td><td></td></tr></tbody></table><h2 id="基本类型自动转换"><a href="#基本类型自动转换" class="headerlink" title="基本类型自动转换"></a>基本类型自动转换</h2><ol><li>从小到大依次为：byte &lt; short &lt; int &lt; long &lt; float &lt; double</li><li>自动类型转换：小类型转大类型 （小杯子往大杯子倒水）</li><li>强制类型转换：大类型转小类型 （大杯子往小杯子倒数）</li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol><li>算数：    +，-，*，/，%，++，–</li><li>关系：&gt;,&lt;,&gt;=,&lt;=,==,!=,boolean</li><li>逻辑：&amp;&amp;，||，!boolean</li><li>赋值：=，+=，-=，*=，/=，%=</li><li>字符连接运算符：+</li><li>条件/三目运算：boolean?数1:数2;</li></ol><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><ol><li>If</li><li>If…else</li><li>If…elss     if</li><li>Switch…case</li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ol><li>while循环</li><li>do…while循环</li><li>for循环</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li>数组的定义：int [ ] arr =new int [ 10 ] </li><li>数组的初始化：int [ ] arr = new int [ ] </li><li>数组的访问：通过数组名.length可以获取数组的长度，也就是数组内元素的个数通过索引来访问数组元素，下标从0开始，最大到数组长度-1</li><li>数组遍历<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[<span class="number">3</span>] = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);    <span class="comment">//正序输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.println(arr[i]);    <span class="comment">//倒序输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table><thead><tr><th><strong>private</strong></th><th><strong>同类可见</strong></th><th><strong>可以修饰变量、方法</strong></th><th><strong>注意：不能修饰类(外部类)</strong></th></tr></thead><tbody><tr><td><strong>default</strong></td><td><strong>同包同类可见</strong></td><td><strong>可以修饰类、接口、变量、方法</strong></td><td></td></tr><tr><td><strong>protected</strong></td><td><strong>同包同类和所有子类可见</strong></td><td><strong>可以修饰变量、方法</strong></td><td><strong>注意不能修饰类(外部类)</strong></td></tr><tr><td><strong>public</strong></td><td><strong>所有类可见</strong></td><td><strong>可以修饰类、接口、变量、方法</strong></td><td></td></tr></tbody></table><h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><p>&emsp;为了实现某一些功能，java也提供了许多非访问修饰符</p><blockquote><p>static修饰符：</p><ol><li>static关键字修饰的变量称之为静态变量，无论一个类实例化多少对象，他的静态变量只有唯一的一个。</li><li>static关键字修饰的方法称之为静态方法，静态方法只能使用类的静态变量，不可以使用非静态变量。</li></ol></blockquote><blockquote><p>final修饰符：</p><ol><li>Final关键字可以修饰类，表示不能有子类。</li><li>Final关键字可以修饰变量，表示变量不能被修改，只能有唯一一次赋值。</li><li>Final关键字可以修饰方法，表示不能被子类覆盖重写。</li><li>Final关键字修饰引用类型变量，地址值不能变，但是对象的属性可以通过set方法改变。</li></ol></blockquote><blockquote><p>abstract修饰符：<font color=red>被abstract修饰的类和方法叫做抽象类和抽象方法</font>。</p><ol><li>抽象类：抽象类不能用来实例化对象，目的：是为了将来对该类进行扩充。</li><li>抽象方法：继承抽象类的子类必须实现父类的所有抽象方法，除非这个子类也是抽象类，</li><li>注意：如果一个类包含若干个抽象方法，那么该类必须声明为抽象类，抽象类不可以包含抽象方法。  </li></ol></blockquote><blockquote><p>抽象加单总结:</p><ol><li>抽象方法的意义：在于将方法的设计和方法的实现分离。</li><li>抽象类需要被继承，抽象类定义的抽象方法子类必须重写。</li><li>抽象类不能创建对象，但是可以包含构造方法，成员属性，普通方法。</li></ol></blockquote><hr><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>&emsp;一个事物的内部包含另外一个事物，就是一个类内部包含另外一个类，比如身体和心脏的关系，汽车和发动机的关系。</p><blockquote><h2 id="成员内部类："><a href="#成员内部类：" class="headerlink" title="成员内部类："></a>成员内部类：</h2><p>定义在类里面的类，叫做成员内部类。<br>使用成员内部类的两种方式:</p><ol><li>间接方式：在外部类的方法中，使用内部类，然后main只是调用外部类的方法。</li><li>直接方式：外部类名称.内部类名称<br>对象名 = new 外部类名称() . new 内部类名称(); (外部.内部)  </li></ol></blockquote><blockquote><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>&emsp;定在在方法里面的类，叫做局部内部类，局部内部类包含了匿名内部类。  </p></blockquote><blockquote><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>作用：如果接口的实现类，或者是父类的子类，只需要使用唯一一次，那么这种情况下，就可以省略该类的定义，改用匿名内部类。<br>定义格式：接口名称  对象名 = new 接口名称(){ //方法体中重写所有的抽象方法 }； </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Myinterface myinterface = <span class="keyword">new</span> Myinterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类方法执行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        myinterface.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h2><blockquote><p>类是一个模板，包含对象的属性，方法。<br>我们把它理解为造汽车的图纸，图纸包含了制造汽车的各个部件的尺寸，参数等。</p></blockquote><h2 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h2><blockquote><p>对象是类的一个实例。<br>我们可以对象理解为根据图纸制造出来的汽车。  </p></blockquote><h2 id="类和对象之间的关系？"><a href="#类和对象之间的关系？" class="headerlink" title="类和对象之间的关系？"></a>类和对象之间的关系？</h2><blockquote><p>汽车就好比一个对象，图纸就好比是一个类，有了图纸才能设计出汽车，换而言之也就是有了类才能创建对象（也叫实例）。  </p></blockquote><h2 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征?"></a>面向对象的特征?</h2><blockquote><p>记住并理解这重要的6个字，<font color=red><em>封装、继承、多态</em></font>&emsp;称之为面向对象的三大特征 。</p></blockquote><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h3><blockquote><h4 id="封装的概念："><a href="#封装的概念：" class="headerlink" title="封装的概念："></a>封装的概念：</h4><p>&emsp;面向对象的封装就是把描述一个对象的属性和行为的代码封装到一个类当中，属性用变量定义，行为用方法定义，然后运用访问修饰符，修饰成员变量及方法，就基本上实现了对象的封装。    </p></blockquote><blockquote><h4 id="封装的好处："><a href="#封装的好处：" class="headerlink" title="封装的好处："></a>封装的好处：</h4><p>&emsp;封装的目标就是要实现软件内部的“高内聚、低耦合”，防止程序相互依赖而带来的变动的影响。解耦</p></blockquote><blockquote><h4 id="封装的总结："><a href="#封装的总结：" class="headerlink" title="封装的总结："></a>封装的总结：</h4><p>封装类，封装的就是对象的属性和行为。<br>封装方法，封装的就是具体业务逻辑功能的实现。<br>访问控制，访问修饰符（private、public….）用来封装具体的访问权限。</p></blockquote><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h3><blockquote><h4 id="封装的概念：-1"><a href="#封装的概念：-1" class="headerlink" title="封装的概念："></a>封装的概念：</h4><p>&emsp; 继承也是泛化（抽取共性）的过程，在开发中我们先将子类共有的属性及方法全部抽取到父类，然后通过子类去继承父类的属性及方法实现数据和方法的共享，这是类之间的一种关系，<font color=red>继承的好处就是提高了代码的可重用性和扩展性</font>。</p></blockquote><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h3><blockquote><h4 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h4><p>&emsp; 一个对象拥有多种形态，这就是多态，代码体现多态其实就是一句话，<font color=red>父类引用指向子类对象</font>  </p></blockquote><blockquote><h4 id="多态的格式和使用"><a href="#多态的格式和使用" class="headerlink" title="多态的格式和使用"></a>多态的格式和使用</h4><ol><li>父类名称  对象名称  =  new 子类名称（）；</li><li>接口名称  对象名称  =  new 实现类名称（）；</li></ol></blockquote><blockquote><h4 id="多态中访问成员变量的两种方式及规则"><a href="#多态中访问成员变量的两种方式及规则" class="headerlink" title="多态中访问成员变量的两种方式及规则"></a>多态中访问成员变量的两种方式及规则</h4><ol><li>直接通过对象名称访问成员变量：看等号左边是谁就优先用谁，没有则会往上寻找父类中是否存在该变量。</li><li>间接通过成员方法访问成员变量：看该方法属于谁就优先用谁，没有则会往上寻找父类中是否存在该变量。</li></ol></blockquote><blockquote><h4 id="多态中成员方法的访规则"><a href="#多态中成员方法的访规则" class="headerlink" title="多态中成员方法的访规则"></a>多态中成员方法的访规则</h4><ol><li>看等号右边new的是谁，就优先用谁的方法。没有则会找到父类的方法。</li></ol></blockquote><blockquote><h4 id="对比多态中成员变量和成员方法有何不同"><a href="#对比多态中成员变量和成员方法有何不同" class="headerlink" title="对比多态中成员变量和成员方法有何不同"></a>对比多态中成员变量和成员方法有何不同</h4><ol><li>成员变量：编译看左边，运行还看左边</li><li>成员方法：编译看左边，运行看右边。</li></ol></blockquote><blockquote><h4 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h4><p>&emsp; 比如Animal类有cat和dog两个子类，Animal有eat（）方法，cat和dog继承Animal也拥有了eat方法，但是狗和猫吃的东西不一样，有自己各自的方法。我们在写代码的时候  Animal  obj = new Dog();  并调用 obj.eat();  这里在编译时调用的时Animal类中的eat()方法，但是在程序运行的时候，会执行dog类中的eat()方法。new Cat();也是同理。这样就保证了等号左边的一致性，你new谁，在程序运行时，就调用谁的方法。一句话，编译看左边，运行看右边。<font color=red>多态的好处就是允许程序在运行的时候动态的创建对象，并调用对象的方法</font>。  </p></blockquote><blockquote><h4 id="对象向上转型"><a href="#对象向上转型" class="headerlink" title="对象向上转型"></a>对象向上转型</h4><p>&emsp; 父类引用指向子类对象。多态的写法就是向上转型。比如 将一个狗对象，当作父类动物对象来看待。<br>&emsp; 注意：向上转型的弊端，对象一旦向上转型为父类，那么就无法调用子类原本特有的方法。因为编译的时候根本无法通过对象点出来子类的方法，而只能调用父类的方法。</p></blockquote><blockquote><h4 id="对象的向下转型"><a href="#对象的向下转型" class="headerlink" title="对象的向下转型"></a>对象的向下转型</h4><p>&emsp; 进行还原动作，比如你将一个子类对象向上转型为父类对象，你还可以将该对象转换回来，比如将狗的实例转为动物的实例，在将动物实例转换回狗的实例 　<br>&emsp; Dog dog = (Dog) Animal();<br>&emsp; 但是如果你在向下转型的过程中，向上转型为动物对象的狗对象还原为一个猫对象，那么就回报错。一定要注意，向下转型的时候对象的原本类型是什么，可以借助 instance of 关键字。</p><h4 id="instance-of"><a href="#instance-of" class="headerlink" title="instance of"></a>instance of</h4><p>&emsp;可以判断一个父类引用的对象，本来是什么子类。可以帮助我们在写代码的过程中，安全的向下转型。</p></blockquote><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{            Animal animal = <span class="keyword">new</span> Dog();        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog){            Dog dog = (Dog) animal;            dog.eat();        }        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat){            Cat cat = (Cat) animal;            cat.eat();        }         }</code></pre><hr><h1 id="接口和抽象"><a href="#接口和抽象" class="headerlink" title="接口和抽象"></a>接口和抽象</h1><blockquote><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><ol><li>抽象类不能直接new</li><li>必须需要子类实现抽象类</li><li>子类需要覆盖父类的抽象方法</li><li>创建子类进行使用  </li></ol></blockquote><blockquote><p>注意事项：</p><ol><li>抽象类可以有构造函数，是供子类创建对象时，初始化父类成员使用的。</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必须定义为抽象类。</li><li>抽象类的子类，必须重写子类中的所有抽象方法。否则编译报错。除非子类也是抽象类。  </li></ol></blockquote><blockquote><h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>&emsp;就是多个类的公共规范，接口是一种引用数据类型，最重要的内容就是其中的抽象方法（usb接口，插座）  </p></blockquote><blockquote><h2 id="接口的使用步骤"><a href="#接口的使用步骤" class="headerlink" title="接口的使用步骤"></a>接口的使用步骤</h2><ol><li>接口不能直接使用，必须有一个实现类来实现接口。</li><li>接口的实现类必须重写接口中所有的抽象方法</li><li>创建实现类对象，进行使用。<br>注意事项：如果实现类并没有重写接口中的所有方法，那么这个实现类就必须是抽象类。   </li></ol></blockquote><blockquote><h2 id="接口可以包含、常量、抽象方法、默认方法、静态方法、私有方法"><a href="#接口可以包含、常量、抽象方法、默认方法、静态方法、私有方法" class="headerlink" title="接口可以包含、常量、抽象方法、默认方法、静态方法、私有方法"></a>接口可以包含、常量、抽象方法、默认方法、静态方法、私有方法</h2><ol><li><font color=red>默认方法：就是定义在接口中的静态方法。包含public default 方法名 { 方法体 }</font>。</li></ol><ul><li>作用：可以解决接口升级的问题，因为接口中添加新的抽象方法，其实现类必须全部重写，</li><li>注意：并且可以通过接口实现类对象直接调用，也可以被接口实现类覆盖重写。</li></ul><ol start="2"><li><font color=red>静态方法：就是定义在接口中的静态方法。包含public static 方法名 { 方法体 }</font>。</li></ol><ul><li>作用：不创建对象直接调用接口中的方法。静态方法和对象无关</li><li>注意：不能通过接口实现类的对象来调用接口中的静态方法。而是直接用接口名称调用（一个类可以实现多个接口，多个接口中静态方法有可能产生冲突）（默认方法和静态方法只有在java 8会以上版本才支持）</li></ul><ol start="3"><li><font color=red>私有方法：就是在接口中定义private关键字的方法，默认接口中方法必须是public的。（私有方法只有在java 9 或以上版本才支持）</font></li></ol><ul><li>普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名称（参数列表）{ 方法体 }</li><li>静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名称（参数列表）{ 方法体 }</li><li>作用：某些场景，我们需要在接口中抽取一个公有的方法，来解决两个或多个方法之间代码重复的问题，并规定只能在接口中调用，就可以通过私有方法来解决。  </li></ul><ol start="4"><li><font color=red>常量：接口当中也可以定义“成员变量”</font>。</li></ol><ul><li>类和类之间是单继承的，直接父类只有一个。</li><li>类和接口之间是多实现的，一个接口可以实现（implements）多个接口，注意处理抽象方法的冲突问题就行。</li><li>接口与接口之间是多继承的。就是一个接口可以继承（extends）多个接口，那么该接口就拥有了其他接口的全部抽象方法。  </li></ul><ol start="5"><li><font color=red>注意事项（总结）</font>。</li></ol><ul><li>接口不能有静态代码块或者构造方法。</li><li>一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</li><li>如果实现类所实现的接口中，存在重复的抽象方法，那么只需要重写覆盖一次即可。</li><li>如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类必须是一个抽象类。</li><li>如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类必须冲突的默认方法进行重写。</li><li>如果一个类的直接父类当中的方法，和接口当中的默认方法产生了冲突，会优先用父类的方法。（先继承，后实现的特点）。</li></ul></blockquote><hr><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol><li>堆中存储new出来的对象(包括实例变量)</li><li>垃圾：没有任何引用所指向的对象，垃圾回收器(GC)不定时到内存中清扫垃圾，回收过程是透明的，调用System.gc()可以建议虚拟机尽快调度GC来回收</li><li>内存泄漏:不再使用的内存还没有被及时的回收、建议:对象不再使用时及时将引用设置为null</li><li>实例变量的生命周期：创建对象时存储在堆中，对象被回收时一并被回收  </li></ol></blockquote><blockquote><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol><li>存储正在调用的方法中的局部变量(包括方法的参数)</li><li>调用方法时，会在栈中为该方法分配一块对应的栈帧，栈帧中存储局部变量(包括方法的参数)，当方法执行结束后，栈帧被清除，局部变量一并失效</li><li>局部变量的生命周期:调用方法时存储在栈中，方法结束时与栈帧一并被清除</li></ol></blockquote><blockquote><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ol><li>存储.class字节码文件(包括静态变量、方法)</li><li>方法只有一份，通过this来区分具体的对象</li></ol></blockquote><hr><h1 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h1><blockquote><h2 id="集合类的由来"><a href="#集合类的由来" class="headerlink" title="集合类的由来"></a>集合类的由来</h2><p> &emsp;再开发过程中，我们一般用对象来封装特有数据，对象多了就需要存储，如果对象的个数不确定，就是用集合容器进行存储。  </p></blockquote><blockquote><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><p> &emsp;可以将集合理解为就是一个容器，因为面向对象编程会产生很多的对象，对了方便对对象的操作，所以把对象装入到集合，集合本身就是一个对象，能储存对象的对象就叫集合，存储对象的容器，就叫做集合，集合是可变长度的，数组不可变的。  </p></blockquote><blockquote><h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><p> &emsp;用于存储对象的容器，集合长度是可变的，集合中不可以存储基本数据类型值</p></blockquote><blockquote><h2 id="集合框架示意图"><a href="#集合框架示意图" class="headerlink" title="集合框架示意图"></a>集合框架示意图</h2><p><img src="/images/collection.jpg" alt="avatar"></p></blockquote><blockquote><h2 id="Collection框架介绍"><a href="#Collection框架介绍" class="headerlink" title="Collection框架介绍"></a>Collection框架介绍</h2><p>&emsp;Collection是集合框架的顶级接口，Collections是是集合框架的工具类（提供集合共有的一些api）<br>&emsp;Collection接口下有两个子接口，List接口和set接口，如上图  </p></blockquote><blockquote><h3 id="List接口：有序可重复，存储对象有顺序，可以重复"><a href="#List接口：有序可重复，存储对象有顺序，可以重复" class="headerlink" title="List接口：有序可重复，存储对象有顺序，可以重复"></a>List接口：有序可重复，存储对象有顺序，可以重复</h3><p>&emsp; Vector：最早的集合类，现在已经被ArrayList取代。底层也是数组<br>&emsp; ArrayList：底层是数组，有序、可重复、有索引，异步线程不安全、特点：查找效率高，增删效率低<br>&emsp; LinkedList：底层是双向链表，异步线程不安全，特点：增删效率高，查询效率低。不支持高效的随机元素访问。</p></blockquote><blockquote><h3 id="Set接口：无序不可重复。不可存储重复对象，如果有重复，会覆盖。"><a href="#Set接口：无序不可重复。不可存储重复对象，如果有重复，会覆盖。" class="headerlink" title="Set接口：无序不可重复。不可存储重复对象，如果有重复，会覆盖。"></a>Set接口：无序不可重复。不可存储重复对象，如果有重复，会覆盖。</h3><p>&emsp; TreeSet：底层是红黑树(自平衡的排序二叉树)，特点：有序，唯一<br>&emsp; hashSet：底层采用HashMap保存数据。特点：集合元素必须唯一，并且不可重复，无序的。<br>&emsp; LinkHashSet：LinkHashSet继承HashSet，内部是通过LinkedHashMap实现。特点：集合元素必须唯一，并且不可重复，但是有序的。</p><h3 id="Map集合："><a href="#Map集合：" class="headerlink" title="Map集合："></a>Map集合：</h3></blockquote><blockquote><h4 id="emsp-map集合的特点"><a href="#emsp-map集合的特点" class="headerlink" title="&emsp; map集合的特点:"></a>&emsp; map集合的特点:</h4><p>&emsp; map集合是一个双列集合，一个元素包含两个值，一个key，一个value<br>&emsp; map集合中的元素，key和value的数据类型可以相同，也可以不同<br>&emsp; map集合中的元素，key不允许重复，value可以重复<br>&emsp; map集合中的元素，key和value是一一对应的关系。  </p></blockquote><blockquote><h4 id="Map集合与collection集合的区别："><a href="#Map集合与collection集合的区别：" class="headerlink" title="Map集合与collection集合的区别："></a>Map集合与collection集合的区别：</h4><p>&emsp; map集合中元素是成对存在的，每个元素由键与值两个部分组成的，通过键可以找到所对应的值，称之为双列集合。<br>&emsp; collection集合中的元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储，称之为单列集合。  </p></blockquote><blockquote><h4 id="Map集合常用子类："><a href="#Map集合常用子类：" class="headerlink" title="Map集合常用子类："></a>Map集合常用子类：</h4><p>&emsp; HashMap：实现了Map接口，底层是哈希表。无序集合（存储元素和取出元素的顺序有可能不一致），异步多线程，查询的速度块，<br>&emsp; LinkedHashMap：HashMap的子类，底层是哈希表+链表，是一个有序的集合，存取出元素的顺序是一直的，保证迭代的顺序。<br>&emsp; HashTable：实现了Map接口，底层也是哈希表，不允许存储空key和value，线程安全的集合，速度慢，<br>&emsp; properties：HashTable的子类，唯一一个和IO流相结合的集合  </p></blockquote><blockquote><h4 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h4><p>&emsp; HashMap中维持了一个数组，数组的每一个位置称之为一个桶，每一个桶维持了一个链表，一个元素根据哈希吗进行运算，根据运算的结果平均的分配到这个桶中，放用到75%的桶的时候，会进行扩容，桶的数量会增加一倍，已有元素会重新计算哈希吗重新分布，这个过程称之为rehash，默认初始容量为16，即一开始有16个桶，当用到13个桶的时候要进行扩容。由16个桶扩容为32个桶，加载因子越大，碰撞概率越大，加载因子越小，扩容和rehash操作越频繁。  </p></blockquote><blockquote><h4 id="HashMap-为什么速度快？"><a href="#HashMap-为什么速度快？" class="headerlink" title="HashMap 为什么速度快？"></a>HashMap 为什么速度快？</h4><p>&emsp; HashMap 之所以速度快，因为他使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）  </p></blockquote><blockquote><h4 id="hashcode为什么使用31来做相乘？"><a href="#hashcode为什么使用31来做相乘？" class="headerlink" title="hashcode为什么使用31来做相乘？"></a>hashcode为什么使用31来做相乘？</h4><p>&emsp; 之所以使用 31，是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代    。替乘法，可以得到更好的性能： 31 * i == (i &lt;&lt; 5） - i， 现代的 JVM 可以自动完成这种优化。这个公式可以很简单的推导出来  </p></blockquote><blockquote><h2 id="集合常见方法"><a href="#集合常见方法" class="headerlink" title="集合常见方法"></a>集合常见方法</h2><p>集合容器因为内部的数据结构不同，有多种具体容器，不断的向上抽取，就形成了集合框架，集合框架的顶层接口是collections，包含集合的共性方法</p><h3 id="常见方法："><a href="#常见方法：" class="headerlink" title="常见方法："></a>常见方法：</h3><ol><li>添加 ：添加对象  boolean add（Object obj），boolean addAll</li><li>删除： boolean remove（object obj），boolean removeAll（object obj）</li><li>判断：boolean contains(Object obj），boolean containsAll(Boject ooll)，boolean ifEmpty</li><li>获取：int size()；获取集合元素集合的长度。</li></ol></blockquote><blockquote><h2 id="Iterator迭代器："><a href="#Iterator迭代器：" class="headerlink" title="Iterator迭代器："></a>Iterator迭代器：</h2><p>&emsp;专门取出集合中元素的方式，迭代器对象该对象必须依赖具体的容器，因为每一个容器的数据结构都不同，所以迭代器实在容器中进行内部实现的，对于适用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象就可以，也就是iterator方法   </p></blockquote><blockquote><h2 id="迭代器的实现原理："><a href="#迭代器的实现原理：" class="headerlink" title="迭代器的实现原理："></a>迭代器的实现原理：</h2><p>迭代器就是实现了Iterator接口的每一个容器内部的内部对象<br>注意：在迭代器过程中，不要视同集合操作元素，容易出现异常，但是可以使用Iterator接口的子接口，ListIterator来完成在接待中对元素进行更多的操作，他可以实现在迭代过程中，完成对元素的增删改查，注意，只有list集合具备该迭代功能。   </p></blockquote><hr><h1 id="线程总结"><a href="#线程总结" class="headerlink" title="线程总结"></a>线程总结</h1><blockquote><h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><p>计算机在执行的任务就是进程,比如JVM、QQ、微信、迅雷等服务本质上也是进程</p><h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><p>进程中的小任务，多个小任务一起执行就是多线程 </p><h2 id="线程定义的三种方式"><a href="#线程定义的三种方式" class="headerlink" title="线程定义的三种方式"></a>线程定义的三种方式</h2><ol><li>继承Thread类，重写run()方法，将要执行的逻辑写入run方法，并调用start()方法</li><li>实现Runable接口，重写run()方法，通过runnable对象来构建一个Thread对象来启动线程</li><li>实现Callable<T>接口，重写call()方法.</li><li>注意：为什么以上1、2两种方式都需要重写run方法？因为Thread类也实现了Runable接口。</li></ol></blockquote><blockquote><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><ol><li>Thread.currentThread().getName()获取线程的名字</li><li>Thread.seelp(毫秒值) 线程休息一会儿</li></ol></blockquote><blockquote><h2 id="多线程的并发安全问题"><a href="#多线程的并发安全问题" class="headerlink" title="多线程的并发安全问题"></a>多线程的并发安全问题</h2><p>线程的执行不存在先后，而是相互抢占执行，抢占并不是只发生在线程执行的开始，而是发生在线程执行的每一步过程中。由于多个线程并发导致出现一些不符合常理的数据现象—多线程并发安全问题</p></blockquote><blockquote><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>同步代码块可以解决多线程并发安全问题,可以利用synchronize同步代码块来解决此问题<br>synchronize需要指定锁对象,锁对象必须要求是这个类的所有线程都认识<br>共享资源，类的字节码、this（需要是同一个对象，一个对象启动四个线程）<br>synchronize去修饰方法 ，同步方法的锁对象是this   </p></blockquote><blockquote><h2 id="什么是同步和异步"><a href="#什么是同步和异步" class="headerlink" title="什么是同步和异步"></a>什么是同步和异步</h2><p>一段逻辑同一时间内只能一个线程执行，称之为反之叫做异步。<br> 线程同步一定是安全的，而线程不安全一定是异步的。</p></blockquote><blockquote><h2 id="什么是死锁？如何解决死锁问题"><a href="#什么是死锁？如何解决死锁问题" class="headerlink" title="什么是死锁？如何解决死锁问题"></a>什么是死锁？如何解决死锁问题</h2><p>多个线程之间的锁形成了嵌套，导致程序无法继续运行的现象叫做死锁<br> 思考如何避免死锁？<br> &emsp;1.减少线程数量  （理论上是可以，实际开发中不现实）。<br> &emsp;2.统一锁对象<br> &emsp;3.减少锁嵌套</p></blockquote><blockquote><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ol><li>创建状态</li><li>就绪状态</li><li>执行状态</li><li>阻塞状态 / 挂起状态   （人为阻塞 冻结状态）    </li><li>消亡状态</li></ol></blockquote><blockquote><h2 id="Sleep和wait有什么区别："><a href="#Sleep和wait有什么区别：" class="headerlink" title="Sleep和wait有什么区别："></a>Sleep和wait有什么区别：</h2><p>sleep在使用的时候需要指定休眠时间，到点自然醒。释放执行权，不释放锁。是一个静态方法，设计在了Thread类上。wait在使用的时候可以指定等待时间，也可以不指定，如果不指定等待时间就需要唤醒，释放执行权，释放锁，是一个非静态方法，设计在了Object类上。</p></blockquote><blockquote><h2 id="守护线程："><a href="#守护线程：" class="headerlink" title="守护线程："></a>守护线程：</h2><p>守护别的线程，当被守护的线程结束，守护线程无论执行完成与否都得随之结束。 Daemon<br>一个线程要么是守护线程要么是被守护的线程<br>守护线程是随着最后一个被守护线程的结束而结束。   –GC就是一个守护线程。</p></blockquote><blockquote><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>线程的优先级。1-10个等级   没有手动设置的情况下优先级默认是5。<br>理论上数字越大等级越高，这个线程抢到资源的几率越大，相邻的两个线程的优先级的差异性不明显，至少要相差5个等级才能体现的相对明显</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java基础知识整理&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础知识" scheme="https://courage-kevin.github.io/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://courage-kevin.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
